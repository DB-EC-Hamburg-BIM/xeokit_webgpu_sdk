import {LocaleService} from "./localization/LocaleService";
import {Scene} from "./scene/index";
import {Data} from "./data/Data";
import {View} from "./view/View";
import {Plugin} from "./Plugin";
import * as math from "./math/index";
import {scheduler} from "./scheduler";
import {Renderer} from "./scene/Renderer";
import * as utils from "./utils/index";
import {apply, createUUID} from "./utils/index";
import {Events} from "./Events";
import {ViewerCapabilities} from "./ViewerCapabilities";
import {ViewParams} from "./ViewParams";


/**
 * The browser-based viewer at the core of ````@xeokit/xeokit-viewer````.
 *
 * ## Overview
 *
 * A ````Viewer```` has three main components:
 *
 * * {@link Scene} - Contains geometry and materials for models.
 * * {@link Data} - Contains optional semantic information about the models.
 * * {@link View}s - One or more independently-configurable views of the models, each with its own canvas.
 *
 * A ````Viewer```` also has the following strategies, which you can replace with custom implementations if necessary:
 *
 * * {@link Renderer} - Creates and renders geometry and materials on top of the Browser's 3D graphics API.
 * * {@link LocaleService} - Provides string translations for various locales.
 *
 * ## Usage
 *
 * Create a viewer with a WebGL2-based scene renderer:
 *
 * ````javascript
 * const myViewer = new Viewer({
 *     id: "myViewer",
 *     renderer: new WebGL2Renderer({ })
 * });
 * ````
 *
 * Create model geometry and materials:
 *
 * ````javascript
 * const mySceneModel = myViewer.scene.createSceneModel({
 *     id: "myModel"
 * });
 *
 * mySceneModel.createMesh({
 *     id: "myMesh",
 *     primitive: SolidPrimitive,
 *     positions: [...],
 *     indices: [...]
 *     //...
 * });
 *
 * mySceneModel.createObject({
 *     id: "myObject",
 *     meshIds: ["myMesh}]
 *     //...
 * });
 *
 * myModel.finalize();
 * ````
 *
 * Define optional semantic information for the model:
 *
 * ````javascript
 * const myDataModel = myViewer.data.createDataModel({
 *     id: "myModel"
 * });
 *
 * myDataModel.createDataObject({
 *     id: "myObject",
 *     name: "Some object",
 *     type: "MyType"
 * });
 * ````
 *
 * Create a view of the model:
 *
 * ````javascript
 * const view1 = myViewer.createView({
 *     id: "myView",
 *     canvasId: "myCanvas1"
 * });
 *
 * view1.camera.eye = [-3.933, 2.855, 27.018];
 * view1.camera.look = [4.400, 3.724, 8.899];
 * view1.camera.up = [-0.018, 0.999, 0.039];
 * view1.camera.projection = "perspective";
 * view1.cameraControl.navMode = "orbit";
 * ````
 * Customize the view:
 *
 * ````javascript
 * view1.viewObjects["myObject"].highlighted = true;
 * ````
 */
export class Viewer {

    /**
     ID of this Viewer.
     */
    readonly id: string;

    /**
     True once this Viewer has been destroyed.

     Don't use this Viewer if this is ````true````.
     */
    destroyed: boolean;

    /**
     * Indicates the capabilities of this Viewer.
     */
    readonly capabilities: ViewerCapabilities;

    /**
     Manages events on this Viewer.
     */
    readonly events: Events;

    /**
     The viewer's locale service.

     This may be configured via the Viewer's constructor.

     By default, this service will be an instance of {@link LocaleService}, which will just return
     null translations for all given strings and phrases.
     */
    readonly localeService: LocaleService;

    /**
     Metadata about the models and objects within the Viewer's {@link Scene}.
     */
    readonly data: Data;

    /**
     The Viewer's {@link Scene}.
     */
    readonly scene: Scene;

    /**
     The {@link View}s belonging to this Viewer, each keyed to {@link View#id}.
     */
    readonly views: { [key: string]: View };

    /**
     List of {@link View}s belonging to this Viewer.
     */
    readonly viewList: View[];

    /**
     The number of {@link View}s belonging to this Viewer.
     */
    numViews: number;

    /**
     List of {@link Plugin}s installed in this Viewer.
     @private
     */
    readonly pluginList: Plugin[];

    /**
     The time that this Viewer was created.
     */
    readonly startTime: number = (new Date()).getTime();

    /**
     The renderer.
     @private
     */
    readonly renderer: Renderer;

    /**
     Creates a Viewer.

     @param cfg - Viewer configuration.
     @param cfg.id - ID for this Viewer, automatically generated by default.
     @param cfg.units - The measurement unit type. Accepted values are ````"meters"````, ````"metres"````, , ````"centimeters"````, ````"centimetres"````, ````"millimeters"````,  ````"millimetres"````, ````"yards"````, ````"feet"```` and ````"inches"````.
     @param cfg.scale - The number of Real-space units in each World-space coordinate system unit.
     @param cfg.origin - The Real-space 3D origin, in current measurement units, at which the World-space coordinate origin ````[0,0,0]```` sits.
     @param cfg.localeService - Locale-based translation service.
     @param cfg.renderer - Configurable 3D renderer class. Will be a  {@link WebGL2Renderer} by default.
     */
    constructor(cfg: {
        id?: string,
        units?: string,
        scale?: number,
        origin?: math.FloatArrayType,
        localeService?: LocaleService,
        renderer?: Renderer
    } = {}) {

        this.capabilities = {
            maxViews: 0,
            astcSupported: false,
            etc1Supported: false,
            etc2Supported: false,
            dxtSupported: false,
            bptcSupported: false,
            pvrtcSupported: false
        };

        this.renderer.getCapabilities(this.capabilities);

        this.id = cfg.id || createUUID();
        this.destroyed = false;
        this.events = new Events();
        this.localeService = cfg.localeService || new LocaleService();
        this.data = new Data(this);
        this.scene = new Scene(this, {});
        this.viewList = [];
        this.numViews = 0;
        this.pluginList = [];
        this.views = {};

        this.renderer = cfg.renderer;

        this.renderer.init(this);

        scheduler.registerViewer(this);
    }

    /**
     * Creates a new {@link View} within this Viewer.
     *
     * * Fires a "viewCreated" event on this Viewer.
     * * To destroy the View after use, call {@link View.destroy}, which fires a "viewDestroyed" event on this Viewer.
     * * You must add a View to the Viewer before you can create or load content into the Viewer's Scene.
     * * The maximum number of views you're allowed to create is provided in {@link ViewerCapabilities.maxViews}.
     *
     * ### Usage
     *
     * ````javascript
     * const view1 = myViewer.createView({
     *      id: "myView",
     *      canvasId: "myCanvas1"
     *  });
     *
     * view1.camera.eye = [-3.933, 2.855, 27.018];
     * view1.camera.look = [4.400, 3.724, 8.899];
     * view1.camera.up = [-0.018, 0.999, 0.039];
     *
     * //...
     * ````
     *
     * @param cfg
     */
    createView(cfg: ViewParams): View {
        if (this.viewList.length >= this.capabilities.maxViews) {
            this.error(`Attempted to create too many Views with View.createView() - maximum of ${this.capabilities.maxViews} is allowed`);
            return null;
        }
        let id = cfg.id || createUUID();
        if (this.views[id]) {
            this.error(`View with ID "${id}" already exists - will randomly-generate ID`);
            id = createUUID();
        }
        const canvasElement = cfg.canvasElement || document.getElementById(cfg.canvasId);
        if (!(canvasElement instanceof HTMLCanvasElement)) {
            throw "Mandatory View config expected: valid canvasId or canvasElement";
        }
        const view = new View(apply({id, viewer: this}, cfg));
        this.#registerView(view);
        view.events.on("destroyed", () => {
            this.#deregisterView(view);
            this.events.fire("viewDestroyed", view);
        });
        this.events.fire("viewCreated", view);
        return view;
    }

    /**
     @private
     */
    registerPlugin(plugin: Plugin): void {
        this.pluginList.push(plugin);
    }

    /**
     @private
     */
    deregisterPlugin(plugin: Plugin): void {
        for (let i = 0, len = this.pluginList.length; i < len; i++) {
            const p = this.pluginList[i];
            if (p === plugin) {
                p.clear();
                this.pluginList.splice(i, 1);
                return;
            }
        }
    }

    /**
     @private
     */
    sendToPlugins(name: string, value?: any) {
        for (let i = 0, len = this.pluginList.length; i < len; i++) {
            const p = this.pluginList[i];
            if (p.send) {
                p.send(name, value);
            }
        }
    }

    /**
     @private
     */
    recompile() {
        for (let id in this.views) {
            this.views[id].recompile();
        }
    }

    /**
     Trigger a redraw of all {@link View}s belonging to this Viewer.

     @private
     */
    redraw(): void {
        for (let id in this.views) {
            this.views[id].redraw();
        }
    }

    /**
     Logs a console debugging message for this Viewer.

     The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*

     Also fires the message as a "log" event on the parent {@link Viewer}.

     @private
     @param message - The message to log
     */
    log(message: string): void {
        message = `[LOG] ${this.#prefixMessageWithID(message)}`;
        window.console.log(message);
        //   this.viewer.events.fire("log", message);
    }

    /**
     Logs a warning for this Viewer to the JavaScript console.

     The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*

     Also fires the message as a "warn" event on the parent {@link Viewer}.

     @private
     @param message - The warning message to log
     */
    warn(message: string): void {
        message = `[WARN] ${this.#prefixMessageWithID(message)}`;
        window.console.warn(message);
        // this.viewer.events.fire("warn", message);
    }

    /**
     Logs an error for this Viewer to the JavaScript console.

     The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*

     Also fires the message as an "error" event on the {@link Viewer}.

     @private
     @param message The error message to log
     */
    error(message: string): void {
        message = `[ERROR] ${this.#prefixMessageWithID(message)}`;
        window.console.error(message);
        // this.viewer.events.fire("error", message);
    }

    /**
     Destroys this Viewer and all {@link View}s, {@link SceneModel}s, {@link DataModel}s and {@link Plugin}s we've created within it.
     */
    destroy(): void {
        if (this.destroyed) {
            return;
        }
        scheduler.deregisterViewer(this);
        const pluginList = this.pluginList.slice(); // Array will modify as we delete plugins
        for (let i = 0, len = pluginList.length; i < len; i++) {
            const plugin = pluginList[i];
            plugin.destroy();
        }
        // for (let id in this.views) {
        //     this.views[id].destroy();
        // }
        // this.scene.destroy();
    }

    #prefixMessageWithID(message: string): string {
        return ` [${this.constructor.name} "${utils.inQuotes(this.id)}"]: ${message}`;
    }

    #registerView(view: View): void {
        if (this.views[view.id]) {
            return;
        }
        this.views[view.id] = view;
        for (let viewIndex = 0; ; viewIndex++) {
            if (!this.viewList[viewIndex]) {
                this.viewList[viewIndex] = view;
                // @ts-ignore
                this.numViews++;
                view.viewIndex = viewIndex;
                return;
            }
        }
    }

    #deregisterView(view: View): void {
        if (!this.views[view.id]) {
            return;
        }
        delete this.views[view.id];
        delete this.viewList[view.viewIndex];
        // @ts-ignore
        this.numViews--;
    }
}

