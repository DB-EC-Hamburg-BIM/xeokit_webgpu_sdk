<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Concepts | xeokit-sdk</title>
	<meta name="description" content="Documentation for xeokit-sdk">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
	<script async src="../assets/js/search.js" id="search-script"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.json" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">xeokit-sdk</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../modules.html">xeokit-sdk</a>
				</li>
				<li>
					<a href="pages.html">pages</a>
				</li>
				<li>
					<a href="pages.concepts.html">Concepts</a>
				</li>
			</ul>
			<h1>Namespace Concepts</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-comment">
				<div class="tsd-comment tsd-typography">
					<div class="lead">
						<a href="#concepts" id="concepts" style="color: inherit; text-decoration: none;">
							<h1>Concepts</h1>
						</a>
						<p>The glTF format defines high-level abstractions for concepts like scenes, nodes, meshes, and all other properties of a runtime 3D model. The <a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">glTF 2.0 Quick Reference Guide</a>, provides a solid introduction to those concepts. A simplified overview (skipping some orthogonal details of animation, cameras, and lights) is presented here, for reference in writing scripts using the xeokit-sdk APIs.</p>
						<figure>
							<img alt="glTF concept diagram" src="media/concepts.png">
							<figcaption>
								<em><strong>Figure:</strong> Concept diagram showing most of the glTF 2.0 format. Greyed-out properties (Sampler, Image, BufferView) are managed automatically (or nearly so) by the xeokit-sdk API, and are not discussed in detail here.</em>
							</figcaption>
						</figure>
						<a href="#properties-and-references" id="properties-and-references" style="color: inherit; text-decoration: none;">
							<h2>Properties and references</h2>
						</a>
						<p>In a runtime-ready glTF file, any properties available for use (and reuse) are listed in top-level JSON arrays at the root of the asset:</p>
						<pre><code class="language-js"><span style="color: #000000">{</span>
<span style="color: #000000">  </span><span style="color: #A31515">&quot;scenes&quot;</span><span style="color: #000000">: [...],</span>
<span style="color: #000000">  </span><span style="color: #A31515">&quot;meshes&quot;</span><span style="color: #000000">: [...],</span>
<span style="color: #000000">  </span><span style="color: #A31515">&quot;materials&quot;</span><span style="color: #000000">: [...],</span>
<span style="color: #000000">  </span><span style="color: #A31515">&quot;nodes&quot;</span><span style="color: #000000">: [...],</span>
<span style="color: #000000">  ...</span>
<span style="color: #000000">}</span>
</code></pre>
						<p>Throughout the asset, those properties are referenced by indices into the top-level array. For example, a node defined as <code>{&quot;mesh&quot;: 0}</code> will instantiate the mesh found at index <code>0</code> of the top-level <code>meshes</code> array. These indexed arrays are useful for efficient loading, which is the primary goal of glTF 2.0, but are cumbersome for direct editing — which, to be fair, is generally the domain of interchange formats like COLLADA or USD.</p>
						<p>In xeokit-sdk, the conceptual model of these {@link Root}-level arrays is preserved, but all index-based pointers are managed by references and an internal graph structure, instead. For example, to list each {@link Mesh} available for reuse in a glTF document:</p>
						<pre><code class="language-typescript"><span style="color: #001080">doc</span><span style="color: #000000">.</span><span style="color: #795E26">getRoot</span><span style="color: #000000">()</span>
<span style="color: #000000">  .</span><span style="color: #795E26">listMeshes</span><span style="color: #000000">()</span>
<span style="color: #000000">  .</span><span style="color: #795E26">forEach</span><span style="color: #000000">((</span><span style="color: #001080">mesh</span><span style="color: #000000">) </span><span style="color: #0000FF">=&gt;</span><span style="color: #000000"> {</span>
<span style="color: #000000">    </span><span style="color: #001080">console</span><span style="color: #000000">.</span><span style="color: #795E26">log</span><span style="color: #000000">(</span><span style="color: #001080">mesh</span><span style="color: #000000">);</span>
<span style="color: #000000">  });</span>
</code></pre>
						<p>Positions in root-level arrays are fluid until the final glTF file is written, and references to properties are given by passing objects directly:</p>
						<pre><code class="language-typescript"><span style="color: #008000">// Find an existing Mesh named &#039;Cog&#039;.</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">mesh</span><span style="color: #000000"> = </span><span style="color: #001080">doc</span><span style="color: #000000">.</span><span style="color: #795E26">getRoot</span><span style="color: #000000">()</span>
<span style="color: #000000">  .</span><span style="color: #795E26">listMeshes</span><span style="color: #000000">()</span>
<span style="color: #000000">  .</span><span style="color: #795E26">find</span><span style="color: #000000">((</span><span style="color: #001080">mesh</span><span style="color: #000000">) </span><span style="color: #0000FF">=&gt;</span><span style="color: #000000"> </span><span style="color: #001080">mesh</span><span style="color: #000000">.</span><span style="color: #795E26">getName</span><span style="color: #000000">() === </span><span style="color: #A31515">&#039;Cog&#039;</span><span style="color: #000000">);</span>

<span style="color: #008000">// Instantiate a copy of the &#039;Cog&#039; mesh at a new node, &#039;CogInstance1&#039;.</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">cogNode</span><span style="color: #000000"> = </span><span style="color: #001080">doc</span><span style="color: #000000">.</span><span style="color: #795E26">createNode</span><span style="color: #000000">(</span><span style="color: #A31515">&#039;CogInstance1&#039;</span><span style="color: #000000">)</span>
<span style="color: #000000">  .</span><span style="color: #795E26">setMesh</span><span style="color: #000000">(</span><span style="color: #001080">mesh</span><span style="color: #000000">);</span>

<span style="color: #008000">// Add the Node to a Scene.</span>
<span style="color: #001080">doc</span><span style="color: #000000">.</span><span style="color: #795E26">listScenes</span><span style="color: #000000">()[</span><span style="color: #098658">0</span><span style="color: #000000">]</span>
<span style="color: #000000">  .</span><span style="color: #795E26">addChild</span><span style="color: #000000">(</span><span style="color: #001080">cogNode</span><span style="color: #000000">);</span>

<span style="color: #008000">// List all references to the &#039;Cog&#039; mesh.</span>
<span style="color: #001080">mesh</span><span style="color: #000000">.</span><span style="color: #795E26">listParents</span><span style="color: #000000">(); </span><span style="color: #008000">// → [cogNode, ...]</span>
</code></pre>
						<p>The same approach applies to any property that can hold references or be referenced within a glTF file. As the {@link Mesh} above can identify each {@link Node} that holds a reference to it, low-level properties like {@link Texture} and {@link Accessor} instances can similarly look up the locations in which they are used. A directed graph structure maintains these references automatically.</p>
						<p>To remove all uses of a <a href="../classes/packages_viewer_src.property.html">Property</a>, simply <code>.detach()</code> or <code>dispose()</code> the object. Properties that are detached but not disposed are still exported, although — without any references to them from a <a href="../classes/packages_viewer_src.scene.html">Scene</a> — you may need to write client logic to load them individually.</p>
						<a href="#binary-data" id="binary-data" style="color: inherit; text-decoration: none;">
							<h2>Binary data</h2>
						</a>
						<p>Similarly, the binary data in an exported glTF file is laid out tightly packed for GPU upload, with the JSON metadata of the file providing byte offsets and byte lengths for each vertex attribute or animation sampler. These byte offsets are described by Accessors and BufferViews. While this structure is ideal for efficient loading, it would normally present a challenge for directly editing a file: adding a single vertex to a Mesh might shift byte offsets used throughout the Buffer, requiring updates to any other Mesh or Animation referencing that Buffer.</p>
						<p>xeokit-sdk maintains the concept of an {@link Accessor}, but simplifies its use: the typed array is isolated during editing, and can be resized or deleted without affecting other data. Each Accessor has a reference to a {@link Buffer}, but that reference is only used to tell the exporter where to put the Accessor&#39;s data, when the model is finally written. Assigning Accessors to specific Buffers allows the data to be grouped for lazy-loading — if all Accessors for a specific Mesh are stored in an independent Buffer, the client does not need to fetch that Buffer until it needs to load that particular Mesh.</p>
						<blockquote>
							<p><strong>NOTICE:</strong> The concept of a BufferView is not visible in xeokit-sdk: the library creates an interleaved BufferView for each mesh at export, and automatically generates additional BufferViews for any remaining data.</p>
						</blockquote>
						<p>To edit a Mesh vertex:</p>
						<pre><code class="language-typescript"><span style="color: #008000">// A Mesh may contain multiple Primitives, but in this case we only need to</span>
<span style="color: #008000">// edit a particular vertex in the first Primitive.</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">primitive</span><span style="color: #000000"> = </span><span style="color: #001080">mesh</span><span style="color: #000000">.</span><span style="color: #795E26">listPrimitives</span><span style="color: #000000">()[</span><span style="color: #098658">0</span><span style="color: #000000">];</span>

<span style="color: #008000">// Find the Accessor storing vertex position data, and update the 10th vertex.</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">positionAccessor</span><span style="color: #000000"> = </span><span style="color: #001080">primitive</span><span style="color: #000000">.</span><span style="color: #795E26">getAttribute</span><span style="color: #000000">(</span><span style="color: #A31515">&#039;POSITION&#039;</span><span style="color: #000000">);</span>
<span style="color: #001080">positionAccessor</span><span style="color: #000000">.</span><span style="color: #795E26">setElement</span><span style="color: #000000">(</span><span style="color: #098658">10</span><span style="color: #000000">, [</span><span style="color: #098658">0</span><span style="color: #000000">, </span><span style="color: #098658">0</span><span style="color: #000000">, </span><span style="color: #098658">0</span><span style="color: #000000">]);</span>
</code></pre>
						<p>To allocate more vertices, or change the accessor type, replace its underlying array:</p>
						<pre><code class="language-typescript"><span style="color: #008000">// Make a copy of the Accessor&#039;s array, and allocate 100 empty vertices.</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">prevArray</span><span style="color: #000000"> = </span><span style="color: #001080">accessor</span><span style="color: #000000">.</span><span style="color: #795E26">getArray</span><span style="color: #000000">();</span>
<span style="color: #0000FF">const</span><span style="color: #000000"> </span><span style="color: #0070C1">nextArray</span><span style="color: #000000"> = </span><span style="color: #0000FF">new</span><span style="color: #000000"> </span><span style="color: #267F99">Float32Array</span><span style="color: #000000">(</span><span style="color: #001080">prevArray</span><span style="color: #000000">.</span><span style="color: #001080">length</span><span style="color: #000000"> + </span><span style="color: #098658">3</span><span style="color: #000000"> * </span><span style="color: #098658">100</span><span style="color: #000000">);</span>
<span style="color: #001080">nextArray</span><span style="color: #000000">.</span><span style="color: #795E26">set</span><span style="color: #000000">(</span><span style="color: #001080">prevArray</span><span style="color: #000000">);</span>

<span style="color: #008000">// Assign the modified array.</span>
<span style="color: #001080">accessor</span><span style="color: #000000">.</span><span style="color: #795E26">setArray</span><span style="color: #000000">(</span><span style="color: #001080">nextArray</span><span style="color: #000000">);</span>
</code></pre>
						<p>Most internal glTF properies are handled automatically when changing the array. In some cases (when setting uint- or int-typed arrays) you will need to pay attention to the glTF schema&#39;s allowed component types, and normalize your data where necessary. The KHR_mesh_quantization extension provides additional flexibility on data types.</p>
						<p>For a deeper look at the xeokit-sdk API, refer to the documentation for the {@link Document} class and its associated <a href="../classes/packages_viewer_src.property.html">Property</a> types.</p>
					</div>
				</div>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class=" ">
						<a href="../modules.html">Modules</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-namespace"><span class="tsd-kind-icon">Namespace</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
</body>
</html>