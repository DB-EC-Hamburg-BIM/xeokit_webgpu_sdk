{"version":3,"file":"index.modern.mjs","sources":["../src/Property.ts","../src/PropertySet.ts","../src/DataObject.ts","../src/Relationship.ts","../src/DataModel.ts","../src/Data.ts"],"sourcesContent":["import type {PropertySet} from \"./PropertySet\";\nimport type {PropertyParams} from \"./PropertyParams\";\n\n/**\n * A property in a {@link PropertySet}.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Property {\n\n    /**\n     * The PropertySet to which this Property belongs.\n     */\n    public readonly propertySet: PropertySet;\n\n    /**\n     * The name of this property.\n     */\n    public readonly name: string;\n\n    /**\n     * The value of this property.\n     */\n    public readonly value: any;\n\n    /**\n     * The type of this property.\n     */\n    public readonly type?: string | number;\n\n    /**\n     * The type of this property's value.\n     */\n    public readonly valueType?: string | number;\n\n    /**\n     * Informative text to explain the property.\n     */\n    public readonly description?: string;\n\n    /**\n     * @private\n     * @ignore\n     */\n    constructor(\n        propertySet: PropertySet,\n        propertyCfg: PropertyParams) {\n        this.propertySet = propertySet;\n        this.name = propertyCfg.name;\n        this.type = propertyCfg.type\n        this.value = propertyCfg.value\n        this.valueType = propertyCfg.valueType;\n        this.description = propertyCfg.description;\n    }\n}\n","import {Property} from \"./Property\";\nimport type {DataModel} from \"./DataModel\";\nimport type {PropertyParams} from \"./PropertyParams\";\nimport type {PropertySetParams} from \"./PropertySetParams\";\n\n/**\n * A set of {@link Property | Properties} in a {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Created with {@link DataModel.createPropertySet | DataModel.createPropertySet}\n * * Stored in {@link Data.propertySets | Data.propertySets} and {@link DataModel.propertySets | Data.propertySets}\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class PropertySet {\n\n    /**\n     * The DataModels to which this PropertySet belongs.\n     */\n    public readonly models: DataModel[];\n\n    /**\n     * Unique ID.\n     *\n     * PropertySet instances are registered by this ID in {@link Data.propertySets | Data.propertySets}\n     * and {@link DataModel.propertySets | DataModel.propertySets}.\n     */\n    public readonly id: string;\n\n    /**\n     * ID of the corresponding object within the originating system, if any.\n     */\n    public readonly originalSystemId?: string;\n\n    /**\n     * Human-readable name of this PropertySet.\n     */\n    public readonly name: string;\n\n    /**\n     * Type of this PropertySet.\n     */\n    public readonly type: string;\n\n    /**\n     * Properties within this PropertySet.\n     */\n    public readonly properties: Property[];\n\n    /**\n     * @private\n     */\n    constructor(\n        dataModel: DataModel,\n        propertySetCfg: PropertySetParams) {\n        this.models = [dataModel];\n        this.id = propertySetCfg.id;\n        this.name = propertySetCfg.name;\n        this.type = propertySetCfg.type;\n        this.properties = [];\n        if (propertySetCfg.properties) {\n            for (let i = 0, len = propertySetCfg.properties.length; i < len; i++) {\n                const property = new Property(this, propertySetCfg.properties[i]);\n                this.properties.push(property);\n            }\n        }\n    }\n}\n","import type {PropertySet} from \"./PropertySet\";\nimport type {DataModel} from \"./DataModel\";\nimport type {Relationship} from \"./Relationship\";\nimport type {Data} from \"./Data\";\n\n/**\n * An object in a {@link @xeokit/data!DataModel}.\n *\n * * Created with {@link DataModel.createObject | DataModel.createObject}\n * * Stored in {@link Data.objects | Data.objects}, {@link Data.rootObjects | Data.rootObjects}, {@link Data.objectsByType | Data.objectsByType}, {@link DataModel.objects | Data.objects}, {@link DataModel.rootObjects | Data.rootObjects}\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class DataObject {\n\n    /**\n     *  {@link Data} that contains this DataObject.\n     */\n    public data: Data;\n\n    /**\n     * {@link DataModel | DataModels} that share this DataObject.\n     */\n    public models: DataModel[];\n\n    /**\n     * Globally-unique ID.\n     *\n     * DataObjects are stored by ID in {@link Data.objects | Data.objects}, {@link Data.rootObjects | Data.rootObjects}, {@link Data.objectsByType | Data.objectsByType} and {@link DataModel.rootObjects | Data.rootObjects}.\n     */\n    public readonly id: string;\n\n    /**\n     * Human-readable name.\n     */\n    public readonly name?: string;\n\n    /**\n     * DataObject's type.\n     */\n    public readonly type: number;\n\n    /**\n     * {@link PropertySet | PropertySets} referenced by this DataObject.\n     */\n    public readonly propertySets?: PropertySet[];\n\n    /**\n     * The {@link Relationship | Relations} in which this DataObject is the {@link Relationship.relating} participant.\n     *\n     * Each DataObject is mapped here by {@link Relationship.type | Relationship.type} and sub-mapped by {@link Relationship.relating | Relationship.relating}.\n     */\n    public readonly relating: {\n        [key: number]: Relationship[]\n    };\n\n    /**\n     * The {@link Relationship | Relationships} in which this DataObject is the {@link Relationship.related} participant.\n     *\n     * Each DataObject is mapped here by {@link Relationship.type | Relationship.type} and sub-mapped by {@link Relationship.related | Relationship.related}.\n     */\n    public readonly related: {\n        [key: number]: Relationship[]\n    };\n\n    /**\n     * @private\n     */\n    constructor(\n        data: Data,\n        model: DataModel,\n        id: string,\n        name: string,\n        type: number,\n        propertySets?: PropertySet[]) {\n\n        this.data = data;\n        this.models = [model];\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.propertySets = propertySets || [];\n        this.related = {};\n        this.relating = {};\n    }\n}\n","import type {DataObject} from \"./DataObject\";\n\n/**\n * A one-to-one relationship between two {@link DataObject | DataObjects}.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Relationship {\n\n    /**\n     * The type of this Relationship.\n     *\n     * This can be any value that identifies the Relationship type within your DataModel.\n     */\n    readonly type: number;\n\n    /**\n     * The relating {@link DataObject} in this Relationship.\n     *\n     * This Relationship will be stored by {@link DataObject.type | DataObject.type}\n     * in the DataObject's {@link DataObject.relatedObject | DataObject.relatedObject} attribute.\n     */\n    readonly relatingObject: DataObject;\n\n    /**\n     * The related {@link DataObject} in this Relationship.\n     *\n     * This Relationship will be stored by {@link DataObject.type | DataObject.type} in\n     * the DataObject's {@link DataObject.relatingObject | DataObject.relatingObject} attribute.\n     */\n    readonly relatedObject: DataObject;\n\n    /**\n     * @private\n     * @ignore\n     */\n    constructor(type: number, relatingObject: DataObject, relatedObject: DataObject) {\n        this.type = type;\n        this.relatingObject = relatingObject;\n        this.relatedObject = relatedObject;\n    }\n}\n","import {Component, EventEmitter, SDKError} from \"@xeokit/core\";\nimport type {Data} from \"./Data\";\nimport {PropertySet} from \"./PropertySet\";\nimport {DataObject} from \"./DataObject\";\nimport type {DataModelParams} from \"./DataModelParams\";\nimport type {DataObjectParams} from \"./DataObjectParams\";\nimport type {PropertySetParams} from \"./PropertySetParams\";\nimport {Relationship} from \"./Relationship\";\nimport type {RelationshipParams} from \"./RelationshipParams\";\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport type {PropertyParams} from \"./PropertyParams\";\n\n/**\n * xeokit Semantic Data Model.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class DataModel extends Component {\n\n    /**\n     * The Data that contains this DataModel.\n     */\n    public readonly data: Data;\n\n    /**\n     * Unique ID of this DataModel.\n     *\n     * DataModels are stored against this ID in {@link Data.models}.\n     */\n    declare public readonly id: string;\n\n    /**\n     * The project ID, if available.\n     */\n    public readonly projectId?: string | number;\n\n    /**\n     * The revision ID, if available.\n     */\n    public readonly revisionId?: string | number;\n\n    /**\n     * The model author, if available.\n     */\n    public readonly author?: string;\n\n    /**\n     * The date the model was created, if available.\n     */\n    public readonly createdAt?: string;\n\n    /**\n     * The application that created the model, if available.\n     */\n    public readonly creatingApplication?: string;\n\n    /**\n     * The model schema version, if available.\n     */\n    public readonly schema?: string;\n\n    /**\n     * The {@link PropertySet | PropertySets} in this DataModel, mapped to {@link PropertySet.id | PropertySet.id}.\n     *\n     * PropertySets have globally-unique IDs and will also be stored in {@link Data.propertySets | Data.propertySets}.\n     */\n    public readonly propertySets: { [key: string]: PropertySet };\n\n    /**\n     * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.id | DataObject.id}.\n     *\n     * DataObjects have globally-unique IDs and will also be stored in {@link Data.objects | Data.objects}.\n     */\n    public objects: { [key: string]: DataObject };\n\n    /**\n     * The root {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.id | DataObject.id}.\n     *\n     * * This is the set of DataObjects in this DataModel that are not the *related* participant in\n     * any {@link Relationship | Relationships}, where they have no incoming Relationships and\n     * their {@link DataObject.relating} property is empty.\n     */\n    public rootObjects: { [key: string]: DataObject };\n\n    /**\n     * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.type | DataObject.type},\n     * sub-mapped to {@link DataObject.id | DataObject.id}.\n     */\n    public objectsByType: { [key: string]: { [key: string]: DataObject } };\n\n    /**\n     * The {@link Relationship | Relationships} in this DataModel.\n     *\n     * * The Relationships can be between DataObjects in different DataModels, but always within the same Data.\n     */\n    public relationships: Relationship[];\n\n    /**\n     * The count of each type of {@link DataObject} in this DataModel, mapped to {@link DataObject.type | DataObject.type}.\n     */\n    public readonly typeCounts: { [key: string]: number };\n\n    /**\n     * Emits an event when the {@link @xeokit/data!DataModel} has been built.\n     *\n     * * The DataModel is built using {@link DataModel.build | DataModel.build}.\n     * * {@link DataModel.built | DataModel.built} indicates if the DataModel is currently built.\n     * * Don't create anything more in this DataModel once it's built.\n     *\n     * @event\n     */\n    public readonly onBuilt: EventEmitter<DataModel, null>;\n\n    /**\n     * Indicates if this DataModel has been built.\n     *\n     * * Set true by {@link DataModel.build | DataModel.build}.\n     * * Subscribe to updates using {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | Data.onModelCreated}.\n     */\n    built: boolean;\n\n    #destroyed: boolean;\n\n    /**\n     * @private\n     */\n    constructor(\n        data: Data,\n        id: string,\n        dataModelParams: DataModelParams,\n        options?: {\n            includeTypes?: string[],\n            excludeTypes?: string[],\n            globalizeObjectIds?: boolean\n        }) {\n\n        super(data);\n\n        this.onBuilt = new EventEmitter(new EventDispatcher<DataModel, null>());\n\n        this.data = data;\n\n        this.id = id;\n        this.projectId = dataModelParams.projectId || \"\";\n        this.revisionId = dataModelParams.revisionId || \"\";\n        this.author = dataModelParams.author || \"\";\n        this.createdAt = dataModelParams.createdAt || \"\";\n        this.creatingApplication = dataModelParams.creatingApplication || \"\";\n        this.schema = dataModelParams.schema || \"\";\n        this.propertySets = {};\n        this.objects = {};\n        this.objectsByType = {};\n        this.relationships = [];\n        this.typeCounts = {};\n        this.rootObjects = {};\n        this.built = false;\n        this.#destroyed = false;\n\n        this.fromJSON(dataModelParams);\n    }\n\n    /**\n     * Adds the given components to this DataModel.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param dataModelParams\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A duplicate PropertySet was already created for this DataModel.\n     * * A duplicate DataObject was already created in this DataModel.\n     * * DataObjects were not found for a Relationship.\n     */\n    fromJSON(dataModelParams: DataModelParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to add components to DataModel - DataModel already destroyed\");\n        }\n        if (this.built) {\n            throw new SDKError(\"Failed to add components to DataModel - DataModel already built\");\n        }\n        if (dataModelParams.propertySets) {\n            for (let i = 0, len = dataModelParams.propertySets.length; i < len; i++) {\n                this.createPropertySet(dataModelParams.propertySets[i]);\n            }\n        }\n        if (dataModelParams.objects) {\n            for (let i = 0, len = dataModelParams.objects.length; i < len; i++) {\n                this.createObject(dataModelParams.objects[i]);\n            }\n        }\n        if (dataModelParams.relationships) {\n            for (let i = 0, len = dataModelParams.relationships.length; i < len; i++) {\n                this.createRelationship(dataModelParams.relationships[i]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertySet}.\n     *\n     * * Stores the new PropertySet in {@link DataModel.propertySets | DataModel.propertySets}\n     * and {@link Data.propertySets | Data.propertySets}.\n     * * Note that PropertySet IDs are globally unique. PropertySet instances are automatically reused and shared among DataModels\n     * when IDs given to {@link DataModel.createPropertySet | DataModel.createPropertySet} match existing PropertySet\n     * instances in the same Data.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     *  const propertySet = dataModel.createPropertySet({\n     *      id: \"myPropertySet\",\n     *      name: \"My properties\",\n     *      properties: [{\n     *          name: \"Weight\",\n     *          value: 5,\n     *          type: \"\",\n     *          valueType: \"\",\n     *          description: \"Weight of a thing\"\n     *      }, {\n     *          name: \"Height\",\n     *          value: 12,\n     *          type: \"\",\n     *          valueType: \"\",\n     *          description: \"Height of a thing\"\n     *      }]\n     * });\n     *\n     * if (propertySet instanceof SDKError) {\n     *     console.error(propertySet.message);\n     * } else {\n     *     // Success\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param propertySetCfg - PropertySet creation parameters.\n     * @returns *{@link PropertySet}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A PropertySet of the given ID was already created for this DataModel. While it's OK\n     * for multiple DataModels to *share* PropertySets with duplicate IDs between them, it's not permitted to\n     * create duplicate PropertySets within the same DataModel.\n     */\n    createPropertySet(propertySetCfg: PropertySetParams): PropertySet | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create PropertySet - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"DataModel already built\");\n        }\n        if (this.propertySets[propertySetCfg.id]) {\n            return new SDKError(\"Failed to create PropertySet - PropertySet with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.\")\n        }\n        let propertySet = this.data.propertySets[propertySetCfg.id];\n        if (propertySet) {\n            this.propertySets[propertySetCfg.id] = propertySet;\n            propertySet.models.push(this);\n            return propertySet;\n        }\n        propertySet = new PropertySet(this, propertySetCfg);\n        this.propertySets[propertySetCfg.id] = propertySet;\n        this.data.propertySets[propertySetCfg.id] = propertySet;\n        return propertySet;\n    }\n\n    /**\n     * Creates a new {@link DataObject}.\n     *\n     * * Stores the new {@link DataObject} in {@link DataModel.objects | DataModel.objects} and {@link Data.objects | Data.objects}.\n     * * Fires an event via {@link Data.onObjectCreated | Data.onObjectCreated}.\n     * * Note that DataObject IDs are globally unique. DataObject instances are automatically reused and shared among DataModels when\n     * IDs given to {@link DataModel.createObject | DataModel.createObject} match existing DataObject instances in the same\n     * Data. This feature is part of how xeokit supports [*federated data models*](/docs/pages/GLOSSARY.html#federated-models).\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const myDataObject = dataModel.createObject({\n     *     id: \"myDataObject\",\n     *     type: BasicEntity,     // @xeokit/datatypes!basicTypes\n     *     name: \"My Object\",\n     *     propertySetIds: [\"myPropertySet\"]\n     * });\n     *\n     * const myDataObject2 = dataModel.createObject({\n     *     id: \"myDataObject2\",\n     *     name: \"My Other Object\",\n     *     type: BasicEntity,\n     *     propertySetIds: [\"myPropertySet\"]\n     * });\n     *\n     * if (myDataObject instanceof SDKError) {\n     *     console.error(myDataObject.message);\n     *\n     * } else if (myDataObject2 instanceof SDKError) {\n     *     console.error(myDataObject2.message);\n     *\n     * } else { // Success\n     *     const gotMyDataObject = dataModel.objects[\"myDataObject\"];\n     *     const gotMyDataObjectAgain = data.objects[\"myDataObject\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param dataObjectParams - DataObject creation parameters.\n     * @returns *{@link DataObject}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A DataObject of the given ID was already created in this DataModel. While it's OK\n     * for multiple DataModels to *share* DataObjects with duplicate IDs between them, we're not permitted to\n     * create duplicate DataObjects within the same DataModel.\n     * * A specified PropertySet could not be found.\n     */\n    createObject(dataObjectParams: DataObjectParams): DataObject | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create DataObject - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create DataObject - DataModel already built\");\n        }\n        const id = dataObjectParams.id;\n        if (this.objects[id]) {\n            return new SDKError(\"Failed to create DataObject - DataObject with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.\")\n        }\n        const type = dataObjectParams.type;\n        let dataObject = this.data.objects[id];\n        if (!dataObject) {\n            const propertySets = [];\n            if (dataObjectParams.propertySetIds) {\n                for (let i = 0, len = dataObjectParams.propertySetIds.length; i < len; i++) {\n                    const propertySetId = dataObjectParams.propertySetIds[i];\n                    const propertySet = this.propertySets[propertySetId];\n                    if (!propertySet) {\n                        return new SDKError(`Failed to create DataObject - PropertySet not found: \"${propertySetId}\"`);\n                    } else {\n                        propertySets.push(propertySet);\n                    }\n                }\n            }\n            dataObject = new DataObject(this.data, this, id, dataObjectParams.name, dataObjectParams.type, propertySets);\n            this.objects[id] = dataObject;\n            this.data.objects[id] = dataObject;\n            if (!this.data.objectsByType[type]) {\n                this.data.objectsByType[type] = {};\n            }\n            this.data.objectsByType[type][id] = dataObject;\n            this.data.typeCounts[type] = (this.data.typeCounts[type] === undefined) ? 1 : this.data.typeCounts[type] + 1;\n            dataObject.models.push(this);\n            // if (dataObjectParams.relations) {\n            //     for (let relationType in dataObjectParams.relations) {\n            //         if (!dataObject.relating[relationType]) {\n            //             dataObject.relating[relationType] = [];\n            //         }\n            //         const relatedObjectIds = dataObjectParams.relations[relationType];\n            //         for (let j = 0, lenj = relatedObjectIds.length; j < lenj; j++) {\n            //             const relatedObjectId = relatedObjectIds[j];\n            //             const relatedObject = this.data.objects[relatedObjectId];\n            //             if (!relatedObject) {\n            //                 this.error(`[createObject] Can't create Relationship - DataObject not found: ${relatedObjectId}`);\n            //             } else {\n            //                 // @ts-ignore\n            //                 const relation = new Relationship(relationType, this, relatedObject);\n            //                 relatedObject.relating[relationType].push(relation);\n            //                 dataObject.related[relationType].push(relation);\n            //             }\n            //         }\n            //     }\n            // }\n            this.data.onObjectCreated.dispatch(this.data, dataObject);\n        } else {\n            this.objects[id] = dataObject;\n            this.data.objects[id] = dataObject;\n            if (!this.objectsByType[type]) {\n                this.objectsByType[type] = {};\n            }\n            this.objectsByType[type][id] = dataObject;\n            this.typeCounts[type] = (this.typeCounts[type] === undefined) ? 1 : this.typeCounts[type] + 1;\n            dataObject.models.push(this);\n        }\n        return dataObject;\n    }\n\n    /**\n     * Creates a new {@link Relationship} between two existing {@link DataObject | DataObjects}.\n     *\n     * * A Relationship involves a *relating* DataObject and a *related* DataObject.\n     * * The *relating* and *related* DataObjects can exist within different DataModels,\n     * as long as the DataModels both exist in the same {@link Data}. This feature is part of\n     * how xeokit supports the viewing of [*federated models*](/docs/pages/GLOSSARY.html#federated-models).\n     * * The new Relationship will be stored in\n     *   - {@link DataModel.relationships | DataModel.relationships},\n     *   - {@link DataObject.related | DataObject.related} on the *relating* DataObject, and\n     *   - {@link DataObject.relating | DataObject.relating} on the *related* DataObject.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const myRelationship = dataModel.createRelationship({\n     *     type: BasicAggregation,            // @xeokit/datatypes!basicTypes\n     *     relatingObjectId: \"myDataObject\",\n     *     relatedObjectId: \"myDataObject2\"\n     * });\n     *\n     * if (myRelationship instanceof SDKError) {\n     *     console.error(myRelationship.message);\n     *\n     * } else { // Success\n     *     const myDataObject = dataModel.objects[\"myDataObject\"];\n     *     const myDataObject2 = dataModel.objects[\"myDataObject2\"];\n     *\n     *     const gotMyRelationship = myDataObject.related[BasicAggregation][0];\n     *     const gotMyRelationshipAgain = myDataObject2.relating[BasicAggregation][0];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param relationshipParams - Relationship creation parameters.\n     * @returns *{@link Relationship}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built or destroyed.\n     * * The *relating* DataObject was not found in the {@link Data} that contains this DataModel.\n     * * The *related* DataObject was not found in the Data that contains this DataModel.\n     */\n    createRelationship(relationshipParams: RelationshipParams): Relationship | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Relationship - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Relationship - DataModel already built\");\n        }\n        const relatingObject = this.data.objects[relationshipParams.relatingObjectId];\n        if (!relatingObject) {\n            return new SDKError(`Failed to create Relationship - relating DataObject not found: ${relationshipParams.relatingObjectId}`);\n        }\n        const relatedObject = this.data.objects[relationshipParams.relatedObjectId];\n        if (!relatedObject) {\n            return new SDKError(`Failed to create Relationship - related DataObject not found: ${relationshipParams.relatedObjectId}`);\n        }\n        const relation = new Relationship(relationshipParams.type, relatingObject, relatedObject);\n        if (!relatedObject.relating[relationshipParams.type]) {\n            relatedObject.relating[relationshipParams.type] = [];\n        }\n        relatedObject.relating[relationshipParams.type].push(relation);\n        if (!relatingObject.related[relationshipParams.type]) {\n            relatingObject.related[relationshipParams.type] = [];\n        }\n        relatingObject.related[relationshipParams.type].push(relation);\n        this.relationships.push(relation);\n        return relation;\n    }\n\n    /**\n     * Finalizes this DataModel, readying it for use.\n     *\n     * * Fires an event via {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | DataModel.onCreated}, to indicate to subscribers that\n     * the DataModel is complete and ready to use.\n     * * Sets {@link DataModel.built | DataModel.built} ````true````.\n     * * You can only call this method once on a DataModel.\n     * * Once built, no more components can be created in a DataModel.\n     *\n     * ````javascript\n     * dataModel.onBuilt.subscribe(()=>{\n     *     // Our DataModel is built and ready to use\n     * });\n     *\n     * data.onModelCreated.subscribe((dataModel)=>{\n     *     // Another way to subscribe to DataModel readiness\n     * });\n     *\n     * const result = dataModel.build();\n     *\n     * if (result instanceof SDKError) {\n     *     console.error(result.message);\n     * } else {\n     *     // Success\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built or destroyed.\n     */\n    build(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to build DataModel - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to build DataModel - DataModel already built\");\n        }\n        this.built = true;\n        this.onBuilt.dispatch(this, null);\n    }\n\n    getJSON(): DataModelParams | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"DataModel already built\");\n        }\n        const dataModelParams = <DataModelParams>{\n            id: this.id,\n            propertySets: [],\n            objects: [],\n            relationships: []\n        };\n\n        for (let id in this.propertySets) {\n            const propertySet = this.propertySets[id];\n            const propertySetParams = <PropertySetParams>{\n                id,\n                name: propertySet.name,\n                properties: [],\n                type: propertySet.type,\n                originalSystemId: propertySet.originalSystemId\n            };\n            for (let i = 0, len = propertySet.properties.length; i < len; i++) {\n                const property = propertySet.properties[i];\n                const propertyParams = <PropertyParams>{\n                    name: property.name,\n                    value: property.value,\n                    type: property.type,\n                    valueType: property.valueType,\n                    description: property.description\n                };\n                propertySetParams.properties.push(propertyParams);\n            }\n            dataModelParams.propertySets?.push(propertySetParams);\n        }\n        for (let id in this.objects) {\n            const object = this.objects[id];\n            const objectParams = <DataObjectParams>{\n                id,\n                type: object.type,\n                name: object.name,\n                propertySetIds: []\n            };\n            if (object.propertySets) {\n                for (let i = 0, len = object.propertySets.length; i < len; i++) {\n                    const propertySet = object.propertySets[i];\n                    objectParams.propertySetIds?.push(propertySet.id);\n                }\n            }\n            dataModelParams.objects?.push(objectParams);\n        }\n        for (let i = 0, len = this.relationships.length; i < len; i++) {\n            const relationship = this.relationships[i];\n            const relationParams = <RelationshipParams>{\n                type: relationship.type,\n                relatingObjectId: relationship.relatingObject.id,\n                relatedObjectId: relationship.relatedObject.id\n            };\n            dataModelParams.relationships?.push(relationParams);\n        }\n        return dataModelParams;\n    }\n\n    /**\n     * Destroys this DataModel.\n     *\n     * * Fires an event via {@link DataModel.onDestroyed | DataModel.onDestroyed} and {@link Data.onModelDestroyed | Data.onModelDestroyed}.\n     * * You can only call this method once on a DataModel.\n     * * Once destroyed, no more components can be created in a DataModel.\n     * * Does not matter if the DataModel has not yet been built.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been destroyed.\n     */\n    destroy(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to destroy DataModel - DataModel already destroyed\");\n        }\n        for (let id in this.objects) {\n            const dataObject = this.objects[id];\n            if (dataObject.models.length > 1) {\n                this.#removeObjectFromModels(dataObject);\n            } else {\n                delete this.data.objects[id];\n                const type = dataObject.type;\n                if ((--this.data.typeCounts[type]) === 0) {\n                    delete this.data.typeCounts[type];\n                    delete this.data.objectsByType[type];\n                    this.data.onObjectDestroyed.dispatch(this.data, dataObject);\n                    for (let type in dataObject.relating) {\n                        const relations = dataObject.relating[type];\n                        for (let i = 0, len = relations.length; i < len; i++) {\n                            const relation = relations[i];\n                            const related = relation.relatedObject;\n                            const list = related.relating[type];\n                            for (let j = 0, k = 0, lenj = list.length; j < lenj; j++) {\n                                if (list[k].relatingObject === dataObject) {\n                                    // Splice j from related.relating[type]\n                                    list[j] = list[j]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // if (dataObject.parent) {\n            //     const objects = dataObject.parent.objects;\n            //     objects.length--;\n            //     let f = false;\n            //     for (let i = 0, len = objects.length; i < len; i++) {\n            //         if (f || (f = objects[i] === dataObject)) {\n            //             objects[i] = objects[i + 1];\n            //         }\n            //     }\n            // }\n        }\n        this.#destroyed = true;\n        this.onBuilt.clear();\n        super.destroy();\n    }\n\n    // #removePropertySetFromModels(dataObject: DataObject) {\n    //     for (let i = 0, len = dataObject.models.length; i < len; i++) {\n    //         if (dataObject.models[i] === this) {\n    //             dataObject.models = dataObject.models.splice(i, 1);\n    //             break;\n    //         }\n    //     }\n    // }\n\n    #removeObjectFromModels(dataObject: DataObject) {\n        for (let i = 0, len = dataObject.models.length; i < len; i++) {\n            if (dataObject.models[i] === this) {\n                dataObject.models = dataObject.models.splice(i, 1);\n                break;\n            }\n        }\n    }\n}\n\n","import {Component, EventEmitter, SDKError} from \"@xeokit/core\";\n\nimport {DataModel} from \"./DataModel\";\nimport type {DataObject} from \"./DataObject\";\nimport type {PropertySet} from \"./PropertySet\";\nimport type {DataModelParams} from \"./DataModelParams\";\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport type {SearchParams} from \"./SearchParams\";\n\n/**\n * An entity-relationship semantic data model.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Data extends Component {\n\n    /**\n     * The {@link @xeokit/data!DataModel | DataModels} belonging to this Data, each keyed to\n     * its {@link @xeokit/data!DataModel.id | DataModel.id}.\n     */\n    public readonly models: { [key: string]: DataModel };\n\n    /**\n     * The {@link PropertySet | PropertySets} belonging to this Data, mapped to {@link PropertySet.id | PropertySet.id}.\n     */\n    public readonly propertySets: { [key: string]: PropertySet };\n\n    /**\n     * The {@link DataObject | DataObjects} in this Data, mapped to {@link DataObject.id | DataObject.id}.\n     */\n    public readonly objects: { [key: string]: DataObject };\n\n    /**\n     * The root {@link DataObject | DataObjects} belonging to this Data, each keyed to its {@link DataObject.id | DataObject.id}.\n     *\n     * * This is the set of DataObjects in the DataModels within this Data that are not the *related* participant in\n     * any {@link Relationship | Relationships}, where they have no incoming Relationships and\n     * their {@link DataObject.relating} property is empty.\n     */\n    public readonly rootObjects: { [key: string]: DataObject };\n\n    /**\n     * The {@link DataObject | DataObjects} belonging to this Data, each map keyed to {@link DataObject.type | DataObject.type},\n     * containing {@link DataObject | DataObjects} keyed to {@link DataObject.id | DataObject.id}.\n     */\n    public readonly objectsByType: { [key: string]: { [key: string]: DataObject } };\n\n    /**\n     * Tracks number of {@link DataObject | DataObjects} of each type in this Data.\n     */\n    public readonly typeCounts: { [key: string]: number };\n\n    /**\n     * Emits an event each time a {@link @xeokit/data!DataModel} has been created in this Data.\n     *\n     * @event\n     */\n    public readonly onModelCreated: EventEmitter<Data, DataModel>;\n\n    /**\n     * Emits an event each time a {@link @xeokit/data!DataModel} has been destroyed within this Data.\n     *\n     * @event\n     */\n    public readonly onModelDestroyed: EventEmitter<Data, DataModel>;\n\n    /**\n     * Emits an event each time a {@link DataObject} is created within this Data.\n     *\n     * @event\n     */\n    public readonly onObjectCreated: EventEmitter<Data, DataObject>;\n\n    /**\n     * Emits an event each time a {@link DataObject} is destroyed within this Data.\n     *\n     * @event\n     */\n    public readonly onObjectDestroyed: EventEmitter<Data, DataObject>;\n\n    /**\n     * Creates a new Data.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     */\n    constructor() {\n\n        super(null, {});\n\n        this.models = {};\n        this.propertySets = {};\n        this.objects = {};\n        this.rootObjects = {};\n        this.objectsByType = {};\n        this.typeCounts = {};\n\n        this.onModelCreated = new EventEmitter(new EventDispatcher<Data, DataModel>());\n        this.onModelDestroyed = new EventEmitter(new EventDispatcher<Data, DataModel>());\n        this.onObjectCreated = new EventEmitter(new EventDispatcher<Data, DataObject>());\n        this.onObjectDestroyed = new EventEmitter(new EventDispatcher<Data, DataObject>());\n    }\n\n    /**\n     * Creates a new {@link @xeokit/data!DataModel} in this Data.\n     *\n     * Remember to call {@link DataModel.build | DataModel.build} when you've finished building or loading the DataModel. That will\n     * fire events via {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}, to\n     * indicate to any subscribers that the DataModel is built and ready for use.\n     *\n     * Note that while we're building/loading the SceneModel, each call that we make to {@link DataModel.createObject | DataModel.createObject}\n     * will create a new {@link DataObject}\n     * in {@link Data.objects | Data.objects} and {@link DataModel.objects | DataModel.objects}, and will also fire an event\n     * via {@link Data.onObjectCreated | Data.onObjectCreated}. However,\n     * only when we've received the {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}\n     * events can we actually consider the DataModel to be fully constructed.\n     *\n     * See {@link \"@xeokit/data\"} for more details on usage.\n     *\n     * @param  dataModelParams Creation parameters for the new {@link @xeokit/data!DataModel}.\n     * @param [options] Options for creating the {@link @xeokit/data!DataModel}.\n     * @param [options.includeTypes] When provided, only create {@link DataObject | DataObjects} with types in this list.\n     * @param  [options.excludeRelating] When provided, never create {@link DataObject | DataObjects} with types in this list.\n     * @returns {@link DataModel}\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     * * A DataModel with the given ID already exists in this Data.\n     */\n    createModel(\n        dataModelParams: DataModelParams,\n        options?: {\n            includeRelating?: string[],\n            excludeRelating?: string[],\n        }\n    ): DataModel | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        let id = dataModelParams.id;\n        if (this.models[id]) {\n            return new SDKError(`DataModel already created in this Data: ${id}`);\n        }\n        // @ts-ignore\n        const dataModel = new DataModel(this, id, dataModelParams, options);\n        this.models[dataModel.id] = dataModel;\n        dataModel.onDestroyed.one(() => { // DataModel#destroy() called\n            delete this.models[dataModel.id];\n            this.onModelDestroyed.dispatch(this, dataModel);\n        });\n        dataModel.onBuilt.one(() => { // DataModel#build() called\n            this.onModelCreated.dispatch(this, dataModel);\n        });\n        return dataModel;\n    }\n\n    /**\n     * Gets the {@link DataObject.id}s of the {@link DataObject | DataObjects} that have the given {@link DataObject.type}.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param type The type.\n     * @returns {string[]}\n     * * Array of {@link DataObject.id}s on success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    getObjectIdsByType(type: string): string[] | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        const objects = this.objectsByType[type];\n        return objects ? Object.keys(objects) : [];\n    }\n\n    /**\n     * Finds {@link DataObject | DataObjects} using a customized depth-first traversal.\n     *\n     * Usually we use this method to recursively find DataObjects of specific {@link DataObject.type | types} within\n     * a hierarchy.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param searchParams Search parameters.\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     * * The specified starting DataObject was not found in this Data.\n     * * The specified starting DataObject is contained in a different Data than this one.\n     */\n    searchObjects(searchParams: SearchParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        const includeObjects = (searchParams.includeObjects && searchParams.includeObjects.length > 0) ? arrayToMap(searchParams.includeObjects) : null;\n        const excludeObjects = (searchParams.excludeObjects && searchParams.excludeObjects.length > 0) ? arrayToMap(searchParams.excludeObjects) : null;\n        const includeRelating = (searchParams.includeRelating && searchParams.includeRelating.length > 0) ? arrayToMap(searchParams.includeRelating) : null;\n        const excludeRelating = (searchParams.excludeRelating && searchParams.excludeRelating.length > 0) ? arrayToMap(searchParams.excludeRelating) : null;\n\n        function visit(dataObject: DataObject, depth: number) {\n            if (!dataObject) {\n                return;\n            }\n            let includeObject = true;\n            if (excludeObjects && excludeObjects[dataObject.type]) {\n                includeObject = false;\n            } else { // @ts-ignore\n                if (includeObjects && (!includeObjects[dataObject.type])) {\n                    includeObject = false;\n                }\n            }\n            if (depth === 0 && searchParams.includeStart === false) {\n                includeObject = false;\n            }\n            if (includeObject) {\n                if (searchParams.resultObjectIds) {\n                    searchParams.resultObjectIds.push(dataObject.id);\n                } else if (searchParams.resultObjects) {\n                    searchParams.resultObjects.push(dataObject);\n                } else if (searchParams.resultCallback) {\n                    if (searchParams.resultCallback(dataObject)) {\n                    }\n                }\n            }\n            const related = dataObject.related;\n            for (let type in related) {\n                const relations = related[type];\n                if (relations) {\n                    for (let i = 0, len = relations.length; i < len; i++) {\n                        let includeRelation = true;\n                        if (excludeRelating && excludeRelating[dataObject.type]) {\n                            includeRelation = false;\n                        } else {\n                            if (includeRelating && (!includeRelating[dataObject.type])) {\n                                includeRelation = false;\n                            }\n                        }\n                        if (includeRelation) {\n                            visit(relations[i].relatedObject, depth + 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        const depth = 0;\n        if (searchParams.startObjectId) {\n            const startObject = this.objects[searchParams.startObjectId];\n            if (!startObject) {\n                return new SDKError(`Failed to search DataObjects - starting DataObject not found in Data: \"${searchParams.startObjectId}\"`);\n            }\n            visit(startObject, depth);\n        } else if (searchParams.startObject) {\n            if (searchParams.startObject.data != this) {\n                return new SDKError(`Failed to search DataObjects - starting DataObject not in same Data: \"${searchParams.startObjectId}\"`);\n            }\n            visit(searchParams.startObject, depth + 1);\n        } else {\n            for (let id in this.rootObjects) {\n                visit(this.rootObjects[id], depth + 1);\n            }\n        }\n    }\n\n    /**\n     * Destroys all contained {@link DataModel | DataModels}.\n     *\n     * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     * for each existing DataModel in this Data.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    clear(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        for (let id in this.models) {\n            this.models[id].destroy();\n        }\n    }\n\n    /**\n     * Destroys this Data and all contained {@link DataModel | DataModels}.\n     *\n     * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     * for each existing DataModels in this Data.\n     * * Unsubscribes all subscribers to {@link Data.onModelCreated | Data.onModelCreated}, {@link Data.onModelDestroyed | Data.onModelDestroyed}, {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    destroy(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        this.clear();\n        this.onModelCreated.clear();\n        this.onModelDestroyed.clear();\n        super.destroy();\n    }\n}\n\nfunction arrayToMap(array: any[]): { [key: string]: any } {\n    const map: { [key: string]: any } = {};\n    for (let i = 0, len = array.length; i < len; i++) {\n        map[array[i]] = true;\n    }\n    return map;\n}\n\n"],"names":["Property","constructor","propertySet","propertyCfg","this","name","value","type","valueType","description","PropertySet","dataModel","propertySetCfg","models","id","originalSystemId","properties","i","len","length","property","push","DataObject","data","model","propertySets","relating","related","Relationship","relatingObject","relatedObject","_destroyed","_classPrivateFieldLooseKey","_removeObjectFromModels","DataModel","Component","dataModelParams","options","super","Object","defineProperty","_removeObjectFromModels2","projectId","revisionId","author","createdAt","creatingApplication","schema","objects","rootObjects","objectsByType","relationships","typeCounts","onBuilt","built","writable","EventEmitter","EventDispatcher","_classPrivateFieldLooseBase","fromJSON","destroyed","SDKError","createPropertySet","createObject","createRelationship","dataObjectParams","dataObject","undefined","propertySetIds","propertySetId","onObjectCreated","dispatch","relationshipParams","relatingObjectId","relatedObjectId","relation","build","getJSON","_dataModelParams$prop","propertySetParams","_dataModelParams$obje","object","objectParams","_objectParams$propert","_dataModelParams$rela","relationship","destroy","onObjectDestroyed","relations","list","j","k","lenj","clear","splice","Data","onModelCreated","onModelDestroyed","createModel","onDestroyed","one","getObjectIdsByType","keys","searchObjects","searchParams","includeObjects","arrayToMap","excludeObjects","includeRelating","excludeRelating","visit","depth","includeObject","includeStart","resultObjectIds","resultObjects","resultCallback","includeRelation","startObjectId","startObject","array","map"],"mappings":"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"}