{"version":3,"file":"index.js","sources":["../src/Property.ts","../src/PropertySet.ts","../src/DataObject.ts","../src/Relationship.ts","../src/DataModel.ts","../src/Data.ts"],"sourcesContent":["import type {PropertySet} from \"./PropertySet\";\nimport type {PropertyParams} from \"./PropertyParams\";\n\n/**\n * A property in a {@link PropertySet}.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Property {\n\n    /**\n     * The PropertySet to which this Property belongs.\n     */\n    public readonly propertySet: PropertySet;\n\n    /**\n     * The name of this property.\n     */\n    public readonly name: string;\n\n    /**\n     * The value of this property.\n     */\n    public readonly value: any;\n\n    /**\n     * The type of this property.\n     */\n    public readonly type?: string | number;\n\n    /**\n     * The type of this property's value.\n     */\n    public readonly valueType?: string | number;\n\n    /**\n     * Informative text to explain the property.\n     */\n    public readonly description?: string;\n\n    /**\n     * @private\n     * @ignore\n     */\n    constructor(\n        propertySet: PropertySet,\n        propertyCfg: PropertyParams) {\n        this.propertySet = propertySet;\n        this.name = propertyCfg.name;\n        this.type = propertyCfg.type\n        this.value = propertyCfg.value\n        this.valueType = propertyCfg.valueType;\n        this.description = propertyCfg.description;\n    }\n}\n","import {Property} from \"./Property\";\nimport type {DataModel} from \"./DataModel\";\nimport type {PropertyParams} from \"./PropertyParams\";\nimport type {PropertySetParams} from \"./PropertySetParams\";\n\n/**\n * A set of {@link Property | Properties} in a {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Created with {@link DataModel.createPropertySet | DataModel.createPropertySet}\n * * Stored in {@link Data.propertySets | Data.propertySets} and {@link DataModel.propertySets | Data.propertySets}\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class PropertySet {\n\n    /**\n     * The DataModels to which this PropertySet belongs.\n     */\n    public readonly models: DataModel[];\n\n    /**\n     * Unique ID.\n     *\n     * PropertySet instances are registered by this ID in {@link Data.propertySets | Data.propertySets}\n     * and {@link DataModel.propertySets | DataModel.propertySets}.\n     */\n    public readonly id: string;\n\n    /**\n     * ID of the corresponding object within the originating system, if any.\n     */\n    public readonly originalSystemId?: string;\n\n    /**\n     * Human-readable name of this PropertySet.\n     */\n    public readonly name: string;\n\n    /**\n     * Type of this PropertySet.\n     */\n    public readonly type: string;\n\n    /**\n     * Properties within this PropertySet.\n     */\n    public readonly properties: Property[];\n\n    /**\n     * @private\n     */\n    constructor(\n        dataModel: DataModel,\n        propertySetCfg: PropertySetParams) {\n        this.models = [dataModel];\n        this.id = propertySetCfg.id;\n        this.name = propertySetCfg.name;\n        this.type = propertySetCfg.type;\n        this.properties = [];\n        if (propertySetCfg.properties) {\n            for (let i = 0, len = propertySetCfg.properties.length; i < len; i++) {\n                const property = new Property(this, propertySetCfg.properties[i]);\n                this.properties.push(property);\n            }\n        }\n    }\n}\n","import type {PropertySet} from \"./PropertySet\";\nimport type {DataModel} from \"./DataModel\";\nimport type {Relationship} from \"./Relationship\";\nimport type {Data} from \"./Data\";\n\n/**\n * An object in a {@link @xeokit/data!DataModel}.\n *\n * * Created with {@link DataModel.createObject | DataModel.createObject}\n * * Stored in {@link Data.objects | Data.objects}, {@link Data.rootObjects | Data.rootObjects}, {@link Data.objectsByType | Data.objectsByType}, {@link DataModel.objects | Data.objects}, {@link DataModel.rootObjects | Data.rootObjects}\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class DataObject {\n\n    /**\n     *  {@link Data} that contains this DataObject.\n     */\n    public data: Data;\n\n    /**\n     * {@link DataModel | DataModels} that share this DataObject.\n     */\n    public models: DataModel[];\n\n    /**\n     * Globally-unique ID.\n     *\n     * DataObjects are stored by ID in {@link Data.objects | Data.objects}, {@link Data.rootObjects | Data.rootObjects}, {@link Data.objectsByType | Data.objectsByType} and {@link DataModel.rootObjects | Data.rootObjects}.\n     */\n    public readonly id: string;\n\n    /**\n     * Human-readable name.\n     */\n    public readonly name?: string;\n\n    /**\n     * DataObject's type.\n     */\n    public readonly type: number;\n\n    /**\n     * {@link PropertySet | PropertySets} referenced by this DataObject.\n     */\n    public readonly propertySets?: PropertySet[];\n\n    /**\n     * The {@link Relationship | Relations} in which this DataObject is the {@link Relationship.relating} participant.\n     *\n     * Each DataObject is mapped here by {@link Relationship.type | Relationship.type} and sub-mapped by {@link Relationship.relating | Relationship.relating}.\n     */\n    public readonly relating: {\n        [key: number]: Relationship[]\n    };\n\n    /**\n     * The {@link Relationship | Relationships} in which this DataObject is the {@link Relationship.related} participant.\n     *\n     * Each DataObject is mapped here by {@link Relationship.type | Relationship.type} and sub-mapped by {@link Relationship.related | Relationship.related}.\n     */\n    public readonly related: {\n        [key: number]: Relationship[]\n    };\n\n    /**\n     * @private\n     */\n    constructor(\n        data: Data,\n        model: DataModel,\n        id: string,\n        name: string,\n        type: number,\n        propertySets?: PropertySet[]) {\n\n        this.data = data;\n        this.models = [model];\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.propertySets = propertySets || [];\n        this.related = {};\n        this.relating = {};\n    }\n}\n","import type {DataObject} from \"./DataObject\";\n\n/**\n * A one-to-one relationship between two {@link DataObject | DataObjects}.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Relationship {\n\n    /**\n     * The type of this Relationship.\n     *\n     * This can be any value that identifies the Relationship type within your DataModel.\n     */\n    readonly type: number;\n\n    /**\n     * The relating {@link DataObject} in this Relationship.\n     *\n     * This Relationship will be stored by {@link DataObject.type | DataObject.type}\n     * in the DataObject's {@link DataObject.relatedObject | DataObject.relatedObject} attribute.\n     */\n    readonly relatingObject: DataObject;\n\n    /**\n     * The related {@link DataObject} in this Relationship.\n     *\n     * This Relationship will be stored by {@link DataObject.type | DataObject.type} in\n     * the DataObject's {@link DataObject.relatingObject | DataObject.relatingObject} attribute.\n     */\n    readonly relatedObject: DataObject;\n\n    /**\n     * @private\n     * @ignore\n     */\n    constructor(type: number, relatingObject: DataObject, relatedObject: DataObject) {\n        this.type = type;\n        this.relatingObject = relatingObject;\n        this.relatedObject = relatedObject;\n    }\n}\n","import {Component, EventEmitter, SDKError} from \"@xeokit/core\";\nimport type {Data} from \"./Data\";\nimport {PropertySet} from \"./PropertySet\";\nimport {DataObject} from \"./DataObject\";\nimport type {DataModelParams} from \"./DataModelParams\";\nimport type {DataObjectParams} from \"./DataObjectParams\";\nimport type {PropertySetParams} from \"./PropertySetParams\";\nimport {Relationship} from \"./Relationship\";\nimport type {RelationshipParams} from \"./RelationshipParams\";\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport type {PropertyParams} from \"./PropertyParams\";\n\n/**\n * xeokit Semantic Data Model.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class DataModel extends Component {\n\n    /**\n     * The Data that contains this DataModel.\n     */\n    public readonly data: Data;\n\n    /**\n     * Unique ID of this DataModel.\n     *\n     * DataModels are stored against this ID in {@link Data.models}.\n     */\n    declare public readonly id: string;\n\n    /**\n     * The project ID, if available.\n     */\n    public readonly projectId?: string | number;\n\n    /**\n     * The revision ID, if available.\n     */\n    public readonly revisionId?: string | number;\n\n    /**\n     * The model author, if available.\n     */\n    public readonly author?: string;\n\n    /**\n     * The date the model was created, if available.\n     */\n    public readonly createdAt?: string;\n\n    /**\n     * The application that created the model, if available.\n     */\n    public readonly creatingApplication?: string;\n\n    /**\n     * The model schema version, if available.\n     */\n    public readonly schema?: string;\n\n    /**\n     * The {@link PropertySet | PropertySets} in this DataModel, mapped to {@link PropertySet.id | PropertySet.id}.\n     *\n     * PropertySets have globally-unique IDs and will also be stored in {@link Data.propertySets | Data.propertySets}.\n     */\n    public readonly propertySets: { [key: string]: PropertySet };\n\n    /**\n     * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.id | DataObject.id}.\n     *\n     * DataObjects have globally-unique IDs and will also be stored in {@link Data.objects | Data.objects}.\n     */\n    public objects: { [key: string]: DataObject };\n\n    /**\n     * The root {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.id | DataObject.id}.\n     *\n     * * This is the set of DataObjects in this DataModel that are not the *related* participant in\n     * any {@link Relationship | Relationships}, where they have no incoming Relationships and\n     * their {@link DataObject.relating} property is empty.\n     */\n    public rootObjects: { [key: string]: DataObject };\n\n    /**\n     * The {@link DataObject | DataObjects} in this DataModel, mapped to {@link DataObject.type | DataObject.type},\n     * sub-mapped to {@link DataObject.id | DataObject.id}.\n     */\n    public objectsByType: { [key: string]: { [key: string]: DataObject } };\n\n    /**\n     * The {@link Relationship | Relationships} in this DataModel.\n     *\n     * * The Relationships can be between DataObjects in different DataModels, but always within the same Data.\n     */\n    public relationships: Relationship[];\n\n    /**\n     * The count of each type of {@link DataObject} in this DataModel, mapped to {@link DataObject.type | DataObject.type}.\n     */\n    public readonly typeCounts: { [key: string]: number };\n\n    /**\n     * Emits an event when the {@link @xeokit/data!DataModel} has been built.\n     *\n     * * The DataModel is built using {@link DataModel.build | DataModel.build}.\n     * * {@link DataModel.built | DataModel.built} indicates if the DataModel is currently built.\n     * * Don't create anything more in this DataModel once it's built.\n     *\n     * @event\n     */\n    public readonly onBuilt: EventEmitter<DataModel, null>;\n\n    /**\n     * Indicates if this DataModel has been built.\n     *\n     * * Set true by {@link DataModel.build | DataModel.build}.\n     * * Subscribe to updates using {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | Data.onModelCreated}.\n     */\n    built: boolean;\n\n    #destroyed: boolean;\n\n    /**\n     * @private\n     */\n    constructor(\n        data: Data,\n        id: string,\n        dataModelParams: DataModelParams,\n        options?: {\n            includeTypes?: string[],\n            excludeTypes?: string[],\n            globalizeObjectIds?: boolean\n        }) {\n\n        super(data);\n\n        this.onBuilt = new EventEmitter(new EventDispatcher<DataModel, null>());\n\n        this.data = data;\n\n        this.id = id;\n        this.projectId = dataModelParams.projectId || \"\";\n        this.revisionId = dataModelParams.revisionId || \"\";\n        this.author = dataModelParams.author || \"\";\n        this.createdAt = dataModelParams.createdAt || \"\";\n        this.creatingApplication = dataModelParams.creatingApplication || \"\";\n        this.schema = dataModelParams.schema || \"\";\n        this.propertySets = {};\n        this.objects = {};\n        this.objectsByType = {};\n        this.relationships = [];\n        this.typeCounts = {};\n        this.rootObjects = {};\n        this.built = false;\n        this.#destroyed = false;\n\n        this.fromJSON(dataModelParams);\n    }\n\n    /**\n     * Adds the given components to this DataModel.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param dataModelParams\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A duplicate PropertySet was already created for this DataModel.\n     * * A duplicate DataObject was already created in this DataModel.\n     * * DataObjects were not found for a Relationship.\n     */\n    fromJSON(dataModelParams: DataModelParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to add components to DataModel - DataModel already destroyed\");\n        }\n        if (this.built) {\n            throw new SDKError(\"Failed to add components to DataModel - DataModel already built\");\n        }\n        if (dataModelParams.propertySets) {\n            for (let i = 0, len = dataModelParams.propertySets.length; i < len; i++) {\n                this.createPropertySet(dataModelParams.propertySets[i]);\n            }\n        }\n        if (dataModelParams.objects) {\n            for (let i = 0, len = dataModelParams.objects.length; i < len; i++) {\n                this.createObject(dataModelParams.objects[i]);\n            }\n        }\n        if (dataModelParams.relationships) {\n            for (let i = 0, len = dataModelParams.relationships.length; i < len; i++) {\n                this.createRelationship(dataModelParams.relationships[i]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertySet}.\n     *\n     * * Stores the new PropertySet in {@link DataModel.propertySets | DataModel.propertySets}\n     * and {@link Data.propertySets | Data.propertySets}.\n     * * Note that PropertySet IDs are globally unique. PropertySet instances are automatically reused and shared among DataModels\n     * when IDs given to {@link DataModel.createPropertySet | DataModel.createPropertySet} match existing PropertySet\n     * instances in the same Data.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     *  const propertySet = dataModel.createPropertySet({\n     *      id: \"myPropertySet\",\n     *      name: \"My properties\",\n     *      properties: [{\n     *          name: \"Weight\",\n     *          value: 5,\n     *          type: \"\",\n     *          valueType: \"\",\n     *          description: \"Weight of a thing\"\n     *      }, {\n     *          name: \"Height\",\n     *          value: 12,\n     *          type: \"\",\n     *          valueType: \"\",\n     *          description: \"Height of a thing\"\n     *      }]\n     * });\n     *\n     * if (propertySet instanceof SDKError) {\n     *     console.error(propertySet.message);\n     * } else {\n     *     // Success\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param propertySetCfg - PropertySet creation parameters.\n     * @returns *{@link PropertySet}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A PropertySet of the given ID was already created for this DataModel. While it's OK\n     * for multiple DataModels to *share* PropertySets with duplicate IDs between them, it's not permitted to\n     * create duplicate PropertySets within the same DataModel.\n     */\n    createPropertySet(propertySetCfg: PropertySetParams): PropertySet | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create PropertySet - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"DataModel already built\");\n        }\n        if (this.propertySets[propertySetCfg.id]) {\n            return new SDKError(\"Failed to create PropertySet - PropertySet with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.\")\n        }\n        let propertySet = this.data.propertySets[propertySetCfg.id];\n        if (propertySet) {\n            this.propertySets[propertySetCfg.id] = propertySet;\n            propertySet.models.push(this);\n            return propertySet;\n        }\n        propertySet = new PropertySet(this, propertySetCfg);\n        this.propertySets[propertySetCfg.id] = propertySet;\n        this.data.propertySets[propertySetCfg.id] = propertySet;\n        return propertySet;\n    }\n\n    /**\n     * Creates a new {@link DataObject}.\n     *\n     * * Stores the new {@link DataObject} in {@link DataModel.objects | DataModel.objects} and {@link Data.objects | Data.objects}.\n     * * Fires an event via {@link Data.onObjectCreated | Data.onObjectCreated}.\n     * * Note that DataObject IDs are globally unique. DataObject instances are automatically reused and shared among DataModels when\n     * IDs given to {@link DataModel.createObject | DataModel.createObject} match existing DataObject instances in the same\n     * Data. This feature is part of how xeokit supports [*federated data models*](/docs/pages/GLOSSARY.html#federated-models).\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const myDataObject = dataModel.createObject({\n     *     id: \"myDataObject\",\n     *     type: BasicEntity,     // @xeokit/datatypes!basicTypes\n     *     name: \"My Object\",\n     *     propertySetIds: [\"myPropertySet\"]\n     * });\n     *\n     * const myDataObject2 = dataModel.createObject({\n     *     id: \"myDataObject2\",\n     *     name: \"My Other Object\",\n     *     type: BasicEntity,\n     *     propertySetIds: [\"myPropertySet\"]\n     * });\n     *\n     * if (myDataObject instanceof SDKError) {\n     *     console.error(myDataObject.message);\n     *\n     * } else if (myDataObject2 instanceof SDKError) {\n     *     console.error(myDataObject2.message);\n     *\n     * } else { // Success\n     *     const gotMyDataObject = dataModel.objects[\"myDataObject\"];\n     *     const gotMyDataObjectAgain = data.objects[\"myDataObject\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param dataObjectParams - DataObject creation parameters.\n     * @returns *{@link DataObject}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built.\n     * * If this DataModel has already been destroyed.\n     * * A DataObject of the given ID was already created in this DataModel. While it's OK\n     * for multiple DataModels to *share* DataObjects with duplicate IDs between them, we're not permitted to\n     * create duplicate DataObjects within the same DataModel.\n     * * A specified PropertySet could not be found.\n     */\n    createObject(dataObjectParams: DataObjectParams): DataObject | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create DataObject - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create DataObject - DataModel already built\");\n        }\n        const id = dataObjectParams.id;\n        if (this.objects[id]) {\n            return new SDKError(\"Failed to create DataObject - DataObject with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.\")\n        }\n        const type = dataObjectParams.type;\n        let dataObject = this.data.objects[id];\n        if (!dataObject) {\n            const propertySets = [];\n            if (dataObjectParams.propertySetIds) {\n                for (let i = 0, len = dataObjectParams.propertySetIds.length; i < len; i++) {\n                    const propertySetId = dataObjectParams.propertySetIds[i];\n                    const propertySet = this.propertySets[propertySetId];\n                    if (!propertySet) {\n                        return new SDKError(`Failed to create DataObject - PropertySet not found: \"${propertySetId}\"`);\n                    } else {\n                        propertySets.push(propertySet);\n                    }\n                }\n            }\n            dataObject = new DataObject(this.data, this, id, dataObjectParams.name, dataObjectParams.type, propertySets);\n            this.objects[id] = dataObject;\n            this.data.objects[id] = dataObject;\n            if (!this.data.objectsByType[type]) {\n                this.data.objectsByType[type] = {};\n            }\n            this.data.objectsByType[type][id] = dataObject;\n            this.data.typeCounts[type] = (this.data.typeCounts[type] === undefined) ? 1 : this.data.typeCounts[type] + 1;\n            dataObject.models.push(this);\n            // if (dataObjectParams.relations) {\n            //     for (let relationType in dataObjectParams.relations) {\n            //         if (!dataObject.relating[relationType]) {\n            //             dataObject.relating[relationType] = [];\n            //         }\n            //         const relatedObjectIds = dataObjectParams.relations[relationType];\n            //         for (let j = 0, lenj = relatedObjectIds.length; j < lenj; j++) {\n            //             const relatedObjectId = relatedObjectIds[j];\n            //             const relatedObject = this.data.objects[relatedObjectId];\n            //             if (!relatedObject) {\n            //                 this.error(`[createObject] Can't create Relationship - DataObject not found: ${relatedObjectId}`);\n            //             } else {\n            //                 // @ts-ignore\n            //                 const relation = new Relationship(relationType, this, relatedObject);\n            //                 relatedObject.relating[relationType].push(relation);\n            //                 dataObject.related[relationType].push(relation);\n            //             }\n            //         }\n            //     }\n            // }\n            this.data.onObjectCreated.dispatch(this.data, dataObject);\n        } else {\n            this.objects[id] = dataObject;\n            this.data.objects[id] = dataObject;\n            if (!this.objectsByType[type]) {\n                this.objectsByType[type] = {};\n            }\n            this.objectsByType[type][id] = dataObject;\n            this.typeCounts[type] = (this.typeCounts[type] === undefined) ? 1 : this.typeCounts[type] + 1;\n            dataObject.models.push(this);\n        }\n        return dataObject;\n    }\n\n    /**\n     * Creates a new {@link Relationship} between two existing {@link DataObject | DataObjects}.\n     *\n     * * A Relationship involves a *relating* DataObject and a *related* DataObject.\n     * * The *relating* and *related* DataObjects can exist within different DataModels,\n     * as long as the DataModels both exist in the same {@link Data}. This feature is part of\n     * how xeokit supports the viewing of [*federated models*](/docs/pages/GLOSSARY.html#federated-models).\n     * * The new Relationship will be stored in\n     *   - {@link DataModel.relationships | DataModel.relationships},\n     *   - {@link DataObject.related | DataObject.related} on the *relating* DataObject, and\n     *   - {@link DataObject.relating | DataObject.relating} on the *related* DataObject.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const myRelationship = dataModel.createRelationship({\n     *     type: BasicAggregation,            // @xeokit/datatypes!basicTypes\n     *     relatingObjectId: \"myDataObject\",\n     *     relatedObjectId: \"myDataObject2\"\n     * });\n     *\n     * if (myRelationship instanceof SDKError) {\n     *     console.error(myRelationship.message);\n     *\n     * } else { // Success\n     *     const myDataObject = dataModel.objects[\"myDataObject\"];\n     *     const myDataObject2 = dataModel.objects[\"myDataObject2\"];\n     *\n     *     const gotMyRelationship = myDataObject.related[BasicAggregation][0];\n     *     const gotMyRelationshipAgain = myDataObject2.relating[BasicAggregation][0];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for more usage info.\n     *\n     * @param relationshipParams - Relationship creation parameters.\n     * @returns *{@link Relationship}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built or destroyed.\n     * * The *relating* DataObject was not found in the {@link Data} that contains this DataModel.\n     * * The *related* DataObject was not found in the Data that contains this DataModel.\n     */\n    createRelationship(relationshipParams: RelationshipParams): Relationship | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Relationship - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Relationship - DataModel already built\");\n        }\n        const relatingObject = this.data.objects[relationshipParams.relatingObjectId];\n        if (!relatingObject) {\n            return new SDKError(`Failed to create Relationship - relating DataObject not found: ${relationshipParams.relatingObjectId}`);\n        }\n        const relatedObject = this.data.objects[relationshipParams.relatedObjectId];\n        if (!relatedObject) {\n            return new SDKError(`Failed to create Relationship - related DataObject not found: ${relationshipParams.relatedObjectId}`);\n        }\n        const relation = new Relationship(relationshipParams.type, relatingObject, relatedObject);\n        if (!relatedObject.relating[relationshipParams.type]) {\n            relatedObject.relating[relationshipParams.type] = [];\n        }\n        relatedObject.relating[relationshipParams.type].push(relation);\n        if (!relatingObject.related[relationshipParams.type]) {\n            relatingObject.related[relationshipParams.type] = [];\n        }\n        relatingObject.related[relationshipParams.type].push(relation);\n        this.relationships.push(relation);\n        return relation;\n    }\n\n    /**\n     * Finalizes this DataModel, readying it for use.\n     *\n     * * Fires an event via {@link DataModel.onBuilt | DataModel.onBuilt} and {@link Data.onModelCreated | DataModel.onCreated}, to indicate to subscribers that\n     * the DataModel is complete and ready to use.\n     * * Sets {@link DataModel.built | DataModel.built} ````true````.\n     * * You can only call this method once on a DataModel.\n     * * Once built, no more components can be created in a DataModel.\n     *\n     * ````javascript\n     * dataModel.onBuilt.subscribe(()=>{\n     *     // Our DataModel is built and ready to use\n     * });\n     *\n     * data.onModelCreated.subscribe((dataModel)=>{\n     *     // Another way to subscribe to DataModel readiness\n     * });\n     *\n     * const result = dataModel.build();\n     *\n     * if (result instanceof SDKError) {\n     *     console.error(result.message);\n     * } else {\n     *     // Success\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been built or destroyed.\n     */\n    build(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to build DataModel - DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to build DataModel - DataModel already built\");\n        }\n        this.built = true;\n        this.onBuilt.dispatch(this, null);\n    }\n\n    getJSON(): DataModelParams | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"DataModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"DataModel already built\");\n        }\n        const dataModelParams = <DataModelParams>{\n            id: this.id,\n            propertySets: [],\n            objects: [],\n            relationships: []\n        };\n\n        for (let id in this.propertySets) {\n            const propertySet = this.propertySets[id];\n            const propertySetParams = <PropertySetParams>{\n                id,\n                name: propertySet.name,\n                properties: [],\n                type: propertySet.type,\n                originalSystemId: propertySet.originalSystemId\n            };\n            for (let i = 0, len = propertySet.properties.length; i < len; i++) {\n                const property = propertySet.properties[i];\n                const propertyParams = <PropertyParams>{\n                    name: property.name,\n                    value: property.value,\n                    type: property.type,\n                    valueType: property.valueType,\n                    description: property.description\n                };\n                propertySetParams.properties.push(propertyParams);\n            }\n            dataModelParams.propertySets?.push(propertySetParams);\n        }\n        for (let id in this.objects) {\n            const object = this.objects[id];\n            const objectParams = <DataObjectParams>{\n                id,\n                type: object.type,\n                name: object.name,\n                propertySetIds: []\n            };\n            if (object.propertySets) {\n                for (let i = 0, len = object.propertySets.length; i < len; i++) {\n                    const propertySet = object.propertySets[i];\n                    objectParams.propertySetIds?.push(propertySet.id);\n                }\n            }\n            dataModelParams.objects?.push(objectParams);\n        }\n        for (let i = 0, len = this.relationships.length; i < len; i++) {\n            const relationship = this.relationships[i];\n            const relationParams = <RelationshipParams>{\n                type: relationship.type,\n                relatingObjectId: relationship.relatingObject.id,\n                relatedObjectId: relationship.relatedObject.id\n            };\n            dataModelParams.relationships?.push(relationParams);\n        }\n        return dataModelParams;\n    }\n\n    /**\n     * Destroys this DataModel.\n     *\n     * * Fires an event via {@link DataModel.onDestroyed | DataModel.onDestroyed} and {@link Data.onModelDestroyed | Data.onModelDestroyed}.\n     * * You can only call this method once on a DataModel.\n     * * Once destroyed, no more components can be created in a DataModel.\n     * * Does not matter if the DataModel has not yet been built.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this DataModel has already been destroyed.\n     */\n    destroy(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to destroy DataModel - DataModel already destroyed\");\n        }\n        for (let id in this.objects) {\n            const dataObject = this.objects[id];\n            if (dataObject.models.length > 1) {\n                this.#removeObjectFromModels(dataObject);\n            } else {\n                delete this.data.objects[id];\n                const type = dataObject.type;\n                if ((--this.data.typeCounts[type]) === 0) {\n                    delete this.data.typeCounts[type];\n                    delete this.data.objectsByType[type];\n                    this.data.onObjectDestroyed.dispatch(this.data, dataObject);\n                    for (let type in dataObject.relating) {\n                        const relations = dataObject.relating[type];\n                        for (let i = 0, len = relations.length; i < len; i++) {\n                            const relation = relations[i];\n                            const related = relation.relatedObject;\n                            const list = related.relating[type];\n                            for (let j = 0, k = 0, lenj = list.length; j < lenj; j++) {\n                                if (list[k].relatingObject === dataObject) {\n                                    // Splice j from related.relating[type]\n                                    list[j] = list[j]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // if (dataObject.parent) {\n            //     const objects = dataObject.parent.objects;\n            //     objects.length--;\n            //     let f = false;\n            //     for (let i = 0, len = objects.length; i < len; i++) {\n            //         if (f || (f = objects[i] === dataObject)) {\n            //             objects[i] = objects[i + 1];\n            //         }\n            //     }\n            // }\n        }\n        this.#destroyed = true;\n        this.onBuilt.clear();\n        super.destroy();\n    }\n\n    // #removePropertySetFromModels(dataObject: DataObject) {\n    //     for (let i = 0, len = dataObject.models.length; i < len; i++) {\n    //         if (dataObject.models[i] === this) {\n    //             dataObject.models = dataObject.models.splice(i, 1);\n    //             break;\n    //         }\n    //     }\n    // }\n\n    #removeObjectFromModels(dataObject: DataObject) {\n        for (let i = 0, len = dataObject.models.length; i < len; i++) {\n            if (dataObject.models[i] === this) {\n                dataObject.models = dataObject.models.splice(i, 1);\n                break;\n            }\n        }\n    }\n}\n\n","import {Component, EventEmitter, SDKError} from \"@xeokit/core\";\n\nimport {DataModel} from \"./DataModel\";\nimport type {DataObject} from \"./DataObject\";\nimport type {PropertySet} from \"./PropertySet\";\nimport type {DataModelParams} from \"./DataModelParams\";\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport type {SearchParams} from \"./SearchParams\";\n\n/**\n * An entity-relationship semantic data model.\n *\n * See {@link \"@xeokit/data\"} for usage.\n */\nexport class Data extends Component {\n\n    /**\n     * The {@link @xeokit/data!DataModel | DataModels} belonging to this Data, each keyed to\n     * its {@link @xeokit/data!DataModel.id | DataModel.id}.\n     */\n    public readonly models: { [key: string]: DataModel };\n\n    /**\n     * The {@link PropertySet | PropertySets} belonging to this Data, mapped to {@link PropertySet.id | PropertySet.id}.\n     */\n    public readonly propertySets: { [key: string]: PropertySet };\n\n    /**\n     * The {@link DataObject | DataObjects} in this Data, mapped to {@link DataObject.id | DataObject.id}.\n     */\n    public readonly objects: { [key: string]: DataObject };\n\n    /**\n     * The root {@link DataObject | DataObjects} belonging to this Data, each keyed to its {@link DataObject.id | DataObject.id}.\n     *\n     * * This is the set of DataObjects in the DataModels within this Data that are not the *related* participant in\n     * any {@link Relationship | Relationships}, where they have no incoming Relationships and\n     * their {@link DataObject.relating} property is empty.\n     */\n    public readonly rootObjects: { [key: string]: DataObject };\n\n    /**\n     * The {@link DataObject | DataObjects} belonging to this Data, each map keyed to {@link DataObject.type | DataObject.type},\n     * containing {@link DataObject | DataObjects} keyed to {@link DataObject.id | DataObject.id}.\n     */\n    public readonly objectsByType: { [key: string]: { [key: string]: DataObject } };\n\n    /**\n     * Tracks number of {@link DataObject | DataObjects} of each type in this Data.\n     */\n    public readonly typeCounts: { [key: string]: number };\n\n    /**\n     * Emits an event each time a {@link @xeokit/data!DataModel} has been created in this Data.\n     *\n     * @event\n     */\n    public readonly onModelCreated: EventEmitter<Data, DataModel>;\n\n    /**\n     * Emits an event each time a {@link @xeokit/data!DataModel} has been destroyed within this Data.\n     *\n     * @event\n     */\n    public readonly onModelDestroyed: EventEmitter<Data, DataModel>;\n\n    /**\n     * Emits an event each time a {@link DataObject} is created within this Data.\n     *\n     * @event\n     */\n    public readonly onObjectCreated: EventEmitter<Data, DataObject>;\n\n    /**\n     * Emits an event each time a {@link DataObject} is destroyed within this Data.\n     *\n     * @event\n     */\n    public readonly onObjectDestroyed: EventEmitter<Data, DataObject>;\n\n    /**\n     * Creates a new Data.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     */\n    constructor() {\n\n        super(null, {});\n\n        this.models = {};\n        this.propertySets = {};\n        this.objects = {};\n        this.rootObjects = {};\n        this.objectsByType = {};\n        this.typeCounts = {};\n\n        this.onModelCreated = new EventEmitter(new EventDispatcher<Data, DataModel>());\n        this.onModelDestroyed = new EventEmitter(new EventDispatcher<Data, DataModel>());\n        this.onObjectCreated = new EventEmitter(new EventDispatcher<Data, DataObject>());\n        this.onObjectDestroyed = new EventEmitter(new EventDispatcher<Data, DataObject>());\n    }\n\n    /**\n     * Creates a new {@link @xeokit/data!DataModel} in this Data.\n     *\n     * Remember to call {@link DataModel.build | DataModel.build} when you've finished building or loading the DataModel. That will\n     * fire events via {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}, to\n     * indicate to any subscribers that the DataModel is built and ready for use.\n     *\n     * Note that while we're building/loading the SceneModel, each call that we make to {@link DataModel.createObject | DataModel.createObject}\n     * will create a new {@link DataObject}\n     * in {@link Data.objects | Data.objects} and {@link DataModel.objects | DataModel.objects}, and will also fire an event\n     * via {@link Data.onObjectCreated | Data.onObjectCreated}. However,\n     * only when we've received the {@link Data.onModelCreated | Data.onModelCreated} and {@link DataModel.onBuilt | DataModel.onBuilt}\n     * events can we actually consider the DataModel to be fully constructed.\n     *\n     * See {@link \"@xeokit/data\"} for more details on usage.\n     *\n     * @param  dataModelParams Creation parameters for the new {@link @xeokit/data!DataModel}.\n     * @param [options] Options for creating the {@link @xeokit/data!DataModel}.\n     * @param [options.includeTypes] When provided, only create {@link DataObject | DataObjects} with types in this list.\n     * @param  [options.excludeRelating] When provided, never create {@link DataObject | DataObjects} with types in this list.\n     * @returns {@link DataModel}\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     * * A DataModel with the given ID already exists in this Data.\n     */\n    createModel(\n        dataModelParams: DataModelParams,\n        options?: {\n            includeRelating?: string[],\n            excludeRelating?: string[],\n        }\n    ): DataModel | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        let id = dataModelParams.id;\n        if (this.models[id]) {\n            return new SDKError(`DataModel already created in this Data: ${id}`);\n        }\n        // @ts-ignore\n        const dataModel = new DataModel(this, id, dataModelParams, options);\n        this.models[dataModel.id] = dataModel;\n        dataModel.onDestroyed.one(() => { // DataModel#destroy() called\n            delete this.models[dataModel.id];\n            this.onModelDestroyed.dispatch(this, dataModel);\n        });\n        dataModel.onBuilt.one(() => { // DataModel#build() called\n            this.onModelCreated.dispatch(this, dataModel);\n        });\n        return dataModel;\n    }\n\n    /**\n     * Gets the {@link DataObject.id}s of the {@link DataObject | DataObjects} that have the given {@link DataObject.type}.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param type The type.\n     * @returns {string[]}\n     * * Array of {@link DataObject.id}s on success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    getObjectIdsByType(type: string): string[] | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        const objects = this.objectsByType[type];\n        return objects ? Object.keys(objects) : [];\n    }\n\n    /**\n     * Finds {@link DataObject | DataObjects} using a customized depth-first traversal.\n     *\n     * Usually we use this method to recursively find DataObjects of specific {@link DataObject.type | types} within\n     * a hierarchy.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @param searchParams Search parameters.\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     * * The specified starting DataObject was not found in this Data.\n     * * The specified starting DataObject is contained in a different Data than this one.\n     */\n    searchObjects(searchParams: SearchParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        const includeObjects = (searchParams.includeObjects && searchParams.includeObjects.length > 0) ? arrayToMap(searchParams.includeObjects) : null;\n        const excludeObjects = (searchParams.excludeObjects && searchParams.excludeObjects.length > 0) ? arrayToMap(searchParams.excludeObjects) : null;\n        const includeRelating = (searchParams.includeRelating && searchParams.includeRelating.length > 0) ? arrayToMap(searchParams.includeRelating) : null;\n        const excludeRelating = (searchParams.excludeRelating && searchParams.excludeRelating.length > 0) ? arrayToMap(searchParams.excludeRelating) : null;\n\n        function visit(dataObject: DataObject, depth: number) {\n            if (!dataObject) {\n                return;\n            }\n            let includeObject = true;\n            if (excludeObjects && excludeObjects[dataObject.type]) {\n                includeObject = false;\n            } else { // @ts-ignore\n                if (includeObjects && (!includeObjects[dataObject.type])) {\n                    includeObject = false;\n                }\n            }\n            if (depth === 0 && searchParams.includeStart === false) {\n                includeObject = false;\n            }\n            if (includeObject) {\n                if (searchParams.resultObjectIds) {\n                    searchParams.resultObjectIds.push(dataObject.id);\n                } else if (searchParams.resultObjects) {\n                    searchParams.resultObjects.push(dataObject);\n                } else if (searchParams.resultCallback) {\n                    if (searchParams.resultCallback(dataObject)) {\n                    }\n                }\n            }\n            const related = dataObject.related;\n            for (let type in related) {\n                const relations = related[type];\n                if (relations) {\n                    for (let i = 0, len = relations.length; i < len; i++) {\n                        let includeRelation = true;\n                        if (excludeRelating && excludeRelating[dataObject.type]) {\n                            includeRelation = false;\n                        } else {\n                            if (includeRelating && (!includeRelating[dataObject.type])) {\n                                includeRelation = false;\n                            }\n                        }\n                        if (includeRelation) {\n                            visit(relations[i].relatedObject, depth + 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        const depth = 0;\n        if (searchParams.startObjectId) {\n            const startObject = this.objects[searchParams.startObjectId];\n            if (!startObject) {\n                return new SDKError(`Failed to search DataObjects - starting DataObject not found in Data: \"${searchParams.startObjectId}\"`);\n            }\n            visit(startObject, depth);\n        } else if (searchParams.startObject) {\n            if (searchParams.startObject.data != this) {\n                return new SDKError(`Failed to search DataObjects - starting DataObject not in same Data: \"${searchParams.startObjectId}\"`);\n            }\n            visit(searchParams.startObject, depth + 1);\n        } else {\n            for (let id in this.rootObjects) {\n                visit(this.rootObjects[id], depth + 1);\n            }\n        }\n    }\n\n    /**\n     * Destroys all contained {@link DataModel | DataModels}.\n     *\n     * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     * for each existing DataModel in this Data.\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    clear(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        for (let id in this.models) {\n            this.models[id].destroy();\n        }\n    }\n\n    /**\n     * Destroys this Data and all contained {@link DataModel | DataModels}.\n     *\n     * * Fires {@link Data.onModelDestroyed | Data.onModelDestroyed} and {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     * for each existing DataModels in this Data.\n     * * Unsubscribes all subscribers to {@link Data.onModelCreated | Data.onModelCreated}, {@link Data.onModelDestroyed | Data.onModelDestroyed}, {@link DataModel.onDestroyed | DataModel.onDestroyed}\n     *\n     * See {@link \"@xeokit/data\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Data has already been destroyed.\n     */\n    destroy(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Data already destroyed\");\n        }\n        this.clear();\n        this.onModelCreated.clear();\n        this.onModelDestroyed.clear();\n        super.destroy();\n    }\n}\n\nfunction arrayToMap(array: any[]): { [key: string]: any } {\n    const map: { [key: string]: any } = {};\n    for (let i = 0, len = array.length; i < len; i++) {\n        map[array[i]] = true;\n    }\n    return map;\n}\n\n"],"names":["Property","propertySet","propertyCfg","this","name","value","type","valueType","description","PropertySet","dataModel","propertySetCfg","models","id","originalSystemId","properties","i","len","length","property","push","DataObject","data","model","propertySets","relating","related","Relationship","relatingObject","relatedObject","_destroyed","_classPrivateFieldLooseKey","_removeObjectFromModels","DataModel","_Component","dataModelParams","options","_this","call","Object","defineProperty","_assertThisInitialized","_removeObjectFromModels2","projectId","revisionId","author","createdAt","creatingApplication","schema","objects","rootObjects","objectsByType","relationships","typeCounts","onBuilt","built","writable","EventEmitter","EventDispatcher","_classPrivateFieldLooseBase","fromJSON","_inheritsLoose","_proto","prototype","destroyed","SDKError","createPropertySet","createObject","createRelationship","dataObjectParams","dataObject","undefined","propertySetIds","propertySetId","onObjectCreated","dispatch","relationshipParams","relatingObjectId","relatedObjectId","relation","build","getJSON","_dataModelParams$prop","propertySetParams","_dataModelParams$obje","object","objectParams","_objectParams$propert","_dataModelParams$rela","relationship","destroy","onObjectDestroyed","relations","list","j","lenj","clear","Component","splice","Data","onModelCreated","onModelDestroyed","createModel","_this2","onDestroyed","one","getObjectIdsByType","keys","searchObjects","searchParams","includeObjects","arrayToMap","excludeObjects","includeRelating","excludeRelating","visit","depth","includeObject","includeStart","resultObjectIds","resultObjects","resultCallback","includeRelation","startObjectId","startObject","array","map"],"mappings":"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"}