import{Component as t,EventEmitter as e,SDKError as s}from"@xeokit/core";import{EventDispatcher as i}from"strongly-typed-events";var o=0;function r(t){return"__private_"+o+++"_"+t}function a(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}class d{constructor(t,e){this.propertySet=void 0,this.name=void 0,this.value=void 0,this.type=void 0,this.valueType=void 0,this.description=void 0,this.propertySet=t,this.name=e.name,this.type=e.type,this.value=e.value,this.valueType=e.valueType,this.description=e.description}}class n{constructor(t,e){if(this.models=void 0,this.id=void 0,this.originalSystemId=void 0,this.name=void 0,this.type=void 0,this.properties=void 0,this.models=[t],this.id=e.id,this.name=e.name,this.type=e.type,this.properties=[],e.properties)for(let t=0,s=e.properties.length;t<s;t++){const s=new d(this,e.properties[t]);this.properties.push(s)}}}class l{constructor(t,e,s,i,o,r){this.data=void 0,this.models=void 0,this.id=void 0,this.name=void 0,this.type=void 0,this.propertySets=void 0,this.relating=void 0,this.related=void 0,this.data=t,this.models=[e],this.id=s,this.name=i,this.type=o,this.propertySets=r||[],this.related={},this.relating={}}}class h{constructor(t,e,s){this.type=void 0,this.relatingObject=void 0,this.relatedObject=void 0,this.type=t,this.relatingObject=e,this.relatedObject=s}}var c=/*#__PURE__*/r("destroyed"),p=/*#__PURE__*/r("removeObjectFromModels");class y extends t{constructor(t,s,o,r){super(t),Object.defineProperty(this,p,{value:u}),this.data=void 0,this.projectId=void 0,this.revisionId=void 0,this.author=void 0,this.createdAt=void 0,this.creatingApplication=void 0,this.schema=void 0,this.propertySets=void 0,this.objects=void 0,this.rootObjects=void 0,this.objectsByType=void 0,this.relationships=void 0,this.typeCounts=void 0,this.onBuilt=void 0,this.built=void 0,Object.defineProperty(this,c,{writable:!0,value:void 0}),this.onBuilt=new e(new i),this.data=t,this.id=s,this.projectId=o.projectId||"",this.revisionId=o.revisionId||"",this.author=o.author||"",this.createdAt=o.createdAt||"",this.creatingApplication=o.creatingApplication||"",this.schema=o.schema||"",this.propertySets={},this.objects={},this.objectsByType={},this.relationships=[],this.typeCounts={},this.rootObjects={},this.built=!1,a(this,c)[c]=!1,this.fromJSON(o)}fromJSON(t){if(this.destroyed)return new s("Failed to add components to DataModel - DataModel already destroyed");if(this.built)throw new s("Failed to add components to DataModel - DataModel already built");if(t.propertySets)for(let e=0,s=t.propertySets.length;e<s;e++)this.createPropertySet(t.propertySets[e]);if(t.objects)for(let e=0,s=t.objects.length;e<s;e++)this.createObject(t.objects[e]);if(t.relationships)for(let e=0,s=t.relationships.length;e<s;e++)this.createRelationship(t.relationships[e])}createPropertySet(t){if(this.destroyed)return new s("Failed to create PropertySet - DataModel already destroyed");if(this.built)return new s("DataModel already built");if(this.propertySets[t.id])return new s("Failed to create PropertySet - PropertySet with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");let e=this.data.propertySets[t.id];return e?(this.propertySets[t.id]=e,e.models.push(this),e):(e=new n(this,t),this.propertySets[t.id]=e,this.data.propertySets[t.id]=e,e)}createObject(t){if(this.destroyed)return new s("Failed to create DataObject - DataModel already destroyed");if(this.built)return new s("Failed to create DataObject - DataModel already built");const e=t.id;if(this.objects[e])return new s("Failed to create DataObject - DataObject with same ID already created in this DataModel. It's OK to have duplicates shared between DataModels, but they must be unique within each DataModel.");const i=t.type;let o=this.data.objects[e];if(o)this.objects[e]=o,this.data.objects[e]=o,this.objectsByType[i]||(this.objectsByType[i]={}),this.objectsByType[i][e]=o,this.typeCounts[i]=void 0===this.typeCounts[i]?1:this.typeCounts[i]+1,o.models.push(this);else{const r=[];if(t.propertySetIds)for(let e=0,i=t.propertySetIds.length;e<i;e++){const i=t.propertySetIds[e],o=this.propertySets[i];if(!o)return new s(`Failed to create DataObject - PropertySet not found: "${i}"`);r.push(o)}o=new l(this.data,this,e,t.name,t.type,r),this.objects[e]=o,this.data.objects[e]=o,this.data.objectsByType[i]||(this.data.objectsByType[i]={}),this.data.objectsByType[i][e]=o,this.data.typeCounts[i]=void 0===this.data.typeCounts[i]?1:this.data.typeCounts[i]+1,o.models.push(this),this.data.onObjectCreated.dispatch(this.data,o)}return o}createRelationship(t){if(this.destroyed)return new s("Failed to create Relationship - DataModel already destroyed");if(this.built)return new s("Failed to create Relationship - DataModel already built");const e=this.data.objects[t.relatingObjectId];if(!e)return new s(`Failed to create Relationship - relating DataObject not found: ${t.relatingObjectId}`);const i=this.data.objects[t.relatedObjectId];if(!i)return new s(`Failed to create Relationship - related DataObject not found: ${t.relatedObjectId}`);const o=new h(t.type,e,i);return i.relating[t.type]||(i.relating[t.type]=[]),i.relating[t.type].push(o),e.related[t.type]||(e.related[t.type]=[]),e.related[t.type].push(o),this.relationships.push(o),o}build(){return this.destroyed?new s("Failed to build DataModel - DataModel already destroyed"):this.built?new s("Failed to build DataModel - DataModel already built"):(this.built=!0,void this.onBuilt.dispatch(this,null))}getJSON(){if(this.destroyed)return new s("DataModel already destroyed");if(this.built)return new s("DataModel already built");const t={id:this.id,propertySets:[],objects:[],relationships:[]};for(let s in this.propertySets){var e;const i=this.propertySets[s],o={id:s,name:i.name,properties:[],type:i.type,originalSystemId:i.originalSystemId};for(let t=0,e=i.properties.length;t<e;t++){const e=i.properties[t];o.properties.push({name:e.name,value:e.value,type:e.type,valueType:e.valueType,description:e.description})}null==(e=t.propertySets)||e.push(o)}for(let e in this.objects){var i;const s=this.objects[e],r={id:e,type:s.type,name:s.name,propertySetIds:[]};if(s.propertySets)for(let t=0,e=s.propertySets.length;t<e;t++){var o;null==(o=r.propertySetIds)||o.push(s.propertySets[t].id)}null==(i=t.objects)||i.push(r)}for(let e=0,s=this.relationships.length;e<s;e++){var r;const s=this.relationships[e];null==(r=t.relationships)||r.push({type:s.type,relatingObjectId:s.relatingObject.id,relatedObjectId:s.relatedObject.id})}return t}destroy(){if(this.destroyed)return new s("Failed to destroy DataModel - DataModel already destroyed");for(let t in this.objects){const e=this.objects[t];if(e.models.length>1)a(this,p)[p](e);else{delete this.data.objects[t];const s=e.type;if(0==--this.data.typeCounts[s]){delete this.data.typeCounts[s],delete this.data.objectsByType[s],this.data.onObjectDestroyed.dispatch(this.data,e);for(let t in e.relating){const s=e.relating[t];for(let i=0,o=s.length;i<o;i++){const o=s[i].relatedObject.relating[t];for(let t=0,s=0,i=o.length;t<i;t++)o[s].relatingObject===e&&(o[t]=o[t])}}}}}a(this,c)[c]=!0,this.onBuilt.clear(),super.destroy()}}function u(t){for(let e=0,s=t.models.length;e<s;e++)if(t.models[e]===this){t.models=t.models.splice(e,1);break}}class b extends t{constructor(){super(null,{}),this.models=void 0,this.propertySets=void 0,this.objects=void 0,this.rootObjects=void 0,this.objectsByType=void 0,this.typeCounts=void 0,this.onModelCreated=void 0,this.onModelDestroyed=void 0,this.onObjectCreated=void 0,this.onObjectDestroyed=void 0,this.models={},this.propertySets={},this.objects={},this.rootObjects={},this.objectsByType={},this.typeCounts={},this.onModelCreated=new e(new i),this.onModelDestroyed=new e(new i),this.onObjectCreated=new e(new i),this.onObjectDestroyed=new e(new i)}createModel(t,e){if(this.destroyed)return new s("Data already destroyed");let i=t.id;if(this.models[i])return new s(`DataModel already created in this Data: ${i}`);const o=new y(this,i,t,e);return this.models[o.id]=o,o.onDestroyed.one(()=>{delete this.models[o.id],this.onModelDestroyed.dispatch(this,o)}),o.onBuilt.one(()=>{this.onModelCreated.dispatch(this,o)}),o}getObjectIdsByType(t){if(this.destroyed)return new s("Data already destroyed");const e=this.objectsByType[t];return e?Object.keys(e):[]}searchObjects(t){if(this.destroyed)return new s("Data already destroyed");const e=t.includeObjects&&t.includeObjects.length>0?j(t.includeObjects):null,i=t.excludeObjects&&t.excludeObjects.length>0?j(t.excludeObjects):null,o=t.includeRelating&&t.includeRelating.length>0?j(t.includeRelating):null,r=t.excludeRelating&&t.excludeRelating.length>0?j(t.excludeRelating):null;function a(s,d){if(!s)return;let n=!0;(i&&i[s.type]||e&&!e[s.type])&&(n=!1),0===d&&!1===t.includeStart&&(n=!1),n&&(t.resultObjectIds?t.resultObjectIds.push(s.id):t.resultObjects?t.resultObjects.push(s):t.resultCallback&&t.resultCallback(s));const l=s.related;for(let t in l){const e=l[t];if(e)for(let t=0,i=e.length;t<i;t++){let i=!0;(r&&r[s.type]||o&&!o[s.type])&&(i=!1),i&&a(e[t].relatedObject,d+1)}}}if(t.startObjectId){const e=this.objects[t.startObjectId];if(!e)return new s(`Failed to search DataObjects - starting DataObject not found in Data: "${t.startObjectId}"`);a(e,0)}else if(t.startObject){if(t.startObject.data!=this)return new s(`Failed to search DataObjects - starting DataObject not in same Data: "${t.startObjectId}"`);a(t.startObject,1)}else for(let t in this.rootObjects)a(this.rootObjects[t],1)}clear(){if(this.destroyed)return new s("Data already destroyed");for(let t in this.models)this.models[t].destroy()}destroy(){if(this.destroyed)return new s("Data already destroyed");this.clear(),this.onModelCreated.clear(),this.onModelDestroyed.clear(),super.destroy()}}function j(t){const e={};for(let s=0,i=t.length;s<i;s++)e[t[s]]=!0;return e}export{b as Data,y as DataModel,l as DataObject,d as Property,n as PropertySet,h as Relationship};
//# sourceMappingURL=index.modern.mjs.map
