{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcompression.svg)](https://badge.fury.io/js/%40xeokit%2Fcompression)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/compression/badge)](https://www.jsdelivr.com/package/npm/@xeokit/compression)\n * \n * <img style=\"padding:20px\" src=\"media://images/geometry_icon.png\"/>\n *\n * # xeokit Geometry Compression / Decompression Utilities\n *\n * ---\n *\n * ### *Tools for geometry compression and decompression*\n *\n * ---\n *\n * The xeokit Geometry Compression/Decompression Utilities library provides functions used internally within SceneModel.createGeometry implementations to compress geometry. These functions are also provided for users who want to pre-compress their geometry \"offline\" and then use SceneModel.createGeometryCompressed to create compressed geometry directly.\n\n The compression techniques used include simplifying geometry by combining duplicate positions and adjusting indices, generating edge indices for triangle meshes, ignoring normals (as shaders auto-generate them), converting positions to relative-to-center (RTC) coordinates, quantizing positions and UVs as 16-bit unsigned integers, and splitting geometry into buckets to enable indices to use the minimum bits for storage. The bucketing technique was developed for xeokit by Toni Marti with support from Tribia AG.\n\n To use the library, install it using npm install @xeokit/compression. An example usage includes compressing a GeometryParams into a GeometryCompressedParams using the compressGeometryParams function. In this example, the geometry is simple, and only one bucket is needed. However, if the positions array was large enough to require some indices to use more than 16 bits for storage, the bucketing mechanism would split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.\n\n The resulting GeometryCompressedParams object shows that we have one bucket with vertex positions relative to the origin and quantized to 16-bit integers, duplicate positions removed, and adjusted indices. Additionally, edge indices are generated for the TrianglesPrimitive, and a positionsDecompressMatrix is included to de-quantize the positions within the Viewer.\n\n * This library provides a set of functions that are used internally within\n * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry} implementations to\n * compress geometry. The functions are provided here in case users instead want to pre-compress their geometry \"offline\",\n * and then use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}\n * to create the compressed geometry directly.\n *\n * ### Compression Techniques Used\n *\n * * Simplifies geometry by combining duplicate positions and adjusting indices\n * * Generates edge indices for triangle meshes\n * * Ignores normals (our shaders auto-generate them)\n * * Converts positions to relative-to-center (RTC) coordinates\n * * Quantizes positions and UVs as 16-bit unsigned integers\n * * Splits geometry into {@link @xeokit/scene!GeometryBucketParams | buckets } to enable indices to use the minimum bits for storage\n *\n * ### Aknowledgements\n *\n * * The bucketing technique mentioned above was developed for xeokit by Toni Marti, with support from Tribia AG. Read [the slides](media://pdfs/GPU_RAM_Savings_Toni_Marti_Apr22.pdf) from Toni's presentation at WebGL Meetup 2022.\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/compression\n * ````\n *\n * ## Usage\n *\n * In the example below, we'll use {@link compressGeometryParams} to compress\n * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a\n * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.\n *\n * In this example, our geometry is very simple, and our GeometryCompressedParams only gets a single\n * {@link @xeokit/scene!GeometryBucketParams | GeometryBucketParams }. Note that if the\n * {@link @xeokit/scene!GeometryParams.positions | GeometryParams.positions} array was large enough to require\n * some of the indices to use more than 16 bits for storage, then that's when the function's bucketing mechanism would\n * kick in, to split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.\n *\n * ````javascript\n * import {compressGeometryParams} from \"@xeokit/compression\";\n * import {TrianglesPrimitive} from \"@xeokit/core/constants\";\n *\n * const geometryCompressedParams = compressGeometryParams({\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      positions: [\n *          202, 202, 202, 200, 202, 202,\n *          200, 200, 202, 202, 200, 202,\n *          202, 202, 202, 202, 200, 202,\n *          202, 200, 200, 202, 202, 200,\n *          202, 202, 202, 202, 202, 200,\n *          200, 202, 200, 200, 202, 202,\n *          200, 202, 202, 200, 202, 200,\n *          200, 200, 200, 200, 200, 202,\n *          200, 200, 200, 202, 200, 200,\n *          202, 200, 202, 200, 200, 202,\n *          202, 200, 200, 200, 200, 200,\n *          200, 202, 200, 202, 202, 200\n *      ],\n *      indices: [\n *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4,\n *          6, 7, 8, 9, 10, 8, 10, 11, 12,\n *          13, 14, 12, 14, 15, 16, 17, 18,\n *          16, 18, 19, 20, 21, 22, 20, 22, 23\n *      ]\n *  });\n * ````\n *\n * The value of our new {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams} is shown below.\n *\n * We can see that:\n *\n * * We get one bucket, because we have only a small number of indices\n * * Vertex positions are now relative to ````origin```` and quantized to 16-bit integers\n * * Duplicate positions are removed and indices adjusted\n * * Edge indices generated for our TrianglesPrimitive\n * * A ````positionsDecompressMatrix```` to de-quantize the positions within the Viewer\n *\n * ````javascript\n * {\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      origin: [200,200,200],\n *      positionsDecompressMatrix: [\n *          0.00003052270125906143, 0, 0, 0,\n *          0, 0.00003052270125906143, 0, 0,\n *          0, 0, 0.00003052270125906143, 0,\n *          -1, -1, -1, 1\n *      ],\n *      geometryBuckets: [\n *          {\n *              positionsCompressed: [\n *                  65525, 65525, 65525, 0, 65525, 65525,\n *                  0, 0, 65525, 65525, 0, 65525, 65525,\n *                  0, 0, 65525, 65525, 0, 0, 65525, 0, 0,\n *                  0, 0\n *              ],\n *              indices: [\n *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,\n *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,\n *                  4, 7, 6, 4, 6, 5\n *              ],\n *              edgeIndices: [\n *                  3, 4, 0, 4, 5, 0, 5, 6,\n *                  0, 6, 1, 1, 6, 7, 1, 7,\n *                  3, 2, 4, 7, 6, 4, 6\n *              ]\n *          }\n *      ]\n * }\n * ````\n *\n * In the next example, we'll again use {@link compressGeometryParams} to compress\n * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a\n * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}, which we'll then use to\n * create a compressed geometry within a {@link @xeokit/scene!SceneModel | SceneModel}.\n *\n * ````javascript\n * import {Scene} from \"@xeokit/scene\";\n * import {TrianglesPrimitive} from \"@xeokit/core/constants\";\n * import {compressGeometryParams} from \"@xeokit/compression\";\n *\n * const scene = new Scene();\n *\n * const sceneModel = scene.createModel({\n *     id: \"myModel\"\n * });\n *\n * const geometryCompressedParams = compressGeometryParams({\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      positions: [202, 202, 202, 200, 202, 202, ...],\n *      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, ...]\n * });\n *\n * sceneModel.createGeometryCompressed(geometryCompressedParams);\n *\n * sceneModel.createMesh({ id: \"myMesh\", geometryId: \"myGeometry\" });\n *\n * sceneModel.createObject({ id: \"myObject1\", meshIds: [\"myMesh\"] });\n * sceneModel.createObject({ id: \"myObject2\", meshIds: [\"myMesh\"] });\n *\n * sceneModel.build();\n * ````\n *\n * @module @xeokit/compression\n */\n\nimport {\n    createMat3, createMat4,\n    createVec3,\n    identityMat3,\n    identityMat4,\n    mulMat3,\n    mulMat4,\n    normalizeVec3,\n    scalingMat3v,\n    scalingMat4v,\n    transformVec3,\n    translationMat3v,\n    translationMat4v\n} from \"@xeokit/matrix\";\n\nimport type {FloatArrayParam} from \"@xeokit/math\";\n\nconst translate = createMat4();\nconst scale = createMat4();\n\n/**\n * Gets the boundary of a flat positions array.\n *\n * @param array\n * @param min\n * @param max\n */\nexport function getPositions3MinMax(array: FloatArrayParam, min?: FloatArrayParam, max?: FloatArrayParam) {\n    let i, j;\n    min = min || new Float64Array(3);\n    max = max || new Float64Array(3);\n    for (i = 0; i < 3; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 3) {\n        for (j = 0; j < 3; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min,\n        max\n    };\n}\n\n/**\n * Creates a de-quantization matrix from a boundary.\n */\nexport function createPositions3DecompressMat4(aabb: FloatArrayParam, positionsDecompressMatrix: FloatArrayParam): FloatArrayParam {\n    positionsDecompressMatrix = positionsDecompressMatrix || createMat4();\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    identityMat4(translate);\n    translationMat4v(aabb, translate);\n    identityMat4(scale);\n    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n    mulMat4(translate, scale, positionsDecompressMatrix);\n    return positionsDecompressMatrix;\n}\n\n/**\n * Compresses a flat positions array\n */\nexport function compressPositions3(array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam) {\n    const quantized = new Uint16Array(array.length);\n    var multiplier = new Float32Array([\n        max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,\n        max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,\n        max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0\n    ]);\n    let i;\n    for (i = 0; i < array.length; i += 3) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n    }\n    identityMat4(translate);\n    translationMat4v(min, translate);\n    identityMat4(scale);\n    scalingMat4v([\n        (max[0] - min[0]) / 65535,\n        (max[1] - min[1]) / 65535,\n        (max[2] - min[2]) / 65535\n    ], scale);\n    const decompressMatrix = mulMat4(translate, scale, identityMat4());\n    return {\n        quantized: quantized,\n        decompressMatrix: decompressMatrix\n    };\n}\n\n/**\n * Compresses a 3D position\n * @param p\n * @param aabb\n * @param q\n */\nexport function compressPoint3(p: FloatArrayParam, aabb: FloatArrayParam, dest: FloatArrayParam = p) {\n    const multiplier = new Float32Array([\n        aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0,\n        aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0,\n        aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0\n    ]);\n    dest[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));\n    dest[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));\n    dest[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));\n    return dest;\n}\n\n/**\n * Decompresses a 3D position\n * @param position\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressPoint3(position: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: FloatArrayParam = position): FloatArrayParam {\n    dest[0] = position[0] * decompressMatrix[0] + decompressMatrix[12];\n    dest[1] = position[1] * decompressMatrix[5] + decompressMatrix[13];\n    dest[2] = position[2] * decompressMatrix[10] + decompressMatrix[14];\n    return dest;\n}\n\n/**\n * Decompresses an axis-aligned 3D boundary\n * @param aabb\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressAABB3(aabb: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: FloatArrayParam = aabb): FloatArrayParam {\n    dest[0] = aabb[0] * decompressMatrix[0] + decompressMatrix[12];\n    dest[1] = aabb[1] * decompressMatrix[5] + decompressMatrix[13];\n    dest[2] = aabb[2] * decompressMatrix[10] + decompressMatrix[14];\n    dest[3] = aabb[3] * decompressMatrix[0] + decompressMatrix[12];\n    dest[4] = aabb[4] * decompressMatrix[5] + decompressMatrix[13];\n    dest[5] = aabb[5] * decompressMatrix[10] + decompressMatrix[14];\n    return dest;\n}\n\n/**\n * Decompresses a flat array of positions\n * @param positions\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressPositions3(positions: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: Float32Array = new Float32Array(positions.length)): Float32Array {\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        dest[i + 0] = positions[i + 0] * decompressMatrix[0] + decompressMatrix[12];\n        dest[i + 1] = positions[i + 1] * decompressMatrix[5] + decompressMatrix[13];\n        dest[i + 2] = positions[i + 2] * decompressMatrix[10] + decompressMatrix[14];\n    }\n    return dest;\n}\n\n/**\n * Gets the 2D min/max boundary of a flat array of UV coordinate\n * @param array\n */\nexport function getUVBounds(array: FloatArrayParam): { min: FloatArrayParam, max: FloatArrayParam } {\n    const min = new Float32Array(2);\n    const max = new Float32Array(2);\n    let i, j;\n    for (i = 0; i < 2; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 2) {\n        for (j = 0; j < 2; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n\n/**\n * Compresses a flat array of UV coordinates\n */\nexport var compressUVs = (function () {\n    const translate = createMat3();\n    const scale = createMat3();\n    return function (array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam): {\n        quantized: Uint16Array,\n        decompressMatrix: FloatArrayParam | Float64Array\n    } {\n        const quantized = new Uint16Array(array.length);\n        const multiplier = new Float32Array([\n            65535 / (max[0] - min[0]),\n            65535 / (max[1] - min[1])\n        ]);\n        let i;\n        for (i = 0; i < array.length; i += 2) {\n            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        }\n        identityMat3(translate);\n        translationMat3v(min, translate);\n        identityMat3(scale);\n        scalingMat3v([\n            (max[0] - min[0]) / 65535,\n            (max[1] - min[1]) / 65535\n        ], scale);\n        const decompressMatrix = mulMat3(translate, scale, identityMat3());\n        return {\n            quantized: quantized,\n            decompressMatrix: decompressMatrix\n        };\n    };\n})();\n\n/**\n * Oct-encodes a flat array of normal vectors\n * @param array\n */\nexport function compressNormals(array: FloatArrayParam): Int8Array { // http://jcgt.org/published/0003/02/01/\n\n    // Note: three elements for each encoded normal, in which the last element in each triplet is redundant.\n    // This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/\n\n    const encoded = new Int8Array(array.length);\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < array.length; i += 3) {\n        // Test various combinations of ceil and floor\n        // to minimize rounding errors\n        best = oct = octEncodeNormalFromArray(array, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(array, i, dec);\n        oct = octEncodeNormalFromArray(array, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormalFromArray(array, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormalFromArray(array, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        encoded[i] = best[0];\n        encoded[i + 1] = best[1];\n    }\n    return encoded;\n}\n\n/**\n */\nfunction octEncodeNormalFromArray(array: FloatArrayParam, i: number, xfunc: any, yfunc: any): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n */\nfunction dot(array: FloatArrayParam, i: number, createVec3: FloatArrayParam): number {\n    return array[i] * createVec3[0] + array[i + 1] * createVec3[1] + array[i + 2] * createVec3[2];\n}\n\n/**\n */\nexport function decompressUV(uv: FloatArrayParam, decompressMatrix: FloatArrayParam, dest = new Float32Array(2)) {\n    dest[0] = uv[0] * decompressMatrix[0] + decompressMatrix[6];\n    dest[1] = uv[1] * decompressMatrix[4] + decompressMatrix[7];\n}\n\n/**\n *\n */\nexport function decompressUVs(uvs: FloatArrayParam, decompressMatrix: FloatArrayParam, dest = new Float32Array(uvs.length)) {\n    for (let i = 0, len = uvs.length; i < len; i += 3) {\n        dest[i + 0] = uvs[i + 0] * decompressMatrix[0] + decompressMatrix[6];\n        dest[i + 1] = uvs[i + 1] * decompressMatrix[4] + decompressMatrix[7];\n    }\n    return dest;\n}\n\n/**\n *\n */\nexport function decompressNormal(oct: FloatArrayParam, result: FloatArrayParam): FloatArrayParam {\n    let x = oct[0];\n    let y = oct[1];\n    x = (2 * x + 1) / 255;\n    y = (2 * y + 1) / 255;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    result[0] = x / length;\n    result[1] = y / length;\n    result[2] = z / length;\n    return result;\n}\n\n/**\n *\n */\nexport function decompressNormals(octs: string | any[], result: FloatArrayParam): FloatArrayParam {\n    for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n        let x = octs[i + 0];\n        let y = octs[i + 1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[j + 0] = x / length;\n        result[j + 1] = y / length;\n        result[j + 2] = z / length;\n        j += 3;\n    }\n    return result;\n}\n\n/**\n *\n * @param oct\n * @param result\n */\nfunction octDecodeVec2(oct: Int8Array, result: FloatArrayParam = createVec3()): FloatArrayParam {\n    let x = oct[0];\n    let y = oct[1];\n    x = (2 * x + 1) / 255;\n    y = (2 * y + 1) / 255;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    result[0] = x / length;\n    result[1] = y / length;\n    result[2] = z / length;\n    return result;\n}\n\n/**\n *\n */\nfunction octDecodeVec2s(octs: Int8Array, result: FloatArrayParam): FloatArrayParam {\n    for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n        let x = octs[i + 0];\n        let y = octs[i + 1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[j + 0] = x / length;\n        result[j + 1] = y / length;\n        result[j + 2] = z / length;\n        j += 3;\n    }\n    return result;\n}\n\n/**\n * @private\n */\nexport function quantizePositions3(positions: FloatArrayParam, aabb: FloatArrayParam, positionsDecompressMatrix: FloatArrayParam) { // http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf\n    const lenPositions = positions.length;\n    const positionsCompressed = new Uint16Array(lenPositions);\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65525;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    const verify = (num: number) => num >= 0 ? num : 0;\n    for (let i = 0; i < lenPositions; i += 3) {\n        positionsCompressed[i + 0] = Math.floor(verify(positions[i + 0] - xmin) * xMultiplier);\n        positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);\n        positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);\n    }\n    identityMat4(translate);\n    translationMat4v(aabb, translate);\n    identityMat4(scale);\n    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n    mulMat4(translate, scale, positionsDecompressMatrix);\n    return positionsCompressed;\n}\n\n/**\n * @private\n */\nexport function transformAndOctEncodeNormals(worldNormalMatrix: FloatArrayParam, normals: FloatArrayParam, lenNormals: number, compressedNormals: FloatArrayParam, lenCompressedNormals: number) {\n\n    function dot(p: FloatArrayParam, createVec3: FloatArrayParam) { // Dot product of a normal in an array against a candidate decoding\n        return p[0] * createVec3[0] + p[1] * createVec3[1] + p[2] * createVec3[2];\n    }\n\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = new Float32Array([0, 0, 0, 0]);\n    let worldNormal = new Float32Array([0, 0, 0, 0]);\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        transformVec3(worldNormalMatrix, localNormal, worldNormal);\n        normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, dec);\n        oct = octEncodeVec3(worldNormal, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nexport function octEncodeNormals(normals: FloatArrayParam) { // http://jcgt.org/published/0003/02/01/\n    const lenNormals = normals.length;\n    const compressedNormals = new Int8Array(lenNormals)\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeNormal(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeNormal(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormal(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormal(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[i + 0] = best[0];\n        compressedNormals[i + 1] = best[1];\n        compressedNormals[i + 2] = 0.0; // Unused\n    }\n    return compressedNormals;\n}\n\n/**\n * @private\n */\nexport function octEncodeVec3(p: FloatArrayParam, xfunc: string, yfunc: string): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = p[0] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));\n    let y = p[1] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));\n    if (p[2] < 0) {\n        let tempx = x;\n        let tempy = y;\n        tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n/**\n * @private\n */\nexport function octEncodeNormal(array: FloatArrayParam, i: number, xfunc: string, yfunc: string): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n\n"],"names":["translate","createMat4","scale","compressUVs","createMat3","array","min","max","i","quantized","Uint16Array","length","multiplier","Float32Array","Math","floor","identityMat3","translationMat3v","scalingMat3v","decompressMatrix","mulMat3","octEncodeNormalFromArray","xfunc","yfunc","x","abs","y","tempx","tempy","Int8Array","dot","createVec3","octDecodeVec2","oct","result","z","sqrt","octEncodeVec3","p","octEncodeNormal","best","currentCos","bestCos","encoded","aabb","dest","identityMat4","translationMat4v","scalingMat4v","mulMat4","positionsDecompressMatrix","xwid","ywid","zwid","maxInt","octs","j","len","position","positions","uv","uvs","Float64Array","Number","MAX_VALUE","normals","lenNormals","compressedNormals","lenPositions","positionsCompressed","xmin","ymin","zmin","xMultiplier","yMultiplier","zMultiplier","verify","num","worldNormalMatrix","lenCompressedNormals","localNormal","worldNormal","transformVec3","normalizeVec3"],"mappings":"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"}