{"version":3,"file":"index.modern.mjs","sources":["../src/loadWebIFC.ts"],"sourcesContent":["import {createMat4, createVec3, transformPositions3} from \"@xeokit/matrix\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport * as WebIFC from \"web-ifc/web-ifc-api-node\";\nimport {IfcRelAggregates} from \"@xeokit/ifctypes\";\nimport {worldToRTCPositions} from \"@xeokit/rtc\";\nimport {TrianglesPrimitive} from \"@xeokit/constants\";\n\n/**\n * @private\n */\ninterface ParsingContext {\n    data: ArrayBuffer;\n    ifcAPI: WebIFC.IfcAPI;\n    sceneModel: SceneModel;\n    dataModel?: DataModel;\n    nextId: number;\n    modelId: number;\n    lines: WebIFC.Vector<number>;\n    ifcProjectId: number;\n}\n\n/**\n * Loads IFC into a {@link @xeokit/scene!SceneModel | SceneModel} and/or {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````\n * * Does not call {@link @xeokit/scene!SceneModel.build | SceneModel.build} - we call that ourselves, when we have finished building the SceneModel\n *\n * See {@link @xeokit/webifc} for usage.\n *\n * @param params - Loading parameters.\n * @param params.data - IFC file contents.\n * @param params.ifcAPI - WebIFC API.\n * @param params.sceneModel - SceneModel to load into.\n * @param params.dataModel - DataModel to load into.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been built.\n * @returns {Promise} Resolves when IFC has been loaded into the SceneModel and/or DataModel.\n */\nexport function loadWebIFC(params: {\n    data: ArrayBuffer,\n    ifcAPI: WebIFC.IfcAPI,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): Promise<any> {\n    if (!params.ifcAPI) {\n        throw new Error(\"Argument missing: ifcAPI\");\n    }\n    if (params.sceneModel.destroyed) {\n        throw new Error(\"SceneModel already destroyed\");\n    }\n    if (params.sceneModel.built) {\n        throw new Error(\"SceneModel already built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new Error(\"DataModel already destroyed\");\n        }\n        if (params.dataModel.built) {\n            throw new Error(\"DataModel already built\");\n        }\n    }\n    return new Promise<void>(function (resolve, reject) {\n        const dataArray = new Uint8Array(params.data);\n        const modelId = params.ifcAPI.OpenModel(dataArray);\n        const lines = params.ifcAPI.GetLineIDsWithType(modelId, WebIFC.IFCPROJECT);\n        const ifcProjectId = lines.get(0);\n        const ctx: ParsingContext = {\n            data: params.data,\n            modelId,\n            lines,\n            ifcProjectId,\n            ifcAPI: params.ifcAPI,\n            sceneModel: params.sceneModel,\n            dataModel: params.dataModel,\n            nextId: 0\n        };\n        parseIFC(ctx);\n        resolve();\n    });\n}\n\nfunction parseIFC(ctx: ParsingContext) {\n    if (ctx.dataModel) {\n        parseDataModel(ctx);\n    }\n    if (ctx.sceneModel) {\n        parseSceneModel(ctx);\n    }\n}\n\nfunction parseDataModel(ctx: ParsingContext) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, WebIFC.IFCPROJECT);\n    const ifcProjectId = lines.get(0);\n    const ifcProject = ctx.ifcAPI.GetLine(ctx.modelId, ifcProjectId);\n    parsePropertySets(ctx);\n    parseDataObjectAggregation(ctx, ifcProject);\n}\n\nfunction parsePropertySets(ctx: any) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, WebIFC.IFCRELDEFINESBYPROPERTIES);\n    for (let i = 0; i < lines.size(); i++) {\n        let relID = lines.get(i);\n        let rel = ctx.ifcAPI.GetLine(ctx.modelId, relID, true);\n        if (rel) {\n            const relatingPropertyDefinition = rel.RelatingPropertyDefinition;\n            if (!relatingPropertyDefinition) {\n                continue;\n            }\n            const propertySetId = relatingPropertyDefinition.GlobalId.value;\n            const props = relatingPropertyDefinition.HasProperties;\n            if (props && props.length > 0) {\n                const propertySetType = \"Default\";\n                const propertySetName = relatingPropertyDefinition.Name.value;\n                const properties = [];\n                for (let i = 0, len = props.length; i < len; i++) {\n                    const prop = props[i];\n                    const name = prop.Name;\n                    const nominalValue = prop.NominalValue;\n                    if (name && nominalValue) {\n                        properties.push({\n                            name: name.value,\n                            type: nominalValue.type,\n                            value: nominalValue.value,\n                            valueType: nominalValue.valueType,\n                            description: prop.Description ? prop.Description.value : (nominalValue.description ? nominalValue.description : \"\")\n                        });\n                    }\n                }\n                ctx.dataModel.createPropertySet({\n                    id: propertySetId,\n                    type: propertySetType,\n                    name: propertySetName,\n                    properties: properties\n                });\n                const relatedObjects = rel.RelatedObjects;\n                if (!relatedObjects || relatedObjects.length === 0) {\n                    return;\n                }\n                for (let i = 0, len = relatedObjects.length; i < len; i++) {\n                    const relatedObject = relatedObjects[i];\n                    const dataObjectId = relatedObject.GlobalId.value;\n                    const dataObject = ctx.dataObjects[dataObjectId];\n                    if (dataObject) {\n                        if (!dataObject.propertySetIds) {\n                            dataObject.propertySetIds = [];\n                        }\n                        dataObject.propertySetIds.push(propertySetId);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction parseDataObjectAggregation(ctx: ParsingContext, ifcElement: any, parentDataObjectId?: string) {\n    const type = ifcElement.__proto__.constructor.name;\n    createDataObject(ctx, ifcElement, parentDataObjectId);\n    const dataObjectId = ifcElement.GlobalId.value;\n    parseRelatedItemsOfType(ctx, ifcElement.expressID, 'RelatingObject', 'RelatedObjects', WebIFC.IFCRELAGGREGATES, dataObjectId);\n    parseRelatedItemsOfType(ctx, ifcElement.expressID, 'RelatingStructure', 'RelatedElements', WebIFC.IFCRELCONTAINEDINSPATIALSTRUCTURE, dataObjectId);\n}\n\nfunction createDataObject(ctx: ParsingContext, ifcElement: any, parentDataObjectId?: string) {\n    const id = ifcElement.GlobalId.value;\n    const type = ifcElement.__proto__.constructor.name;\n    const name = (ifcElement.Name && ifcElement.Name.value !== \"\") ? ifcElement.Name.value : type;\n    // @ts-ignore\n    ctx.dataModel.createObject({\n        id,\n        name,\n        type\n    });\n    if (parentDataObjectId) {\n        // @ts-ignore\n        ctx.dataModel.createRelationship({\n            type: IfcRelAggregates,\n            relatingObjectId: parentDataObjectId,\n            relatedObjectId: id\n        });\n    }\n}\n\nfunction parseRelatedItemsOfType(ctx: ParsingContext, id: any, relation: string, related: string, type: number, parentDataObjectId: string) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, type);\n    for (let i = 0; i < lines.size(); i++) {\n        const relID = lines.get(i);\n        const rel = ctx.ifcAPI.GetLine(ctx.modelId, relID);\n        const relatedItems = rel[relation];\n        let foundElement = false;\n        if (Array.isArray(relatedItems)) {\n            const values = relatedItems.map((item) => item.value);\n            foundElement = values.includes(id);\n        } else {\n            foundElement = (relatedItems.value === id);\n        }\n        if (foundElement) {\n            const element = rel[related];\n            if (!Array.isArray(element)) {\n                const ifcElement = ctx.ifcAPI.GetLine(ctx.modelId, element.value);\n                parseDataObjectAggregation(ctx, ifcElement, parentDataObjectId);\n            } else {\n                element.forEach((element2) => {\n                    const ifcElement = ctx.ifcAPI.GetLine(ctx.modelId, element2.value);\n                    parseDataObjectAggregation(ctx, ifcElement, parentDataObjectId);\n                });\n            }\n        }\n    }\n}\n\n\nfunction parseSceneModel(ctx: ParsingContext) {\n    ctx.ifcAPI.StreamAllMeshes(ctx.modelId, (flatMesh) => {\n        // TODO: Can we do geometry reuse with web-ifc?\n        const flatMeshExpressID = flatMesh.expressID;\n        const placedGeometries = flatMesh.geometries;\n        const meshIds = [];\n        const properties = ctx.ifcAPI.GetLine(ctx.modelId, flatMeshExpressID);\n        const objectId = properties.GlobalId.value;\n        const matrix = createMat4();\n        const origin = createVec3();\n        for (let j = 0, lenj = placedGeometries.size(); j < lenj; j++) {\n            const placedGeometry = placedGeometries.get(j);\n            const geometry = ctx.ifcAPI.GetGeometry(ctx.modelId, placedGeometry.geometryExpressID);\n            const vertexData = ctx.ifcAPI.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());\n            const indices = ctx.ifcAPI.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());\n            // De-interleave vertex arrays\n            const positions = new Float64Array(vertexData.length / 2);\n            const normals = new Float32Array(vertexData.length / 2);\n            for (let k = 0, l = 0, lenk = vertexData.length / 6; k < lenk; k++, l += 3) {\n                positions[l + 0] = vertexData[k * 6 + 0];\n                positions[l + 1] = vertexData[k * 6 + 1];\n                positions[l + 2] = vertexData[k * 6 + 2];\n            }\n            (<Float64Array>matrix).set(placedGeometry.flatTransformation);\n            transformPositions3(matrix, positions);\n            const rtcNeeded = worldToRTCPositions(positions, positions, origin);\n            const geometryId = \"\" + ctx.nextId++;\n            ctx.sceneModel.createGeometry({\n                id: geometryId,\n                primitive: TrianglesPrimitive,\n                positions,\n                indices\n            });\n            const meshId = \"\" + ctx.nextId++;\n            ctx.sceneModel.createMesh({\n                id: meshId,\n                geometryId,\n                // TODO: matrix with translation if rtcNeeded\n                color: [placedGeometry.color.x, placedGeometry.color.y, placedGeometry.color.z],\n                opacity: placedGeometry.color.w\n            });\n            meshIds.push(meshId);\n        }\n        ctx.sceneModel.createObject({\n            id: objectId,\n            meshIds: meshIds\n        });\n    });\n}"],"names":["loadWebIFC","params","ifcAPI","Error","sceneModel","destroyed","built","dataModel","Promise","resolve","reject","dataArray","Uint8Array","data","modelId","OpenModel","lines","GetLineIDsWithType","WebIFC","IFCPROJECT","ifcProjectId","get","ctx","nextId","ifcProject","GetLine","IFCRELDEFINESBYPROPERTIES","i","size","relID","rel","relatingPropertyDefinition","RelatingPropertyDefinition","propertySetId","GlobalId","value","props","HasProperties","length","propertySetType","propertySetName","Name","properties","len","prop","name","nominalValue","NominalValue","push","type","valueType","description","Description","createPropertySet","id","relatedObjects","RelatedObjects","dataObject","dataObjects","propertySetIds","parsePropertySets","parseDataObjectAggregation","parseDataModel","StreamAllMeshes","flatMesh","placedGeometries","geometries","meshIds","objectId","expressID","matrix","createMat4","origin","createVec3","j","lenj","placedGeometry","geometry","GetGeometry","geometryExpressID","vertexData","GetVertexArray","GetVertexData","GetVertexDataSize","indices","GetIndexArray","GetIndexData","GetIndexDataSize","positions","Float64Array","k","l","lenk","set","flatTransformation","transformPositions3","worldToRTCPositions","geometryId","createGeometry","primitive","TrianglesPrimitive","meshId","createMesh","color","x","y","z","opacity","w","createObject","parseSceneModel","ifcElement","parentDataObjectId","__proto__","constructor","createRelationship","IfcRelAggregates","relatingObjectId","relatedObjectId","createDataObject","dataObjectId","parseRelatedItemsOfType","IFCRELAGGREGATES","IFCRELCONTAINEDINSPATIALSTRUCTURE","relation","related","relatedItems","foundElement","Array","isArray","map","item","includes","element","forEach","element2"],"mappings":"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"}