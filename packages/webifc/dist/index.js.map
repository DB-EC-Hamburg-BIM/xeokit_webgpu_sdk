{"version":3,"file":"index.js","sources":["../src/loadWebIFC.ts"],"sourcesContent":["import {createMat4, createVec3, transformPositions3} from \"@xeokit/matrix\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport * as WebIFC from \"web-ifc/web-ifc-api-node\";\nimport {IfcRelAggregates} from \"@xeokit/ifctypes\";\nimport {worldToRTCPositions} from \"@xeokit/rtc\";\nimport {TrianglesPrimitive} from \"@xeokit/constants\";\n\n/**\n * @private\n */\ninterface ParsingContext {\n    data: ArrayBuffer;\n    ifcAPI: WebIFC.IfcAPI;\n    sceneModel: SceneModel;\n    dataModel?: DataModel;\n    nextId: number;\n    modelId: number;\n    lines: WebIFC.Vector<number>;\n    ifcProjectId: number;\n}\n\n/**\n * Loads IFC into a {@link @xeokit/scene!SceneModel | SceneModel} and/or {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````\n * * Does not call {@link @xeokit/scene!SceneModel.build | SceneModel.build} - we call that ourselves, when we have finished building the SceneModel\n *\n * See {@link @xeokit/webifc} for usage.\n *\n * @param params - Loading parameters.\n * @param params.data - IFC file contents.\n * @param params.ifcAPI - WebIFC API.\n * @param params.sceneModel - SceneModel to load into.\n * @param params.dataModel - DataModel to load into.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been built.\n * @returns {Promise} Resolves when IFC has been loaded into the SceneModel and/or DataModel.\n */\nexport function loadWebIFC(params: {\n    data: ArrayBuffer,\n    ifcAPI: WebIFC.IfcAPI,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): Promise<any> {\n    if (!params.ifcAPI) {\n        throw new Error(\"Argument missing: ifcAPI\");\n    }\n    if (params.sceneModel.destroyed) {\n        throw new Error(\"SceneModel already destroyed\");\n    }\n    if (params.sceneModel.built) {\n        throw new Error(\"SceneModel already built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new Error(\"DataModel already destroyed\");\n        }\n        if (params.dataModel.built) {\n            throw new Error(\"DataModel already built\");\n        }\n    }\n    return new Promise<void>(function (resolve, reject) {\n        const dataArray = new Uint8Array(params.data);\n        const modelId = params.ifcAPI.OpenModel(dataArray);\n        const lines = params.ifcAPI.GetLineIDsWithType(modelId, WebIFC.IFCPROJECT);\n        const ifcProjectId = lines.get(0);\n        const ctx: ParsingContext = {\n            data: params.data,\n            modelId,\n            lines,\n            ifcProjectId,\n            ifcAPI: params.ifcAPI,\n            sceneModel: params.sceneModel,\n            dataModel: params.dataModel,\n            nextId: 0\n        };\n        parseIFC(ctx);\n        resolve();\n    });\n}\n\nfunction parseIFC(ctx: ParsingContext) {\n    if (ctx.dataModel) {\n        parseDataModel(ctx);\n    }\n    if (ctx.sceneModel) {\n        parseSceneModel(ctx);\n    }\n}\n\nfunction parseDataModel(ctx: ParsingContext) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, WebIFC.IFCPROJECT);\n    const ifcProjectId = lines.get(0);\n    const ifcProject = ctx.ifcAPI.GetLine(ctx.modelId, ifcProjectId);\n    parsePropertySets(ctx);\n    parseDataObjectAggregation(ctx, ifcProject);\n}\n\nfunction parsePropertySets(ctx: any) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, WebIFC.IFCRELDEFINESBYPROPERTIES);\n    for (let i = 0; i < lines.size(); i++) {\n        let relID = lines.get(i);\n        let rel = ctx.ifcAPI.GetLine(ctx.modelId, relID, true);\n        if (rel) {\n            const relatingPropertyDefinition = rel.RelatingPropertyDefinition;\n            if (!relatingPropertyDefinition) {\n                continue;\n            }\n            const propertySetId = relatingPropertyDefinition.GlobalId.value;\n            const props = relatingPropertyDefinition.HasProperties;\n            if (props && props.length > 0) {\n                const propertySetType = \"Default\";\n                const propertySetName = relatingPropertyDefinition.Name.value;\n                const properties = [];\n                for (let i = 0, len = props.length; i < len; i++) {\n                    const prop = props[i];\n                    const name = prop.Name;\n                    const nominalValue = prop.NominalValue;\n                    if (name && nominalValue) {\n                        properties.push({\n                            name: name.value,\n                            type: nominalValue.type,\n                            value: nominalValue.value,\n                            valueType: nominalValue.valueType,\n                            description: prop.Description ? prop.Description.value : (nominalValue.description ? nominalValue.description : \"\")\n                        });\n                    }\n                }\n                ctx.dataModel.createPropertySet({\n                    id: propertySetId,\n                    type: propertySetType,\n                    name: propertySetName,\n                    properties: properties\n                });\n                const relatedObjects = rel.RelatedObjects;\n                if (!relatedObjects || relatedObjects.length === 0) {\n                    return;\n                }\n                for (let i = 0, len = relatedObjects.length; i < len; i++) {\n                    const relatedObject = relatedObjects[i];\n                    const dataObjectId = relatedObject.GlobalId.value;\n                    const dataObject = ctx.dataObjects[dataObjectId];\n                    if (dataObject) {\n                        if (!dataObject.propertySetIds) {\n                            dataObject.propertySetIds = [];\n                        }\n                        dataObject.propertySetIds.push(propertySetId);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction parseDataObjectAggregation(ctx: ParsingContext, ifcElement: any, parentDataObjectId?: string) {\n    const type = ifcElement.__proto__.constructor.name;\n    createDataObject(ctx, ifcElement, parentDataObjectId);\n    const dataObjectId = ifcElement.GlobalId.value;\n    parseRelatedItemsOfType(ctx, ifcElement.expressID, 'RelatingObject', 'RelatedObjects', WebIFC.IFCRELAGGREGATES, dataObjectId);\n    parseRelatedItemsOfType(ctx, ifcElement.expressID, 'RelatingStructure', 'RelatedElements', WebIFC.IFCRELCONTAINEDINSPATIALSTRUCTURE, dataObjectId);\n}\n\nfunction createDataObject(ctx: ParsingContext, ifcElement: any, parentDataObjectId?: string) {\n    const id = ifcElement.GlobalId.value;\n    const type = ifcElement.__proto__.constructor.name;\n    const name = (ifcElement.Name && ifcElement.Name.value !== \"\") ? ifcElement.Name.value : type;\n    // @ts-ignore\n    ctx.dataModel.createObject({\n        id,\n        name,\n        type\n    });\n    if (parentDataObjectId) {\n        // @ts-ignore\n        ctx.dataModel.createRelationship({\n            type: IfcRelAggregates,\n            relatingObjectId: parentDataObjectId,\n            relatedObjectId: id\n        });\n    }\n}\n\nfunction parseRelatedItemsOfType(ctx: ParsingContext, id: any, relation: string, related: string, type: number, parentDataObjectId: string) {\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelId, type);\n    for (let i = 0; i < lines.size(); i++) {\n        const relID = lines.get(i);\n        const rel = ctx.ifcAPI.GetLine(ctx.modelId, relID);\n        const relatedItems = rel[relation];\n        let foundElement = false;\n        if (Array.isArray(relatedItems)) {\n            const values = relatedItems.map((item) => item.value);\n            foundElement = values.includes(id);\n        } else {\n            foundElement = (relatedItems.value === id);\n        }\n        if (foundElement) {\n            const element = rel[related];\n            if (!Array.isArray(element)) {\n                const ifcElement = ctx.ifcAPI.GetLine(ctx.modelId, element.value);\n                parseDataObjectAggregation(ctx, ifcElement, parentDataObjectId);\n            } else {\n                element.forEach((element2) => {\n                    const ifcElement = ctx.ifcAPI.GetLine(ctx.modelId, element2.value);\n                    parseDataObjectAggregation(ctx, ifcElement, parentDataObjectId);\n                });\n            }\n        }\n    }\n}\n\n\nfunction parseSceneModel(ctx: ParsingContext) {\n    ctx.ifcAPI.StreamAllMeshes(ctx.modelId, (flatMesh) => {\n        // TODO: Can we do geometry reuse with web-ifc?\n        const flatMeshExpressID = flatMesh.expressID;\n        const placedGeometries = flatMesh.geometries;\n        const meshIds = [];\n        const properties = ctx.ifcAPI.GetLine(ctx.modelId, flatMeshExpressID);\n        const objectId = properties.GlobalId.value;\n        const matrix = createMat4();\n        const origin = createVec3();\n        for (let j = 0, lenj = placedGeometries.size(); j < lenj; j++) {\n            const placedGeometry = placedGeometries.get(j);\n            const geometry = ctx.ifcAPI.GetGeometry(ctx.modelId, placedGeometry.geometryExpressID);\n            const vertexData = ctx.ifcAPI.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());\n            const indices = ctx.ifcAPI.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());\n            // De-interleave vertex arrays\n            const positions = new Float64Array(vertexData.length / 2);\n            const normals = new Float32Array(vertexData.length / 2);\n            for (let k = 0, l = 0, lenk = vertexData.length / 6; k < lenk; k++, l += 3) {\n                positions[l + 0] = vertexData[k * 6 + 0];\n                positions[l + 1] = vertexData[k * 6 + 1];\n                positions[l + 2] = vertexData[k * 6 + 2];\n            }\n            (<Float64Array>matrix).set(placedGeometry.flatTransformation);\n            transformPositions3(matrix, positions);\n            const rtcNeeded = worldToRTCPositions(positions, positions, origin);\n            const geometryId = \"\" + ctx.nextId++;\n            ctx.sceneModel.createGeometry({\n                id: geometryId,\n                primitive: TrianglesPrimitive,\n                positions,\n                indices\n            });\n            const meshId = \"\" + ctx.nextId++;\n            ctx.sceneModel.createMesh({\n                id: meshId,\n                geometryId,\n                // TODO: matrix with translation if rtcNeeded\n                color: [placedGeometry.color.x, placedGeometry.color.y, placedGeometry.color.z],\n                opacity: placedGeometry.color.w\n            });\n            meshIds.push(meshId);\n        }\n        ctx.sceneModel.createObject({\n            id: objectId,\n            meshIds: meshIds\n        });\n    });\n}"],"names":["parseDataObjectAggregation","ctx","ifcElement","parentDataObjectId","id","GlobalId","value","type","__proto__","constructor","name","dataModel","createObject","Name","createRelationship","IfcRelAggregates","relatingObjectId","relatedObjectId","createDataObject","dataObjectId","parseRelatedItemsOfType","expressID","WebIFC","IFCRELAGGREGATES","IFCRELCONTAINEDINSPATIALSTRUCTURE","relation","related","lines","ifcAPI","GetLineIDsWithType","modelId","i","size","relID","get","rel","GetLine","relatedItems","Array","isArray","map","item","includes","element","forEach","element2","params","Error","sceneModel","destroyed","built","Promise","resolve","reject","dataArray","Uint8Array","data","OpenModel","IFCPROJECT","ifcProjectId","nextId","ifcProject","IFCRELDEFINESBYPROPERTIES","relatingPropertyDefinition","RelatingPropertyDefinition","propertySetId","props","HasProperties","length","propertySetName","properties","len","prop","nominalValue","NominalValue","push","valueType","description","Description","createPropertySet","relatedObjects","RelatedObjects","dataObject","dataObjects","propertySetIds","parsePropertySets","parseDataModel","StreamAllMeshes","flatMesh","placedGeometries","geometries","meshIds","objectId","matrix","createMat4","origin","createVec3","j","lenj","placedGeometry","geometry","GetGeometry","geometryExpressID","vertexData","GetVertexArray","GetVertexData","GetVertexDataSize","indices","GetIndexArray","GetIndexData","GetIndexDataSize","positions","Float64Array","k","l","lenk","set","flatTransformation","transformPositions3","worldToRTCPositions","geometryId","createGeometry","primitive","TrianglesPrimitive","meshId","createMesh","color","x","y","z","opacity","w","parseSceneModel"],"mappings":"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"}