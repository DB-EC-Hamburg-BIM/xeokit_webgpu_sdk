{"version":3,"file":"index.modern.mjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fsvg)](https://badge.fury.io/js/%40xeokit%2Fmath)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)\n *\n * <img src=\"http://xeokit.io/img/kdtree.jpeg\" />\n *\n * # xeokit Boundaries Math Library\n *\n * ---\n *\n * ### *Tools for 2D and 3D boundary analysis, boundary transformation, and collision detection*\n *\n * ---\n *\n * * Axis-aligned boundaries (AABB2 and AABB3)\n * * Object-aligned boundaries (OBB)\n * * Transformable OOBs\n * * Create boundaries from positions\n * * Find center of positions\n * * FrustumProjection-boundary intersection tests\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/boundaries\n * ````\n *\n * ## Usage\n *\n * ````javascript\n * import * as boundaries from \"@xeokit/boundaries\";\n *\n * //..TODO\n * ````\n *\n * @module @xeokit/boundaries\n */\nimport type {FloatArrayParam, IntArrayParam} from \"@xeokit/math\";\nimport {createMat4, createVec2, createVec3, lenVec3, mulMat4, subVec3} from \"@xeokit/matrix\";\nimport {MAX_DOUBLE, MIN_DOUBLE, newFloatArray} from \"@xeokit/math\";\nimport {decompressPoint3} from \"@xeokit/compression\";\n\n\nconst tempVec3a = createVec3();\nconst tempVec3b = createVec3();\nconst tempMat4a = createMat4();\n\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3(values?: FloatArrayParam): Float64Array {\n    // @ts-ignore\n    return new Float64Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3Int16(values?: IntArrayParam): Int16Array {\n    // @ts-ignore\n    return new Int16Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 2D axis-aligned bounding box.\n */\nexport function createAABB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 4);\n}\n\n/**\n * Returns a new, uninitialized 3D oriented bounding box (OBB).\n */\nexport function createOBB3(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 32);\n}\n\n/**\n * Returns a new, uninitialized 2D oriented bounding box (OBB).\n */\nexport function createOBB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 16);\n}\n\n/** Returns a new 3D bounding sphere */\nexport function createSphere3(\n    x: number,\n    y: number,\n    z: number,\n    r: number\n): FloatArrayParam {\n    return newFloatArray([x, y, z, r]);\n}\n\n/**\n * Transforms an createOBB3 by a 4x4 \n */\nexport function transformOBB3(\n    m: FloatArrayParam,\n    p: FloatArrayParam,\n    p2: FloatArrayParam = p\n): FloatArrayParam {\n    let i;\n    const len = p.length;\n\n    let x;\n    let y;\n    let z;\n\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n\n    for (i = 0; i < len; i += 4) {\n        x = p[i + 0];\n        y = p[i + 1];\n        z = p[i + 2];\n\n        p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;\n        p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;\n        p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;\n        p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;\n    }\n\n    return p2;\n}\n\n\n/** Returns true if the first AABB2 contains the second AABB2.\n */\nexport function containsAABB2(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    return aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb1[2] <= aabb2[2];\n}\n\n/** Returns true if the first AABB3 contains the second AABB3.\n */\nexport function containsAABB3(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    const result =\n        aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb2[4] <= aabb1[4] &&\n        aabb1[2] <= aabb2[2] &&\n        aabb2[5] <= aabb1[5];\n    return result;\n}\n\n/**\n * Gets the diagonal size of an createAABB3 given as minima and maxima.\n */\nexport const getAABB3Diag: Function = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n    return (aabb: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n        subVec3(max, min, tempVec3);\n        return Math.abs(lenVec3(tempVec3));\n    };\n})();\n\n/**\n * Get a diagonal boundary size that is symmetrical about the given point.\n */\nexport const getAABB3DiagPoint = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n\n    return (aabb: FloatArrayParam, p: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n\n        const diagVec = subVec3(max, min, tempVec3);\n\n        const xneg = p[0] - aabb[0];\n        const xpos = aabb[3] - p[0];\n        const yneg = p[1] - aabb[1];\n        const ypos = aabb[4] - p[1];\n        const zneg = p[2] - aabb[2];\n        const zpos = aabb[5] - p[2];\n\n        diagVec[0] += xneg > xpos ? xneg : xpos;\n        diagVec[1] += yneg > ypos ? yneg : ypos;\n        diagVec[2] += zneg > zpos ? zneg : zpos;\n\n        return Math.abs(lenVec3(diagVec));\n    };\n})();\n\n/**\n * Gets the area of an AABB.\n */\nexport function getAABB3Area(aabb: FloatArrayParam): number {\n    const width = aabb[3] - aabb[0];\n    const height = aabb[4] - aabb[1];\n    const depth = aabb[5] - aabb[2];\n    return width * height * depth;\n}\n\n/**\n * Gets the center of an AABB.\n */\nexport function getAABB3Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    dest[0] = (aabb[0] + aabb[3]) / 2;\n    dest[1] = (aabb[1] + aabb[4]) / 2;\n    dest[2] = (aabb[2] + aabb[5]) / 2;\n    return dest;\n}\n\n/**\n * Gets the center of a 2D AABB.\n */\nexport function getAABB2Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec2()\n): FloatArrayParam {\n    dest[0] = (aabb[2] + aabb[0]) / 2;\n    dest[1] = (aabb[3] + aabb[1]) / 2;\n    return dest;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3(aabb: FloatArrayParam = createAABB3()): FloatArrayParam {\n    aabb[0] = MAX_DOUBLE;\n    aabb[1] = MAX_DOUBLE;\n    aabb[2] = MAX_DOUBLE;\n    aabb[3] = MIN_DOUBLE;\n    aabb[4] = MIN_DOUBLE;\n    aabb[5] = MIN_DOUBLE;\n    return aabb;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3Int16(aabb: IntArrayParam = createAABB3Int16()): IntArrayParam {\n    aabb[0] = 65535;\n    aabb[1] = 65535;\n    aabb[2] = 65535;\n    aabb[3] = -65535;\n    aabb[4] = -65535;\n    aabb[5] = -65535;\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n *\n * @private\n */\nexport function AABB3ToOBB3(aabb: FloatArrayParam = createAABB3(), obb = createOBB3()): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n */\nexport function expandAABB3(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[2] > aabb2[2]) {\n        aabb1[2] = aabb2[2];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    if (aabb1[5] < aabb2[5]) {\n        aabb1[5] = aabb2[5];\n    }\n    return aabb1;\n}\n\n/**\n * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n */\nexport function expandAABB2(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    return aabb1;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n */\nexport function expandAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[2] > p[2]) {\n        aabb[2] = p[2];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    if (aabb[5] < p[2]) {\n        aabb[5] = p[2];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 2D boundary to enclose the given point, if needed.\n */\nexport function expandAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n */\nexport function expandAABB3Points3(aabb: FloatArrayParam, positions: FloatArrayParam): FloatArrayParam {\n    var x;\n    var y;\n    var z;\n    for (var i = 0, len = positions.length; i < len; i += 3) {\n        x = positions[i];\n        y = positions[i + 1];\n        z = positions[i + 2];\n        if (aabb[0] > x) {\n            aabb[0] = x;\n        }\n        if (aabb[1] > y) {\n            aabb[1] = y;\n        }\n        if (aabb[2] > z) {\n            aabb[2] = z;\n        }\n        if (aabb[3] < x) {\n            aabb[3] = x;\n        }\n        if (aabb[4] < y) {\n            aabb[4] = y;\n        }\n        if (aabb[5] < z) {\n            aabb[5] = z;\n        }\n    }\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n */\nexport function ABB3ToOBB3(\n    aabb: FloatArrayParam,\n    obb: FloatArrayParam = createOBB3()\n): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport const positions3ToAABB3 = (() => {\n    const p = newFloatArray(3);\n\n    return (\n        positions: FloatArrayParam,\n        aabb: FloatArrayParam,\n        positionsDecompressMatrix: FloatArrayParam\n    ): FloatArrayParam => {\n        aabb = aabb || createAABB3();\n\n        let xmin = MAX_DOUBLE;\n        let ymin = MAX_DOUBLE;\n        let zmin = MAX_DOUBLE;\n        let xmax = MIN_DOUBLE;\n        let ymax = MIN_DOUBLE;\n        let zmax = MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            if (positionsDecompressMatrix) {\n                p[0] = positions[i + 0];\n                p[1] = positions[i + 1];\n                p[2] = positions[i + 2];\n\n                decompressPoint3(p, positionsDecompressMatrix, p);\n\n                x = p[0];\n                y = p[1];\n                z = p[2];\n            } else {\n                x = positions[i + 0];\n                y = positions[i + 1];\n                z = positions[i + 2];\n            }\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    };\n})();\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport function OBB3ToAABB3(\n    obb: FloatArrayParam,\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = obb.length; i < len; i += 4) {\n        x = obb[i + 0];\n        y = obb[i + 1];\n        z = obb[i + 2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n */\nexport function points3ToAABB3(\n    points: number[][],\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = points.length; i < len; i++) {\n        x = points[i][0];\n        y = points[i][1];\n        z = points[i][2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Gets the 3D center of the given flat array of 3D positions.\n */\nexport function getPositions3Center(\n    positions: FloatArrayParam,\n    center: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    let xCenter = 0;\n    let yCenter = 0;\n    let zCenter = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        xCenter += positions[i + 0];\n        yCenter += positions[i + 1];\n        zCenter += positions[i + 2];\n    }\n    const numPositions = positions.length / 3;\n    center[0] = xCenter / numPositions;\n    center[1] = yCenter / numPositions;\n    center[2] = zCenter / numPositions;\n    return center;\n}\n\n\n/**\n * A plane within a {@link Frustum3}.\n */\nexport class FrustumPlane3 {\n\n    public testVertex: FloatArrayParam;\n    public offset: number;\n    public normal: FloatArrayParam;\n\n    /**\n     * Creates a new frustum plane.\n     */\n    constructor() {\n        this.normal = createVec3();\n        this.offset = 0;\n        this.testVertex = createVec3();\n    }\n\n    /**\n     * Sets the position and direction of the frustum plane.\n     * @param nx\n     * @param ny\n     * @param nz\n     * @param offset\n     */\n    set(nx: number, ny: number, nz: number, offset: number) {\n        const s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n        this.normal[0] = nx * s;\n        this.normal[1] = ny * s;\n        this.normal[2] = nz * s;\n        this.offset = offset * s;\n        this.testVertex[0] = (this.normal[0] >= 0.0) ? 1 : 0;\n        this.testVertex[1] = (this.normal[1] >= 0.0) ? 1 : 0;\n        this.testVertex[2] = (this.normal[2] >= 0.0) ? 1 : 0;\n    }\n}\n\n/**\n * Intersection state in which first boundary is completely inside the second.\n */\nexport const INSIDE: number = 1;\n\n/**\n * Intersection state in which two boundaries partially intersect.\n */\nexport const INTERSECT: number = 2;\n\n/**\n * Intersection state in which two boundaries do not intersect.\n */\nexport const OUTSIDE: number = 3;\n\n/**\n * A 3D frustum defined as six planes.\n */\nexport class Frustum3 {\n\n    /**\n     * The six planes that comprise the frustum boundary.\n     */\n    public planes: FrustumPlane3[];\n\n    /**\n     * Creates a new FrustumProjection\n     */\n    constructor() {\n        this.planes = [\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(),\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3()\n        ];\n    }\n}\n\n/**\n * Sets the extents of a frustum to the World-space volume defined by view and projection matrices.\n * Creates the frustum first if not given.\n */\nexport function setFrustum3(viewMat: FloatArrayParam, projMat: FloatArrayParam, frustum?: Frustum3) {\n    const m = mulMat4(projMat, viewMat, tempMat4a);\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n    frustum = frustum || new Frustum3();\n    frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);\n    frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);\n    frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);\n    frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);\n    frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);\n    frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);\n    return frustum;\n}\n\n/**\n * Tests for intersection between a frustum and an axis-aligned 3D boundary.\n * @param frustum\n * @param aabb\n */\nexport function intersectFrustum3AABB3(frustum: Frustum3, aabb: FloatArrayParam): number {\n    let ret = INSIDE;\n    const min = tempVec3a;\n    const max = tempVec3b;\n    min[0] = aabb[0];\n    min[1] = aabb[1];\n    min[2] = aabb[2];\n    max[0] = aabb[3];\n    max[1] = aabb[4];\n    max[2] = aabb[5];\n    const bminmax = [min, max];\n    for (let i = 0; i < 6; ++i) {\n        const plane = frustum.planes[i];\n        if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            return OUTSIDE;\n        }\n        if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            ret = INTERSECT;\n        }\n    }\n    return ret;\n}\n\n/**\n * Tests for intersection between two axis-aligned 3D boundaries.\n * @param aabb1\n * @param aabb2\n */\nexport function intersectAABB3s(aabb1: FloatArrayParam, aabb2: FloatArrayParam): number {\n\n    return INTERSECT;\n    // let ret = INSIDE;\n    // const min = tempVec3a;\n    // const max = tempVec3b;\n    // min[0] = aabb[0];\n    // min[1] = aabb[1];\n    // min[2] = aabb[2];\n    // max[0] = aabb[3];\n    // max[1] = aabb[4];\n    // max[2] = aabb[5];\n    // const bminmax = [min, max];\n    // for (let i = 0; i < 6; ++i) {\n    //     const plane = frustum.planes[i];\n    //     if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         return OUTSIDE;\n    //     }\n    //     if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         ret = INTERSECT;\n    //     }\n    // }\n    // return ret;\n}\n\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Triangles3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given triangle primitive.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param a\n * @param b\n * @param c\n */\nexport function intersectFrustum3Triangle3(frustum: Frustum3, a: FloatArrayParam, b: FloatArrayParam, c: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Lines3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!PointsPrimitive | PointsPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n */\nexport function intersectFrustum3Positions3(frustum: Frustum3, positions: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given position.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param position\n */\nexport function intersectFrustum3Point3(frustum: Frustum3, position: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Triangles3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n        // if (aabbIntersectsTriangle(positions, indices[i], indices[i + 1], indices[i + 2], aabb)) {\n        //     return true;\n        // }\n    }\n    return false;\n}\n\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Lines3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam) {\n    return false;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!PointsPrimitive | PointsPrimitive} vertex positions.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n */\nexport function intersectAABB3Positions3(aabb: FloatArrayParam, positions: FloatArrayParam) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xmax = aabb[3];\n    const ymax = aabb[4];\n    const zmax = aabb[5];\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const x = positions[i];\n        if (xmin <= x && x <= xmax) {\n            const y = positions[i + 1];\n            if (ymin <= y && y <= ymax) {\n                const z = positions[i + 2];\n                if (zmin <= z && z <= zmax) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Tets if the given 3D AABB contains the given 3D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4] &&\n        aabb[2] <= p[2] && p[2] <= aabb[5]);\n}\n\n/**\n * Tets if the given 2D AABB contains the given 2D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4]);\n}"],"names":["tempVec3a","createVec3","tempVec3b","tempMat4a","createMat4","createAABB3","values","Float64Array","createAABB3Int16","Int16Array","createAABB2","newFloatArray","createOBB3","createOBB2","createSphere3","x","y","z","r","transformOBB3","m","p","p2","i","len","length","m0","m1","m2","m3","m4","m5","m6","m7","m8","m9","m10","m11","m12","m13","m14","m15","containsAABB2","aabb1","aabb2","containsAABB3","getAABB3Diag","min","max","tempVec3","aabb","subVec3","Math","abs","lenVec3","getAABB3DiagPoint","diagVec","xneg","xpos","yneg","ypos","zneg","zpos","getAABB3Area","getAABB3Center","dest","getAABB2Center","createVec2","collapseAABB3","MAX_DOUBLE","MIN_DOUBLE","collapseAABB3Int16","AABB3ToOBB3","obb","expandAABB3","expandAABB2","expandAABB3Point3","expandAABB2Point2","expandAABB3Points3","positions","ABB3ToOBB3","positions3ToAABB3","positionsDecompressMatrix","xmin","ymin","zmin","xmax","ymax","zmax","decompressPoint3","OBB3ToAABB3","points3ToAABB3","points","getPositions3Center","center","xCenter","yCenter","zCenter","numPositions","FrustumPlane3","constructor","testVertex","this","offset","normal","set","nx","ny","nz","s","sqrt","INSIDE","INTERSECT","OUTSIDE","Frustum3","planes","setFrustum3","viewMat","projMat","frustum","mulMat4","intersectFrustum3AABB3","ret","bminmax","plane","intersectAABB3s","intersectFrustum3Triangles3","indices","intersectFrustum3Triangle3","a","b","c","intersectFrustum3Lines3","intersectFrustum3Positions3","intersectFrustum3Point3","position","intersectAABB3Triangles3","intersectAABB3Lines3","intersectAABB3Positions3","containsAABB3Point3","containsAABB2Point2"],"mappings":"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"}