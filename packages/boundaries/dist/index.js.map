{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fsvg)](https://badge.fury.io/js/%40xeokit%2Fmath)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)\n *\n * <img src=\"http://xeokit.io/img/kdtree.jpeg\" />\n *\n * # xeokit Boundaries Math Library\n *\n * ---\n *\n * ### *Tools for 2D and 3D boundary analysis, boundary transformation, and collision detection*\n *\n * ---\n *\n * * Axis-aligned boundaries (AABB2 and AABB3)\n * * Object-aligned boundaries (OBB)\n * * Transformable OOBs\n * * Create boundaries from positions\n * * Find center of positions\n * * FrustumProjection-boundary intersection tests\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/boundaries\n * ````\n *\n * ## Usage\n *\n * ````javascript\n * import * as boundaries from \"@xeokit/boundaries\";\n *\n * //..TODO\n * ````\n *\n * @module @xeokit/boundaries\n */\nimport type {FloatArrayParam, IntArrayParam} from \"@xeokit/math\";\nimport {createMat4, createVec2, createVec3, lenVec3, mulMat4, subVec3} from \"@xeokit/matrix\";\nimport {MAX_DOUBLE, MIN_DOUBLE, newFloatArray} from \"@xeokit/math\";\nimport {decompressPoint3} from \"@xeokit/compression\";\n\n\nconst tempVec3a = createVec3();\nconst tempVec3b = createVec3();\nconst tempMat4a = createMat4();\n\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3(values?: FloatArrayParam): Float64Array {\n    // @ts-ignore\n    return new Float64Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3Int16(values?: IntArrayParam): Int16Array {\n    // @ts-ignore\n    return new Int16Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 2D axis-aligned bounding box.\n */\nexport function createAABB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 4);\n}\n\n/**\n * Returns a new, uninitialized 3D oriented bounding box (OBB).\n */\nexport function createOBB3(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 32);\n}\n\n/**\n * Returns a new, uninitialized 2D oriented bounding box (OBB).\n */\nexport function createOBB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 16);\n}\n\n/** Returns a new 3D bounding sphere */\nexport function createSphere3(\n    x: number,\n    y: number,\n    z: number,\n    r: number\n): FloatArrayParam {\n    return newFloatArray([x, y, z, r]);\n}\n\n/**\n * Transforms an createOBB3 by a 4x4 \n */\nexport function transformOBB3(\n    m: FloatArrayParam,\n    p: FloatArrayParam,\n    p2: FloatArrayParam = p\n): FloatArrayParam {\n    let i;\n    const len = p.length;\n\n    let x;\n    let y;\n    let z;\n\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n\n    for (i = 0; i < len; i += 4) {\n        x = p[i + 0];\n        y = p[i + 1];\n        z = p[i + 2];\n\n        p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;\n        p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;\n        p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;\n        p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;\n    }\n\n    return p2;\n}\n\n\n/** Returns true if the first AABB2 contains the second AABB2.\n */\nexport function containsAABB2(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    return aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb1[2] <= aabb2[2];\n}\n\n/** Returns true if the first AABB3 contains the second AABB3.\n */\nexport function containsAABB3(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    const result =\n        aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb2[4] <= aabb1[4] &&\n        aabb1[2] <= aabb2[2] &&\n        aabb2[5] <= aabb1[5];\n    return result;\n}\n\n/**\n * Gets the diagonal size of an createAABB3 given as minima and maxima.\n */\nexport const getAABB3Diag: Function = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n    return (aabb: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n        subVec3(max, min, tempVec3);\n        return Math.abs(lenVec3(tempVec3));\n    };\n})();\n\n/**\n * Get a diagonal boundary size that is symmetrical about the given point.\n */\nexport const getAABB3DiagPoint = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n\n    return (aabb: FloatArrayParam, p: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n\n        const diagVec = subVec3(max, min, tempVec3);\n\n        const xneg = p[0] - aabb[0];\n        const xpos = aabb[3] - p[0];\n        const yneg = p[1] - aabb[1];\n        const ypos = aabb[4] - p[1];\n        const zneg = p[2] - aabb[2];\n        const zpos = aabb[5] - p[2];\n\n        diagVec[0] += xneg > xpos ? xneg : xpos;\n        diagVec[1] += yneg > ypos ? yneg : ypos;\n        diagVec[2] += zneg > zpos ? zneg : zpos;\n\n        return Math.abs(lenVec3(diagVec));\n    };\n})();\n\n/**\n * Gets the area of an AABB.\n */\nexport function getAABB3Area(aabb: FloatArrayParam): number {\n    const width = aabb[3] - aabb[0];\n    const height = aabb[4] - aabb[1];\n    const depth = aabb[5] - aabb[2];\n    return width * height * depth;\n}\n\n/**\n * Gets the center of an AABB.\n */\nexport function getAABB3Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    dest[0] = (aabb[0] + aabb[3]) / 2;\n    dest[1] = (aabb[1] + aabb[4]) / 2;\n    dest[2] = (aabb[2] + aabb[5]) / 2;\n    return dest;\n}\n\n/**\n * Gets the center of a 2D AABB.\n */\nexport function getAABB2Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec2()\n): FloatArrayParam {\n    dest[0] = (aabb[2] + aabb[0]) / 2;\n    dest[1] = (aabb[3] + aabb[1]) / 2;\n    return dest;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3(aabb: FloatArrayParam = createAABB3()): FloatArrayParam {\n    aabb[0] = MAX_DOUBLE;\n    aabb[1] = MAX_DOUBLE;\n    aabb[2] = MAX_DOUBLE;\n    aabb[3] = MIN_DOUBLE;\n    aabb[4] = MIN_DOUBLE;\n    aabb[5] = MIN_DOUBLE;\n    return aabb;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3Int16(aabb: IntArrayParam = createAABB3Int16()): IntArrayParam {\n    aabb[0] = 65535;\n    aabb[1] = 65535;\n    aabb[2] = 65535;\n    aabb[3] = -65535;\n    aabb[4] = -65535;\n    aabb[5] = -65535;\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n *\n * @private\n */\nexport function AABB3ToOBB3(aabb: FloatArrayParam = createAABB3(), obb = createOBB3()): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n */\nexport function expandAABB3(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[2] > aabb2[2]) {\n        aabb1[2] = aabb2[2];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    if (aabb1[5] < aabb2[5]) {\n        aabb1[5] = aabb2[5];\n    }\n    return aabb1;\n}\n\n/**\n * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n */\nexport function expandAABB2(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    return aabb1;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n */\nexport function expandAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[2] > p[2]) {\n        aabb[2] = p[2];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    if (aabb[5] < p[2]) {\n        aabb[5] = p[2];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 2D boundary to enclose the given point, if needed.\n */\nexport function expandAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n */\nexport function expandAABB3Points3(aabb: FloatArrayParam, positions: FloatArrayParam): FloatArrayParam {\n    var x;\n    var y;\n    var z;\n    for (var i = 0, len = positions.length; i < len; i += 3) {\n        x = positions[i];\n        y = positions[i + 1];\n        z = positions[i + 2];\n        if (aabb[0] > x) {\n            aabb[0] = x;\n        }\n        if (aabb[1] > y) {\n            aabb[1] = y;\n        }\n        if (aabb[2] > z) {\n            aabb[2] = z;\n        }\n        if (aabb[3] < x) {\n            aabb[3] = x;\n        }\n        if (aabb[4] < y) {\n            aabb[4] = y;\n        }\n        if (aabb[5] < z) {\n            aabb[5] = z;\n        }\n    }\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n */\nexport function ABB3ToOBB3(\n    aabb: FloatArrayParam,\n    obb: FloatArrayParam = createOBB3()\n): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport const positions3ToAABB3 = (() => {\n    const p = newFloatArray(3);\n\n    return (\n        positions: FloatArrayParam,\n        aabb: FloatArrayParam,\n        positionsDecompressMatrix: FloatArrayParam\n    ): FloatArrayParam => {\n        aabb = aabb || createAABB3();\n\n        let xmin = MAX_DOUBLE;\n        let ymin = MAX_DOUBLE;\n        let zmin = MAX_DOUBLE;\n        let xmax = MIN_DOUBLE;\n        let ymax = MIN_DOUBLE;\n        let zmax = MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            if (positionsDecompressMatrix) {\n                p[0] = positions[i + 0];\n                p[1] = positions[i + 1];\n                p[2] = positions[i + 2];\n\n                decompressPoint3(p, positionsDecompressMatrix, p);\n\n                x = p[0];\n                y = p[1];\n                z = p[2];\n            } else {\n                x = positions[i + 0];\n                y = positions[i + 1];\n                z = positions[i + 2];\n            }\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    };\n})();\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport function OBB3ToAABB3(\n    obb: FloatArrayParam,\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = obb.length; i < len; i += 4) {\n        x = obb[i + 0];\n        y = obb[i + 1];\n        z = obb[i + 2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n */\nexport function points3ToAABB3(\n    points: number[][],\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = points.length; i < len; i++) {\n        x = points[i][0];\n        y = points[i][1];\n        z = points[i][2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Gets the 3D center of the given flat array of 3D positions.\n */\nexport function getPositions3Center(\n    positions: FloatArrayParam,\n    center: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    let xCenter = 0;\n    let yCenter = 0;\n    let zCenter = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        xCenter += positions[i + 0];\n        yCenter += positions[i + 1];\n        zCenter += positions[i + 2];\n    }\n    const numPositions = positions.length / 3;\n    center[0] = xCenter / numPositions;\n    center[1] = yCenter / numPositions;\n    center[2] = zCenter / numPositions;\n    return center;\n}\n\n\n/**\n * A plane within a {@link Frustum3}.\n */\nexport class FrustumPlane3 {\n\n    public testVertex: FloatArrayParam;\n    public offset: number;\n    public normal: FloatArrayParam;\n\n    /**\n     * Creates a new frustum plane.\n     */\n    constructor() {\n        this.normal = createVec3();\n        this.offset = 0;\n        this.testVertex = createVec3();\n    }\n\n    /**\n     * Sets the position and direction of the frustum plane.\n     * @param nx\n     * @param ny\n     * @param nz\n     * @param offset\n     */\n    set(nx: number, ny: number, nz: number, offset: number) {\n        const s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n        this.normal[0] = nx * s;\n        this.normal[1] = ny * s;\n        this.normal[2] = nz * s;\n        this.offset = offset * s;\n        this.testVertex[0] = (this.normal[0] >= 0.0) ? 1 : 0;\n        this.testVertex[1] = (this.normal[1] >= 0.0) ? 1 : 0;\n        this.testVertex[2] = (this.normal[2] >= 0.0) ? 1 : 0;\n    }\n}\n\n/**\n * Intersection state in which first boundary is completely inside the second.\n */\nexport const INSIDE: number = 1;\n\n/**\n * Intersection state in which two boundaries partially intersect.\n */\nexport const INTERSECT: number = 2;\n\n/**\n * Intersection state in which two boundaries do not intersect.\n */\nexport const OUTSIDE: number = 3;\n\n/**\n * A 3D frustum defined as six planes.\n */\nexport class Frustum3 {\n\n    /**\n     * The six planes that comprise the frustum boundary.\n     */\n    public planes: FrustumPlane3[];\n\n    /**\n     * Creates a new FrustumProjection\n     */\n    constructor() {\n        this.planes = [\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(),\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3()\n        ];\n    }\n}\n\n/**\n * Sets the extents of a frustum to the World-space volume defined by view and projection matrices.\n * Creates the frustum first if not given.\n */\nexport function setFrustum3(viewMat: FloatArrayParam, projMat: FloatArrayParam, frustum?: Frustum3) {\n    const m = mulMat4(projMat, viewMat, tempMat4a);\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n    frustum = frustum || new Frustum3();\n    frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);\n    frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);\n    frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);\n    frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);\n    frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);\n    frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);\n    return frustum;\n}\n\n/**\n * Tests for intersection between a frustum and an axis-aligned 3D boundary.\n * @param frustum\n * @param aabb\n */\nexport function intersectFrustum3AABB3(frustum: Frustum3, aabb: FloatArrayParam): number {\n    let ret = INSIDE;\n    const min = tempVec3a;\n    const max = tempVec3b;\n    min[0] = aabb[0];\n    min[1] = aabb[1];\n    min[2] = aabb[2];\n    max[0] = aabb[3];\n    max[1] = aabb[4];\n    max[2] = aabb[5];\n    const bminmax = [min, max];\n    for (let i = 0; i < 6; ++i) {\n        const plane = frustum.planes[i];\n        if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            return OUTSIDE;\n        }\n        if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            ret = INTERSECT;\n        }\n    }\n    return ret;\n}\n\n/**\n * Tests for intersection between two axis-aligned 3D boundaries.\n * @param aabb1\n * @param aabb2\n */\nexport function intersectAABB3s(aabb1: FloatArrayParam, aabb2: FloatArrayParam): number {\n\n    return INTERSECT;\n    // let ret = INSIDE;\n    // const min = tempVec3a;\n    // const max = tempVec3b;\n    // min[0] = aabb[0];\n    // min[1] = aabb[1];\n    // min[2] = aabb[2];\n    // max[0] = aabb[3];\n    // max[1] = aabb[4];\n    // max[2] = aabb[5];\n    // const bminmax = [min, max];\n    // for (let i = 0; i < 6; ++i) {\n    //     const plane = frustum.planes[i];\n    //     if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         return OUTSIDE;\n    //     }\n    //     if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         ret = INTERSECT;\n    //     }\n    // }\n    // return ret;\n}\n\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Triangles3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given triangle primitive.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param a\n * @param b\n * @param c\n */\nexport function intersectFrustum3Triangle3(frustum: Frustum3, a: FloatArrayParam, b: FloatArrayParam, c: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Lines3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/core/constants!PointsPrimitive | PointsPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n */\nexport function intersectFrustum3Positions3(frustum: Frustum3, positions: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given position.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param position\n */\nexport function intersectFrustum3Point3(frustum: Frustum3, position: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Triangles3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n        // if (aabbIntersectsTriangle(positions, indices[i], indices[i + 1], indices[i + 2], aabb)) {\n        //     return true;\n        // }\n    }\n    return false;\n}\n\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Lines3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam) {\n    return false;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/core/constants!PointsPrimitive | PointsPrimitive} vertex positions.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n */\nexport function intersectAABB3Positions3(aabb: FloatArrayParam, positions: FloatArrayParam) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xmax = aabb[3];\n    const ymax = aabb[4];\n    const zmax = aabb[5];\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const x = positions[i];\n        if (xmin <= x && x <= xmax) {\n            const y = positions[i + 1];\n            if (ymin <= y && y <= ymax) {\n                const z = positions[i + 2];\n                if (zmin <= z && z <= zmax) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Tets if the given 3D AABB contains the given 3D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4] &&\n        aabb[2] <= p[2] && p[2] <= aabb[5]);\n}\n\n/**\n * Tets if the given 2D AABB contains the given 2D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4]);\n}"],"names":["tempVec3a","createVec3","tempVec3b","tempMat4a","createMat4","createAABB3","values","Float64Array","createAABB3Int16","Int16Array","createOBB3","newFloatArray","min","max","tempVec3","p","getAABB3Diag","aabb","subVec3","Math","abs","lenVec3","getAABB3DiagPoint","diagVec","xneg","xpos","yneg","ypos","zneg","zpos","positions3ToAABB3","positions","positionsDecompressMatrix","x","y","z","xmin","MAX_DOUBLE","ymin","zmin","xmax","MIN_DOUBLE","ymax","zmax","i","len","length","decompressPoint3","FrustumPlane3","this","testVertex","offset","normal","prototype","set","nx","ny","nz","s","sqrt","Frustum3","planes","obb","aabb1","aabb2","r","dest","createVec2","center","xCenter","yCenter","zCenter","numPositions","indices","frustum","ret","bminmax","plane","position","a","b","c","points","viewMat","projMat","m","mulMat4","m0","m1","m2","m3","m4","m5","m6","m7","m8","m9","m10","m11","m12","m13","m14","m15","p2"],"mappings":"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"}