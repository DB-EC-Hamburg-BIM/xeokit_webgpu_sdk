var kdtree3 = require('@xeokit/kdtree3');
var math = require('@xeokit/math');

var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}

/**
 * Caches reusable resources for {@link rayPick} and {@link marqueePick}.
 *
 * These resources are lazy-generated by these methods. When provided
 * again to the methods, we can avoid the method needing to re-generate them.
 *
 * > Internally, the resources consist of lazy-generated {@link PrimsKdTree3 | PrimsKdTree3s}, cached for
 * {@link @xeokit/scene!GeometryBucket | GeometryBuckets} of
 * candidate {@link @xeokit/scene!SceneObject | SceneObjects} while picking.
 */
class PickPrimsCache {
  /**
   * TODO
   */
  constructor() {
    /**
     * TODO
     */
    this.primitivesKdTrees = void 0;
    this.primitivesKdTrees = {};
  }
  /**
   * TODO
   */
  clear() {
    this.primitivesKdTrees = {};
  }
}

s();
  s();
function v(n, t) {
  return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
}
function h(n) {
  return new FloatArrayClass(n || 2);
}
function M(n) {
  return new Float64Array(n || 3);
}
function s(n) {
  return new FloatArrayClass(n || 4);
}
function F(n, t, r) {
  return r || (r = n), r[0] = n[0] - t[0], r[1] = n[1] - t[1], r;
}
function N(n, t) {
  return n[0] * t[0] + n[1] * t[1];
}
function O(n) {
  return v(n, n);
}
function P(n) {
  return N(n, n);
}
function Q(n) {
  return Math.sqrt(O(n));
}
function T(n) {
  return Math.sqrt(P(n));
}
(function () {
  var n = h();
  return function (t, r) {
    return T(F(t, r, n));
  };
})();
function en(t) {
  return new math.newFloatArray(t || 9);
}
function cn(t) {
  return math.newFloatArray(t || 16);
}
cn();
  cn();
function qn(n) {
  return n || (n = cn()), n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function Xn(n) {
  return n || (n = cn()), n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n;
}
function pn(t, r, u) {
  void 0 === u && (u = math.newFloatArray(9));
  var a = t[0],
    o = t[3],
    i = t[6],
    e = t[1],
    c = t[4],
    f = t[7],
    v = t[2],
    h = t[5],
    M = t[8],
    s = r[0],
    l = r[3],
    d = r[6],
    q = r[1],
    X = r[4],
    Y = r[7],
    Z = r[2],
    b = r[5],
    g = r[8];
  return u[0] = a * s + o * q + i * Z, u[3] = a * l + o * X + i * b, u[6] = a * d + o * Y + i * g, u[1] = e * s + c * q + f * Z, u[4] = e * l + c * X + f * b, u[7] = e * d + c * Y + f * g, u[2] = v * s + h * q + M * Z, u[5] = v * l + h * X + M * b, u[8] = v * d + h * Y + M * g, u;
}
function Dn(n, t) {
  return void 0 === t && (t = qn()), t[0] = n[0], t[5] = n[1], t[10] = n[2], t;
}
function En(n, t) {
  return void 0 === t && (t = Xn()), t[0] = n[0], t[4] = n[1], t;
}
var Gn;
  (Gn = math.newFloatArray(3), function (n, t, r, u) {
    return Gn[0] = n, Gn[1] = t, Gn[2] = r, Dn(Gn, u);
  });
(function () {
  var n = M(),
    t = cn();
  return function (r, u, a, o) {
    n[0] = r[0], n[1] = r[1], n[2] = r[2];
    var i = Q(n);
    n[0] = r[4], n[1] = r[5], n[2] = r[6];
    var e = Q(n);
    n[8] = r[8], n[9] = r[9], n[10] = r[10];
    var c = Q(n);
    Un(r) < 0 && (i = -i), u[0] = r[12], u[1] = r[13], u[2] = r[14], t.set(r);
    var f = 1 / i,
      v = 1 / e,
      h = 1 / c;
    t[0] *= f, t[1] *= f, t[2] *= f, t[4] *= v, t[5] *= v, t[6] *= v, t[8] *= h, t[9] *= h, t[10] *= h, nt(t, a), o[0] = i, o[1] = e, o[2] = c;
  };
})();
function Qn(n, t) {
  var r = t || qn();
  return r[12] = n[0], r[13] = n[1], r[14] = n[2], r;
}
function Rn(n, t) {
  var r = t || Xn();
  return r[6] = n[0], r[7] = n[1], r;
}
(function () {
  var t = math.newFloatArray(3);
  return function (n, r, u, a) {
    return t[0] = n, t[1] = r, t[2] = u, Qn(t, a);
  };
})();
function Un(n) {
  var t = n[0],
    r = n[1],
    u = n[2],
    a = n[3],
    o = n[4],
    i = n[5],
    e = n[6],
    c = n[7],
    f = n[8],
    v = n[9],
    h = n[10],
    M = n[11],
    s = n[12],
    l = n[13],
    d = n[14],
    q = n[15];
  return s * v * e * a - f * l * e * a - s * i * h * a + o * l * h * a + f * i * d * a - o * v * d * a - s * v * u * c + f * l * u * c + s * r * h * c - t * l * h * c - f * r * d * c + t * v * d * c + s * i * u * M - o * l * u * M - s * r * e * M + t * l * e * M + o * r * d * M - t * i * d * M - f * i * u * q + o * v * u * q + f * r * e * q - t * v * e * q - o * r * h * q + t * i * h * q;
}
function nt(n, t) {
  void 0 === t && (t = s());
  var r,
    u = n[0],
    a = n[4],
    o = n[8],
    i = n[1],
    e = n[5],
    c = n[9],
    f = n[2],
    v = n[6],
    h = n[10],
    M = u + e + h;
  return M > 0 ? (r = .5 / Math.sqrt(M + 1), t[3] = .25 / r, t[0] = (v - c) * r, t[1] = (o - f) * r, t[2] = (i - a) * r) : u > e && u > h ? (r = 2 * Math.sqrt(1 + u - e - h), t[3] = (v - c) / r, t[0] = .25 * r, t[1] = (a + i) / r, t[2] = (o + f) / r) : e > h ? (r = 2 * Math.sqrt(1 + e - u - h), t[3] = (o - f) / r, t[0] = (a + i) / r, t[1] = .25 * r, t[2] = (c + v) / r) : (r = 2 * Math.sqrt(1 + h - u - e), t[3] = (i - a) / r, t[0] = (o + f) / r, t[1] = (c + v) / r, t[2] = .25 * r), t;
}

/**
 * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcompression.svg)](https://badge.fury.io/js/%40xeokit%2Fcompression)
 * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/compression/badge)](https://www.jsdelivr.com/package/npm/@xeokit/compression)
 *
 * <img style="padding:20px" src="media://images/geometry_icon.png"/>
 *
 * # xeokit Geometry Compression / Decompression Utilities
 *
 * ---
 *
 * ### *Tools for geometry compression and decompression*
 *
 * ---
 *
 * The xeokit Geometry Compression/Decompression Utilities library provides functions used internally within SceneModel.createGeometry implementations to compress geometry. These functions are also provided for users who want to pre-compress their geometry "offline" and then use SceneModel.createGeometryCompressed to create compressed geometry directly.

 The compression techniques used include simplifying geometry by combining duplicate positions and adjusting indices, generating edge indices for triangle meshes, ignoring normals (as shaders auto-generate them), converting positions to relative-to-center (RTC) coordinates, quantizing positions and UVs as 16-bit unsigned integers, and splitting geometry into buckets to enable indices to use the minimum bits for storage. The bucketing technique was developed for xeokit by Toni Marti with support from Tribia AG.

 To use the library, install it using npm install @xeokit/compression. An example usage includes compressing a GeometryParams into a GeometryCompressedParams using the compressGeometryParams function. In this example, the geometry is simple, and only one bucket is needed. However, if the positions array was large enough to require some indices to use more than 16 bits for storage, the bucketing mechanism would split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.

 The resulting GeometryCompressedParams object shows that we have one bucket with vertex positions relative to the origin and quantized to 16-bit integers, duplicate positions removed, and adjusted indices. Additionally, edge indices are generated for the TrianglesPrimitive, and a positionsDecompressMatrix is included to de-quantize the positions within the Viewer.

 * This library provides a set of functions that are used internally within
 * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry} implementations to
 * compress geometry. The functions are provided here in case users instead want to pre-compress their geometry "offline",
 * and then use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}
 * to create the compressed geometry directly.
 *
 * ### Compression Techniques Used
 *
 * * Simplifies geometry by combining duplicate positions and adjusting indices
 * * Generates edge indices for triangle meshes
 * * Ignores normals (our shaders auto-generate them)
 * * Converts positions to relative-to-center (RTC) coordinates
 * * Quantizes positions and UVs as 16-bit unsigned integers
 * * Splits geometry into {@link @xeokit/scene!GeometryBucketParams | buckets } to enable indices to use the minimum bits for storage
 *
 * ### Aknowledgements
 *
 * * The bucketing technique mentioned above was developed for xeokit by Toni Marti, with support from Tribia AG. Read [the slides](media://pdfs/GPU_RAM_Savings_Toni_Marti_Apr22.pdf) from Toni's presentation at WebGL Meetup 2022.
 *
 * ## Installation
 *
 * ````bash
 * npm install @xeokit/compression
 * ````
 *
 * ## Usage
 *
 * In the example below, we'll use {@link compressGeometryParams} to compress
 * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a
 * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.
 *
 * In this example, our geometry is very simple, and our GeometryCompressedParams only gets a single
 * {@link @xeokit/scene!GeometryBucketParams | GeometryBucketParams }. Note that if the
 * {@link @xeokit/scene!GeometryParams.positions | GeometryParams.positions} array was large enough to require
 * some of the indices to use more than 16 bits for storage, then that's when the function's bucketing mechanism would
 * kick in, to split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.
 *
 * ````javascript
 * import {compressGeometryParams} from "@xeokit/compression";
 * import {TrianglesPrimitive} from "@xeokit/constants";
 *
 * const geometryCompressedParams = compressGeometryParams({
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [
 *          202, 202, 202, 200, 202, 202,
 *          200, 200, 202, 202, 200, 202,
 *          202, 202, 202, 202, 200, 202,
 *          202, 200, 200, 202, 202, 200,
 *          202, 202, 202, 202, 202, 200,
 *          200, 202, 200, 200, 202, 202,
 *          200, 202, 202, 200, 202, 200,
 *          200, 200, 200, 200, 200, 202,
 *          200, 200, 200, 202, 200, 200,
 *          202, 200, 202, 200, 200, 202,
 *          202, 200, 200, 200, 200, 200,
 *          200, 202, 200, 202, 202, 200
 *      ],
 *      indices: [
 *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4,
 *          6, 7, 8, 9, 10, 8, 10, 11, 12,
 *          13, 14, 12, 14, 15, 16, 17, 18,
 *          16, 18, 19, 20, 21, 22, 20, 22, 23
 *      ]
 *  });
 * ````
 *
 * The value of our new {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams} is shown below.
 *
 * We can see that:
 *
 * * We get one bucket, because we have only a small number of indices
 * * Vertex positions are now relative to ````origin```` and quantized to 16-bit integers
 * * Duplicate positions are removed and indices adjusted
 * * Edge indices generated for our TrianglesPrimitive
 * * A ````positionsDecompressMatrix```` to de-quantize the positions within the Viewer
 *
 * ````javascript
 * {
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      origin: [200,200,200],
 *      positionsDecompressMatrix: [
 *          0.00003052270125906143, 0, 0, 0,
 *          0, 0.00003052270125906143, 0, 0,
 *          0, 0, 0.00003052270125906143, 0,
 *          -1, -1, -1, 1
 *      ],
 *      geometryBuckets: [
 *          {
 *              positionsCompressed: [
 *                  65525, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 65525, 65525,
 *                  0, 0, 65525, 65525, 0, 0, 65525, 0, 0,
 *                  0, 0
 *              ],
 *              indices: [
 *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,
 *                  4, 7, 6, 4, 6, 5
 *              ],
 *              edgeIndices: [
 *                  3, 4, 0, 4, 5, 0, 5, 6,
 *                  0, 6, 1, 1, 6, 7, 1, 7,
 *                  3, 2, 4, 7, 6, 4, 6
 *              ]
 *          }
 *      ]
 * }
 * ````
 *
 * In the next example, we'll again use {@link compressGeometryParams} to compress
 * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a
 * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}, which we'll then use to
 * create a compressed geometry within a {@link @xeokit/scene!SceneModel | SceneModel}.
 *
 * ````javascript
 * import {Scene} from "@xeokit/scene";
 * import {TrianglesPrimitive} from "@xeokit/constants";
 * import {compressGeometryParams} from "@xeokit/compression";
 *
 * const scene = new Scene();
 *
 * const sceneModel = scene.createModel({
 *     id: "myModel"
 * });
 *
 * const geometryCompressedParams = compressGeometryParams({
 *      id: "myBoxGeometry",
 *      primitive: TrianglesPrimitive,
 *      positions: [202, 202, 202, 200, 202, 202, ...],
 *      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, ...]
 * });
 *
 * sceneModel.createGeometryCompressed(geometryCompressedParams);
 *
 * sceneModel.createMesh({ id: "myMesh", geometryId: "myGeometry" });
 *
 * sceneModel.createObject({ id: "myObject1", meshIds: ["myMesh"] });
 * sceneModel.createObject({ id: "myObject2", meshIds: ["myMesh"] });
 *
 * sceneModel.build();
 * ````
 *
 * @module @xeokit/compression
 */
cn();
cn();
/**
 * Decompresses a flat array of positions
 * @param positions
 * @param decompressMatrix
 * @param dest
 */
function decompressPositions3(positions, decompressMatrix, dest = new Float32Array(positions.length)) {
  for (let i = 0, len = positions.length; i < len; i += 3) {
    dest[i + 0] = positions[i + 0] * decompressMatrix[0] + decompressMatrix[12];
    dest[i + 1] = positions[i + 1] * decompressMatrix[5] + decompressMatrix[13];
    dest[i + 2] = positions[i + 2] * decompressMatrix[10] + decompressMatrix[14];
  }
  return dest;
}
/**
 * Compresses a flat array of UV coordinates
 */
(function () {
  const translate = en();
  const scale = en();
  return function (array, min, max) {
    const quantized = new Uint16Array(array.length);
    const multiplier = new Float32Array([65535 / (max[0] - min[0]), 65535 / (max[1] - min[1])]);
    let i;
    for (i = 0; i < array.length; i += 2) {
      quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
      quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
    }
    Xn(translate);
    Rn(min, translate);
    Xn(scale);
    En([(max[0] - min[0]) / 65535, (max[1] - min[1]) / 65535], scale);
    const decompressMatrix = pn(translate, scale, Xn());
    return {
      quantized: quantized,
      decompressMatrix: decompressMatrix
    };
  };
})();

/**
 * See {@link "@xeokit/collision/pick"} for usage.
 */
var _pickPrimsCache = /*#__PURE__*/_classPrivateFieldLooseKey("pickPrimsCache");
var _getPrimsKdTree = /*#__PURE__*/_classPrivateFieldLooseKey("getPrimsKdTree3");
class Picker {
  constructor() {
    Object.defineProperty(this, _getPrimsKdTree, {
      value: _getPrimsKdTree2
    });
    Object.defineProperty(this, _pickPrimsCache, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _pickPrimsCache)[_pickPrimsCache] = new PickPrimsCache();
  }
  /**
   * TODO
   * @param params
   */
  rayPick(params) {
    const rayPickResult = {
      sceneObjectHits: []
    };
    // const kdItems = searchKdTree3WithRay({kdTree: sceneObjectsKdTree3, origin, dir});
    // for (let i = 0, len = kdItems.length; i < len; i++) {
    //     const item = kdItems[i];
    //     const sceneObject: SceneObject = item.sceneObject;
    //     const meshHits: MeshHit[] = [];
    //     for (let j = 0, lenj = sceneObject.meshes.length; j < lenj; j++) {
    //         const mesh = sceneObject.meshes[j];
    //         const geometryBucketHits: GeometryBucketHit[] = [];
    //         //////////////////////
    //         // Transform ray into mesh local space, by inverse of mesh matrix
    //         ///////////////////////
    //         const geometry = mesh.geometry;
    //         for (let k = 0, lenk = geometry.geometryBuckets.length; k < lenk; k++) {
    //             const primHits: any[] = [];
    //             const geometryBucket = geometry.geometryBuckets[k];
    //             let primsKdTree3 = this.#getPrimsKdTree3(geometry, k, geometryBucket);
    //             const primitives = searchKdTree3WithRay({kdTree: primsKdTree3.primsKdTree3, origin, dir});
    //             if (primitives.length) {
    //                 switch (geometry.primitive) {
    //                     case TrianglesPrimitive:
    //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {
    //                             // const triangle = <KdTrianglePrim>primitives[l];
    //                             // const a = triangle.a;
    //                             // const b = triangle.b;
    //                             // const c = triangle.c;
    //                             // const cx = primsKdTree3.positions[a * 3];
    //                             // const cy = primsKdTree3.positions[a * 3 + 1];
    //                             // const cz = primsKdTree3.positions[a * 3 + 2];
    //
    //                             //////////////////////////
    //                             // Get ray-triangle intersection in worldPos
    //                             /////////////////////////////
    //
    //                             //     primHits.push({primitive: triangle, worldPos});
    //                         }
    //                         break;
    //                     case LinesPrimitive:
    //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {
    //                           //  const line = <KdLinePrim>primitives[l];
    //                             //     primHits.push({primitive: line, worldPos});
    //                         }
    //                         break;
    //                     case PointsPrimitive:
    //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {
    //                         //    const point = <KdPointPrim>primitives[l];
    //                             //      primHits.push({primitive: point, worldPos});
    //                         }
    //                         break;
    //                 }
    //             }
    //             if (primHits.length > 0) {
    //                 geometryBucketHits.push({geometryBucket, primHits});
    //             }
    //         }
    //         if (geometryBucketHits.length > 0) {
    //             meshHits.push({mesh, geometry, geometryBucketHits})
    //         }
    //     }
    //     if (meshHits.length) {
    //         rayPickResult.sceneObjectHits.push({sceneObject, meshHits});
    //     }
    // }
    return rayPickResult;
  }
  /**
   * Picks a {@link SceneObjectsKdTree3} using a 2D marquee to obtain a {@link MarqueePickResult}
   * containing picked {@link SceneObject | SceneObjects}, {@link Mesh}, {@link Geometry},
   * {@link GeometryBucket | GeometryBuckets}, {@link KdTrianglePrim}, {@link KdLinePrim} and {@link KdPointPrim}.
   * @param params
   */
  marqueePick(params) {
    const sceneObjectsKdTree3 = params.sceneObjectsKdTree3;
    _classPrivateFieldLooseBase(this, _pickPrimsCache)[_pickPrimsCache];
    const marqueePickResult = {
      sceneObjects: []
    };
    const frustum = null; // Create from marquee
    const kdItems = kdtree3.searchKdTree3WithFrustum({
      kdTree: sceneObjectsKdTree3,
      frustum
    });
    for (let i = 0, len = kdItems.length; i < len; i++) {
      const kdItem = kdItems[i];
      const sceneObject = kdItem.item;
      for (let j = 0, lenj = sceneObject.meshes.length; j < lenj; j++) {
        const mesh = sceneObject.meshes[j];
        //////////////////////
        // Transform frustum into mesh local space, by inverse of mesh matrix
        ///////////////////////
        const geometry = mesh.geometry;
        for (let k = 0, lenk = geometry.geometryBuckets.length; k < lenk; k++) {
          const geometryBucket = geometry.geometryBuckets[k];
          let primsKdTree3 = _classPrivateFieldLooseBase(this, _getPrimsKdTree)[_getPrimsKdTree](geometry, k, geometryBucket);
          kdtree3.searchKdTree3WithFrustum({
            kdTree: primsKdTree3.primitivesKdTree,
            frustum
          });
        }
      }
    }
    return marqueePickResult;
  }
}
function _getPrimsKdTree2(geometry, k, geometryBucket) {
  const kdTreeId = `${geometry.id}-${k}`;
  let primsKdTree3 = _classPrivateFieldLooseBase(this, _pickPrimsCache)[_pickPrimsCache][kdTreeId];
  if (!primsKdTree3) {
    const positions = decompressPositions3(geometryBucket.positionsCompressed, geometry.positionsDecompressMatrix, new Float32Array(geometryBucket.positionsCompressed.length));
    primsKdTree3 = {
      primsKdTree3: kdtree3.createPrimsKdTree3(geometry.primitive, positions, geometryBucket.indices),
      positions
    };
    _classPrivateFieldLooseBase(this, _pickPrimsCache)[_pickPrimsCache][kdTreeId] = primsKdTree3;
  }
  return primsKdTree3;
}

exports.Picker = Picker;
//# sourceMappingURL=index.js.map
