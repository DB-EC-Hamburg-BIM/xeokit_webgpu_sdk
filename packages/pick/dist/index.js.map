{"version":3,"file":"index.js","sources":["../src/PickPrimsCache.ts","../../matrix/dist/index.es","../../compression/src/index.ts","../src/Picker.ts"],"sourcesContent":["import {KdTree3, PrimsKdTree3} from \"@xeokit/kdtree3\";\nimport {FloatArrayParam} from \"@xeokit/math\";\n\n/**\n * Caches reusable resources for {@link rayPick} and {@link marqueePick}.\n *\n * These resources are lazy-generated by these methods. When provided\n * again to the methods, we can avoid the method needing to re-generate them.\n *\n * > Internally, the resources consist of lazy-generated {@link PrimsKdTree3 | PrimsKdTree3s}, cached for\n * {@link @xeokit/scene!GeometryBucket | GeometryBuckets} of\n * candidate {@link @xeokit/scene!SceneObject | SceneObjects} while picking.\n */\nexport class PickPrimsCache {\n\n    /**\n     * TODO\n     */\n    primitivesKdTrees: {\n        [key: string]: {\n            primitivesKdTree: PrimsKdTree3,\n            positions: FloatArrayParam\n        }\n    };\n\n    /**\n     * TODO\n     */\n    constructor() {\n        this.primitivesKdTrees = {};\n    }\n\n    /**\n     * TODO\n     */\n    clear() {\n        this.primitivesKdTrees = {};\n    }\n}","import{newFloatArray as n,clamp as t,DEGTORAD as r}from\"@xeokit/math\";var u=s(),a=M(),o=M(),i=M(),e=M(),c=M(),f=s();function v(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function h(n){return new FloatArrayClass(n||2)}function M(n){return new Float64Array(n||3)}function s(n){return new FloatArrayClass(n||4)}function l(n,t){return t||(t=n),t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t}function d(n,t){return t||(t=n),t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t}function q(n,t,r){return r||(r=n),r[0]=n[0]+t[0],r[1]=n[1]+t[1],r[2]=n[2]+t[2],r[3]=n[3]+t[3],r}function X(n,t,r){return r||(r=n),r[0]=n[0]+t,r[1]=n[1]+t,r[2]=n[2]+t,r[3]=n[3]+t,r}function Y(n,t,r){return r||(r=n),r[0]=n[0]*t,r[1]=n[1]*t,r[2]=n[2]*t,r[3]=n[3]*t,r}function Z(n,t,r){return r||(r=n),r[0]=n[0]*t,r[1]=n[1]*t,r[2]=n[2]*t,r}function b(n,t,r){return r||(r=n),r[0]=n[0]*t,r[1]=n[1]*t,r}function g(n,t,r){return r||(r=n),r[0]=n[0]+t[0],r[1]=n[1]+t[1],r[2]=n[2]+t[2],r}function y(n,t,r){return r||(r=n),r[0]=n[0]+t,r[1]=n[1]+t,r[2]=n[2]+t,r}function w(n,t,r){return r||(r=n),r[0]=n[0]-t[0],r[1]=n[1]-t[1],r[2]=n[2]-t[2],r[3]=n[3]-t[3],r}function A(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]}function p(n,t,r){return r||(r=n),r[0]=n[0]-t[0],r[1]=n[1]-t[1],r[2]=n[2]-t[2],r}function F(n,t,r){return r||(r=n),r[0]=n[0]-t[0],r[1]=n[1]-t[1],r}function m(){for(var n=[].slice.call(arguments),t=new Float32Array(n[0]),r=1;r<n.length;r++)t[0]+=n[r][0],t[1]+=n[r][1];return t[0]/=n.length,t[1]/=n.length,t}function x(n,t,r){return r||(r=n),r[0]=n[0]-t,r[1]=n[1]-t,r[2]=n[2]-t,r[3]=n[3]-t,r}function C(n,t,r){return r||(r=n),r[0]=t-n[0],r[1]=t-n[1],r[2]=t-n[2],r[3]=t-n[3],r}function k(n,t,r){return r||(r=n),r[0]=n[0]*t[0],r[1]=n[1]*t[1],r[2]=n[2]*t[2],r[3]=n[3]*t[3],r}function j(n,t,r){return r||(r=n),r[0]=n[0]/t[0],r[1]=n[1]/t[1],r[2]=n[2]/t[2],r}function z(n,t,r){return r||(r=n),r[0]=n[0]/t[0],r[1]=n[1]/t[1],r[2]=n[2]/t[2],r[3]=n[3]/t[3],r}function B(n,t,r){return r||(r=t),r[0]=n/t[0],r[1]=n/t[1],r[2]=n/t[2],r}function D(n,t,r){return r||(r=n),r[0]=n[0]/t,r[1]=n[1]/t,r[2]=n[2]/t,r}function E(n,t,r){return r||(r=n),r[0]=n[0]/t,r[1]=n[1]/t,r[2]=n[2]/t,r[3]=n[3]/t,r}function G(n,t,r){return r||(r=t),r[0]=n/t[0],r[1]=n/t[1],r[2]=n/t[2],r[3]=n/t[3],r}function H(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function I(n,t){var r=n[0],u=n[1],a=n[2],o=t[0],i=t[1],e=t[2];return[u*e-a*i,a*o-r*e,r*i-u*o,0]}function J(n,t,r){r||(r=n);var u=n[0],a=n[1],o=n[2],i=t[0],e=t[1],c=t[2];return r[0]=a*c-o*e,r[1]=o*i-u*c,r[2]=u*e-a*i,r}function K(n){return H(n,n)}function L(n){return Math.sqrt(K(n))}function N(n,t){return n[0]*t[0]+n[1]*t[1]}function O(n){return v(n,n)}function P(n){return N(n,n)}function Q(n){return Math.sqrt(O(n))}var R,S=(R=M(),function(n,t){return Q(p(n,t,R))});function T(n){return Math.sqrt(P(n))}function U(n,t,r,u,a,o){var i=o||M(),e=(n-t)/(r-t);return i[0]=u[0]+e*(a[0]-u[0]),i[1]=u[1]+e*(a[1]-u[1]),i[2]=u[2]+e*(a[2]-u[2]),i}var V=function(){var n=h();return function(t,r){return T(F(t,r,n))}}();function W(n,t){return B(1,n,t)}function $(n,t){return Y(n,1/L(n),t)}function _(n,t){return Z(n,1/Q(n),t)}function nn(n,t){return b(n,1/T(n),t)}function tn(n,t){var r=v(n,t)/Math.sqrt(O(n)*O(t));return r=r<-1?-1:r>1?1:r,Math.acos(r)}var rn=function(){var n=M();return function(t,r){return n[0]=t[0],n[1]=t[1],n[2]=t[2],r[0]=Q(n),n[0]=t[4],n[1]=t[5],n[2]=t[6],r[1]=Q(n),n[0]=t[8],n[1]=t[9],n[2]=t[10],r[2]=Q(n),r}}();function un(n){for(var t=0,r=(n=Array.prototype.slice.call(n)).length;t<r;t++)n[t]=an(n[t]);return n}function an(n){return Math.round(1e5*n)/1e5}function on(n,t,r,u){void 0===u&&(u=M());var a=t[0]-n[0],o=t[1]-n[1],i=t[2]-n[2],e=r[0]-n[0],c=r[1]-n[1],f=r[2]-n[2],v=o*f-i*c,h=i*e-a*f,s=a*c-o*e,l=Math.sqrt(v*v+h*h+s*s);return 0===l?(u[0]=0,u[1]=0,u[2]=0):(u[0]=v/l,u[1]=h/l,u[2]=s/l),u}function en(t){return new n(t||9)}function cn(t){return n(t||16)}var fn=cn(),vn=cn();function hn(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]&&n[4]===t[4]&&n[5]===t[5]&&n[6]===t[6]&&n[7]===t[7]&&n[8]===t[8]&&n[9]===t[9]&&n[10]===t[10]&&n[11]===t[11]&&n[12]===t[12]&&n[13]===t[13]&&n[14]===t[14]&&n[15]===t[15]}function Mn(n,t,r,u,a){var o=[],i=[];return o[2]=r,i[2]=u,i[1]=o[2]*Math.tan(n/2),o[1]=-i[1],i[0]=i[1]*t,o[0]=-i[0],sn(o,i,a)}function sn(n,t,r){r||(r=cn());var u=[n[0],n[1],n[2],0],a=[t[0],t[1],t[2],0];q(a,u,fn),w(a,u,vn);var o=2*u[2],i=vn[0],e=vn[1],c=vn[2];return r[0]=o/i,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o/e,r[6]=0,r[7]=0,r[8]=fn[0]/i,r[9]=fn[1]/e,r[10]=-fn[2]/c,r[11]=-1,r[12]=0,r[13]=0,r[14]=-o*a[2]/c,r[15]=0,r}function ln(n,t,r,u,a,o,i){i||(i=cn());var e=t-n,c=u-r,f=o-a;return i[0]=2/e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2/c,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-2/f,i[11]=0,i[12]=-(n+t)/e,i[13]=-(u+r)/c,i[14]=-(o+a)/f,i[15]=1,i}function dn(n,t,r,u,a,o,i){i||(i=cn());var e=t-n,c=u-r,f=o-a;return i[0]=2*a/e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2*a/c,i[6]=0,i[7]=0,i[8]=(t+n)/e,i[9]=(u+r)/c,i[10]=-(o+a)/f,i[11]=-1,i[12]=0,i[13]=0,i[14]=-o*a*2/f,i[15]=0,i}function qn(n){return n||(n=cn()),n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function Xn(n){return n||(n=cn()),n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=1,n[5]=0,n[6]=0,n[7]=0,n[8]=1,n}function Yn(n){return 1===n[0]&&0===n[1]&&0===n[2]&&0===n[3]&&0===n[4]&&1===n[5]&&0===n[6]&&0===n[7]&&0===n[8]&&0===n[9]&&1===n[10]&&0===n[11]&&0===n[12]&&0===n[13]&&0===n[14]&&1===n[15]}function Zn(n,t,r){r||(r=cn());var u,a,o,i,e,c,f=$([t[0],t[1],t[2],0],[]),v=Math.sin(n),h=Math.cos(n),M=1-h,s=f[0],l=f[1],d=f[2];return u=s*l,a=l*d,o=d*s,i=s*v,e=l*v,c=d*v,r[0]=M*s*s+h,r[1]=M*u+c,r[2]=M*o-e,r[3]=0,r[4]=M*u-c,r[5]=M*l*l+h,r[6]=M*a+i,r[7]=0,r[8]=M*o+e,r[9]=M*a-i,r[10]=M*d*d+h,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function bn(n,t,r,u){u||(u=cn());var a,o,i,e,c,f,v,h,M,s,l=n[0],d=n[1],q=n[2],X=r[0],Y=r[1],Z=r[2],b=t[0],g=t[1],y=t[2];return l===b&&d===g&&q===y?qn():(a=l-b,o=d-g,i=q-y,e=Y*(i*=s=1/Math.sqrt(a*a+o*o+i*i))-Z*(o*=s),c=Z*(a*=s)-X*i,f=X*o-Y*a,(s=Math.sqrt(e*e+c*c+f*f))?(e*=s=1/s,c*=s,f*=s):(e=0,c=0,f=0),v=o*f-i*c,h=i*e-a*f,M=a*c-o*e,(s=Math.sqrt(v*v+h*h+M*M))?(v*=s=1/s,h*=s,M*=s):(v=0,h=0,M=0),u[0]=e,u[1]=v,u[2]=a,u[3]=0,u[4]=c,u[5]=h,u[6]=o,u[7]=0,u[8]=f,u[9]=M,u[10]=i,u[11]=0,u[12]=-(e*l+c*d+f*q),u[13]=-(v*l+h*d+M*q),u[14]=-(a*l+o*d+i*q),u[15]=1,u)}function gn(n,t){t||(t=n);var r=n[0],u=n[1],a=n[2],o=n[3],i=n[4],e=n[5],c=n[6],f=n[7],v=n[8],h=n[9],M=n[10],s=n[11],l=n[12],d=n[13],q=n[14],X=n[15],Y=r*e-u*i,Z=r*c-a*i,b=r*f-o*i,g=u*c-a*e,y=u*f-o*e,w=a*f-o*c,A=v*d-h*l,p=v*q-M*l,F=v*X-s*l,m=h*q-M*d,x=h*X-s*d,C=M*X-s*q,k=1/(Y*C-Z*x+b*m+g*F-y*p+w*A);return t[0]=(e*C-c*x+f*m)*k,t[1]=(-u*C+a*x-o*m)*k,t[2]=(d*w-q*y+X*g)*k,t[3]=(-h*w+M*y-s*g)*k,t[4]=(-i*C+c*F-f*p)*k,t[5]=(r*C-a*F+o*p)*k,t[6]=(-l*w+q*b-X*Z)*k,t[7]=(v*w-M*b+s*Z)*k,t[8]=(i*x-e*F+f*A)*k,t[9]=(-r*x+u*F-o*A)*k,t[10]=(l*y-d*b+X*Y)*k,t[11]=(-v*y+h*b-s*Y)*k,t[12]=(-i*m+e*p-c*A)*k,t[13]=(r*m-u*p+a*A)*k,t[14]=(-l*g+d*Z-q*Y)*k,t[15]=(v*g-h*Z+M*Y)*k,t}function yn(n,t){var r=n[4],u=n[14],a=n[8],o=n[13],i=n[12],e=n[9];if(!t||n===t){var c=n[1],f=n[2],v=n[3],h=n[6],M=n[7],s=n[11];return n[1]=r,n[2]=a,n[3]=i,n[4]=c,n[6]=e,n[7]=o,n[8]=f,n[9]=h,n[11]=u,n[12]=v,n[13]=M,n[14]=s,n}return t[0]=n[0],t[1]=r,t[2]=a,t[3]=i,t[4]=n[1],t[5]=n[5],t[6]=e,t[7]=o,t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=u,t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15],t}function wn(n,t,r){r||(r=n);var u=t[0],a=t[1],o=t[2],i=t[3];return r[0]=n[0]*u+n[4]*a+n[8]*o+n[12]*i,r[1]=n[1]*u+n[5]*a+n[9]*o+n[13]*i,r[2]=n[2]*u+n[6]*a+n[10]*o+n[14]*i,r[3]=n[3]*u+n[7]*a+n[11]*o+n[15]*i,r}function An(n,t,r){r||(r=n);var u=n[0],a=n[1],o=n[2],i=n[3],e=n[4],c=n[5],f=n[6],v=n[7],h=n[8],M=n[9],s=n[10],l=n[11],d=n[12],q=n[13],X=n[14],Y=n[15],Z=t[0],b=t[1],g=t[2],y=t[3],w=t[4],A=t[5],p=t[6],F=t[7],m=t[8],x=t[9],C=t[10],k=t[11],j=t[12],z=t[13],B=t[14],D=t[15];return r[0]=Z*u+b*e+g*h+y*d,r[1]=Z*a+b*c+g*M+y*q,r[2]=Z*o+b*f+g*s+y*X,r[3]=Z*i+b*v+g*l+y*Y,r[4]=w*u+A*e+p*h+F*d,r[5]=w*a+A*c+p*M+F*q,r[6]=w*o+A*f+p*s+F*X,r[7]=w*i+A*v+p*l+F*Y,r[8]=m*u+x*e+C*h+k*d,r[9]=m*a+x*c+C*M+k*q,r[10]=m*o+x*f+C*s+k*X,r[11]=m*i+x*v+C*l+k*Y,r[12]=j*u+z*e+B*h+D*d,r[13]=j*a+z*c+B*M+D*q,r[14]=j*o+z*f+B*s+D*X,r[15]=j*i+z*v+B*l+D*Y,r}function pn(t,r,u){void 0===u&&(u=n(9));var a=t[0],o=t[3],i=t[6],e=t[1],c=t[4],f=t[7],v=t[2],h=t[5],M=t[8],s=r[0],l=r[3],d=r[6],q=r[1],X=r[4],Y=r[7],Z=r[2],b=r[5],g=r[8];return u[0]=a*s+o*q+i*Z,u[3]=a*l+o*X+i*b,u[6]=a*d+o*Y+i*g,u[1]=e*s+c*q+f*Z,u[4]=e*l+c*X+f*b,u[7]=e*d+c*Y+f*g,u[2]=v*s+h*q+M*Z,u[5]=v*l+h*X+M*b,u[8]=v*d+h*Y+M*g,u}function Fn(n,t,r){r||(r=t);var u=t[0],a=t[1],o=t[2];return r[0]=n[0]*u+n[4]*a+n[8]*o+n[12],r[1]=n[1]*u+n[5]*a+n[9]*o+n[13],r[2]=n[2]*u+n[6]*a+n[10]*o+n[14],r}function mn(n,t,r){return r[0]=n[0]*t[0]+n[4]*t[1]+n[8]*t[2]+n[12]*t[3],r[1]=n[1]*t[0]+n[5]*t[1]+n[9]*t[2]+n[13]*t[3],r[2]=n[2]*t[0]+n[6]*t[1]+n[10]*t[2]+n[14]*t[3],r[3]=n[3]*t[0]+n[7]*t[1]+n[11]*t[2]+n[15]*t[3],r}function xn(n,t,r){for(var u,a,o,i,e,c=r||[],f=t.length,v=n[0],h=n[1],M=n[2],s=n[3],l=n[4],d=n[5],q=n[6],X=n[7],Y=n[8],Z=n[9],b=n[10],g=n[11],y=n[12],w=n[13],A=n[14],p=n[15],F=0;F<f;++F)u=(i=t[F])[0],a=i[1],o=i[2],(e=c[F]||(c[F]=[0,0,0]))[0]=v*u+l*a+Y*o+y,e[1]=h*u+d*a+Z*o+w,e[2]=M*u+q*a+b*o+A,e[3]=s*u+X*a+g*o+p;return c.length=f,c}function Cn(n,t,r){var u;r||(r=t);var a,o,i,e=t.length,c=n[0],f=n[1],v=n[2],h=n[3],M=n[4],s=n[5],l=n[6],d=n[7],q=n[8],X=n[9],Y=n[10],Z=n[11],b=n[12],g=n[13],y=n[14],w=n[15];for(u=0;u<e;u+=3)r[u+0]=c*(a=t[u+0])+M*(o=t[u+1])+q*(i=t[u+2])+b,r[u+1]=f*a+s*o+X*i+g,r[u+2]=v*a+l*o+Y*i+y,r[u+3]=h*a+d*o+Z*i+w;return r}function kn(n,t,r){var u;r||(r=t);var a,o,i,e=t.length,c=n[0],f=n[1],v=n[2],h=n[3],M=n[4],s=n[5],l=n[6],d=n[7],q=n[8],X=n[9],Y=n[10],Z=n[11],b=n[12],g=n[13],y=n[14],w=n[15];for(u=0;u<e;u+=4)r[u+0]=c*(a=t[u+0])+M*(o=t[u+1])+q*(i=t[u+2])+b,r[u+1]=f*a+s*o+X*i+g,r[u+2]=v*a+l*o+Y*i+y,r[u+3]=h*a+d*o+Z*i+w;return r}function jn(n,t,r){var u=t[0],a=t[1],o=t[2];return(r=r||M())[0]=n[0]*u+n[4]*a+n[8]*o,r[1]=n[1]*u+n[5]*a+n[9]*o,r[2]=n[2]*u+n[6]*a+n[10]*o,r}function zn(n,t,r){var u=t[0],a=t[1],o=t[2],i=t[3];return(r=r||s())[0]=n[0]*u+n[4]*a+n[8]*o+n[12]*i,r[1]=n[1]*u+n[5]*a+n[9]*o+n[13]*i,r[2]=n[2]*u+n[6]*a+n[10]*o+n[14]*i,r[3]=n[3]*u+n[7]*a+n[11]*o+n[15]*i,r}function Bn(n,t){void 0===t&&(t=qn());var r=n[0],u=n[1],a=n[2];return t[0]*=r,t[4]*=u,t[8]*=a,t[1]*=r,t[5]*=u,t[9]*=a,t[2]*=r,t[6]*=u,t[10]*=a,t[3]*=r,t[7]*=u,t[11]*=a,t}function Dn(n,t){return void 0===t&&(t=qn()),t[0]=n[0],t[5]=n[1],t[10]=n[2],t}function En(n,t){return void 0===t&&(t=Xn()),t[0]=n[0],t[4]=n[1],t}var Gn,Hn=(Gn=n(3),function(n,t,r,u){return Gn[0]=n,Gn[1]=t,Gn[2]=r,Dn(Gn,u)});function In(n,t,r,u){return u[0]*=n,u[4]*=t,u[8]*=r,u[1]*=n,u[5]*=t,u[9]*=r,u[2]*=n,u[6]*=t,u[10]*=r,u[3]*=n,u[7]*=t,u[11]*=r,u}function Jn(n){return Hn(n,n,n)}function Kn(n,t,r,u){return void 0===u&&(u=cn()),et(t,u),Bn(r,u),Nn(n,u),u}var Ln=function(){var n=M(),t=cn();return function(r,u,a,o){n[0]=r[0],n[1]=r[1],n[2]=r[2];var i=Q(n);n[0]=r[4],n[1]=r[5],n[2]=r[6];var e=Q(n);n[8]=r[8],n[9]=r[9],n[10]=r[10];var c=Q(n);Un(r)<0&&(i=-i),u[0]=r[12],u[1]=r[13],u[2]=r[14],t.set(r);var f=1/i,v=1/e,h=1/c;t[0]*=f,t[1]*=f,t[2]*=f,t[4]*=v,t[5]*=v,t[6]*=v,t[8]*=h,t[9]*=h,t[10]*=h,nt(t,a),o[0]=i,o[1]=e,o[2]=c}}();function Nn(n,t){return void 0===t&&(t=qn()),On(n[0],n[1],n[2],t)}function On(n,t,r,u){void 0===u&&(u=qn());var a=u[3];u[0]+=a*n,u[1]+=a*t,u[2]+=a*r;var o=u[7];u[4]+=o*n,u[5]+=o*t,u[6]+=o*r;var i=u[11];u[8]+=i*n,u[9]+=i*t,u[10]+=i*r;var e=u[15];return u[12]+=e*n,u[13]+=e*t,u[14]+=e*r,u}function Pn(n,t,r){return r[0]=n[0],r[1]=n[1],r[2]=n[2],r[3]=n[3],r[4]=n[4],r[5]=n[5],r[6]=n[6],r[7]=n[7],r[8]=n[8],r[9]=n[9],r[10]=n[10],r[11]=n[11],r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=n[15],r}function Qn(n,t){var r=t||qn();return r[12]=n[0],r[13]=n[1],r[14]=n[2],r}function Rn(n,t){var r=t||Xn();return r[6]=n[0],r[7]=n[1],r}var Sn=function(){var t=n(3);return function(n,r,u,a){return t[0]=n,t[1]=r,t[2]=u,Qn(t,a)}}();function Tn(n,t){return Sn(n,n,n,t)}function Un(n){var t=n[0],r=n[1],u=n[2],a=n[3],o=n[4],i=n[5],e=n[6],c=n[7],f=n[8],v=n[9],h=n[10],M=n[11],s=n[12],l=n[13],d=n[14],q=n[15];return s*v*e*a-f*l*e*a-s*i*h*a+o*l*h*a+f*i*d*a-o*v*d*a-s*v*u*c+f*l*u*c+s*r*h*c-t*l*h*c-f*r*d*c+t*v*d*c+s*i*u*M-o*l*u*M-s*r*e*M+t*l*e*M+o*r*d*M-t*i*d*M-f*i*u*q+o*v*u*q+f*r*e*q-t*v*e*q-o*r*h*q+t*i*h*q}function Vn(n,r,u){void 0===u&&(u=M());var a=n[0],o=n[4],i=n[8],e=n[1],c=n[5],f=n[9],v=n[2],h=n[6],s=n[10];return\"XYZ\"===r?(u[1]=Math.asin(t(i,-1,1)),Math.abs(i)<.99999?(u[0]=Math.atan2(-f,s),u[2]=Math.atan2(-o,a)):(u[0]=Math.atan2(h,c),u[2]=0)):\"YXZ\"===r?(u[0]=Math.asin(-t(f,-1,1)),Math.abs(f)<.99999?(u[1]=Math.atan2(i,s),u[2]=Math.atan2(e,c)):(u[1]=Math.atan2(-v,a),u[2]=0)):\"ZXY\"===r?(u[0]=Math.asin(t(h,-1,1)),Math.abs(h)<.99999?(u[1]=Math.atan2(-v,s),u[2]=Math.atan2(-o,c)):(u[1]=0,u[2]=Math.atan2(e,a))):\"ZYX\"===r?(u[1]=Math.asin(-t(v,-1,1)),Math.abs(v)<.99999?(u[0]=Math.atan2(h,s),u[2]=Math.atan2(e,a)):(u[0]=0,u[2]=Math.atan2(-o,c))):\"YZX\"===r?(u[2]=Math.asin(t(e,-1,1)),Math.abs(e)<.99999?(u[0]=Math.atan2(-f,c),u[1]=Math.atan2(-v,a)):(u[0]=0,u[1]=Math.atan2(i,s))):\"XZY\"===r&&(u[2]=Math.asin(-t(o,-1,1)),Math.abs(o)<.99999?(u[0]=Math.atan2(h,c),u[1]=Math.atan2(i,a)):(u[0]=Math.atan2(-f,s),u[1]=0)),u}function Wn(n,t,r,u,a,o){var i=o||cn(),e=(n-t)/(r-t);return i[0]=u[0]+e*(a[0]-u[0]),i[1]=u[1]+e*(a[1]-u[1]),i[2]=u[2]+e*(a[2]-u[2]),i[3]=u[3]+e*(a[3]-u[3]),i[4]=u[4]+e*(a[4]-u[4]),i[5]=u[5]+e*(a[5]-u[5]),i[6]=u[6]+e*(a[6]-u[6]),i[7]=u[7]+e*(a[7]-u[7]),i[8]=u[8]+e*(a[8]-u[8]),i[9]=u[9]+e*(a[9]-u[9]),i[10]=u[10]+e*(a[10]-u[10]),i[11]=u[11]+e*(a[11]-u[11]),i[12]=u[12]+e*(a[12]-u[12]),i[13]=u[13]+e*(a[13]-u[13]),i[14]=u[14]+e*(a[14]-u[14]),i[15]=u[15]+e*(a[15]-u[15]),i}function $n(n){return void 0===n&&(n=s()),n[0]=0,n[1]=0,n[2]=0,n[3]=1,n}function _n(n,t,u){void 0===u&&(u=s());var a=n[0]*r/2,o=n[1]*r/2,i=n[2]*r/2,e=Math.cos(a),c=Math.cos(o),f=Math.cos(i),v=Math.sin(a),h=Math.sin(o),M=Math.sin(i);return\"XYZ\"===t?(u[0]=v*c*f+e*h*M,u[1]=e*h*f-v*c*M,u[2]=e*c*M+v*h*f,u[3]=e*c*f-v*h*M):\"YXZ\"===t?(u[0]=v*c*f+e*h*M,u[1]=e*h*f-v*c*M,u[2]=e*c*M-v*h*f,u[3]=e*c*f+v*h*M):\"ZXY\"===t?(u[0]=v*c*f-e*h*M,u[1]=e*h*f+v*c*M,u[2]=e*c*M+v*h*f,u[3]=e*c*f-v*h*M):\"ZYX\"===t?(u[0]=v*c*f-e*h*M,u[1]=e*h*f+v*c*M,u[2]=e*c*M-v*h*f,u[3]=e*c*f+v*h*M):\"YZX\"===t?(u[0]=v*c*f+e*h*M,u[1]=e*h*f+v*c*M,u[2]=e*c*M-v*h*f,u[3]=e*c*f-v*h*M):\"XZY\"===t&&(u[0]=v*c*f-e*h*M,u[1]=e*h*f-v*c*M,u[2]=e*c*M+v*h*f,u[3]=e*c*f+v*h*M),u}function nt(n,t){void 0===t&&(t=s());var r,u=n[0],a=n[4],o=n[8],i=n[1],e=n[5],c=n[9],f=n[2],v=n[6],h=n[10],M=u+e+h;return M>0?(r=.5/Math.sqrt(M+1),t[3]=.25/r,t[0]=(v-c)*r,t[1]=(o-f)*r,t[2]=(i-a)*r):u>e&&u>h?(r=2*Math.sqrt(1+u-e-h),t[3]=(v-c)/r,t[0]=.25*r,t[1]=(a+i)/r,t[2]=(o+f)/r):e>h?(r=2*Math.sqrt(1+e-u-h),t[3]=(o-f)/r,t[0]=(a+i)/r,t[1]=.25*r,t[2]=(c+v)/r):(r=2*Math.sqrt(1+h-u-e),t[3]=(i-a)/r,t[0]=(o+f)/r,t[1]=(c+v)/r,t[2]=.25*r),t}function tt(n,t,r){void 0===r&&(r=s());var u=Math.sqrt(v(n,n)*v(t,t)),a=u+v(n,t);return a<1e-8*u?(a=0,Math.abs(n[0])>Math.abs(n[2])?(r[0]=-n[1],r[1]=n[0],r[2]=0):(r[0]=0,r[1]=-n[2],r[2]=n[1])):J(n,t,r),r[3]=a,ct(r)}function rt(n,t){void 0===t&&(t=s());var r=n[3]/2,u=Math.sin(r);return t[0]=u*n[0],t[1]=u*n[1],t[2]=u*n[2],t[3]=Math.cos(r),t}function ut(n,t,r){return void 0===r&&(r=M()),et(n,fn),Vn(fn,t,r),r}function at(n,t,r){void 0===r&&(r=s());var u=n[0],a=n[1],o=n[2],i=n[3],e=t[0],c=t[1],f=t[2],v=t[3];return r[0]=i*e+u*v+a*f-o*c,r[1]=i*c+a*v+o*e-u*f,r[2]=i*f+o*v+u*c-a*e,r[3]=i*v-u*e-a*c-o*f,r}function ot(n,t,r){void 0===r&&(r=M());var u=t[0],a=t[1],o=t[2],i=n[0],e=n[1],c=n[2],f=n[3],v=f*u+e*o-c*a,h=f*a+c*u-i*o,s=f*o+i*a-e*u,l=-i*u-e*a-c*o;return r[0]=v*f+l*-i+h*-c-s*-e,r[1]=h*f+l*-e+s*-i-v*-c,r[2]=s*f+l*-c+v*-e-h*-i,r}function it(n,t){t=qn(t);var r=n[0],u=n[1],a=n[2],o=n[3],i=2*r,e=2*u,c=2*a,f=i*o,v=e*o,h=c*o,M=i*r,s=e*r,l=c*r,d=e*u,q=c*u,X=c*a;return t[0]=1-(d+X),t[1]=s+h,t[2]=l-v,t[4]=s-h,t[5]=1-(M+X),t[6]=q+f,t[8]=l+v,t[9]=q-f,t[10]=1-(M+d),t}function et(n,t){var r=n[0],u=n[1],a=n[2],o=n[3],i=r+r,e=u+u,c=a+a,f=r*i,v=r*e,h=r*c,M=u*e,s=u*c,l=a*c,d=o*i,q=o*e,X=o*c;return t[0]=1-(M+l),t[4]=v-X,t[8]=h+q,t[1]=v+X,t[5]=1-(f+l),t[9]=s-d,t[2]=h-q,t[6]=s+d,t[10]=1-(f+M),t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function ct(n,t){void 0===t&&(t=n);var r=L([n[0],n[1],n[2],n[3]]);return t[0]=n[0]/r,t[1]=n[1]/r,t[2]=n[2]/r,t[3]=n[3]/r,t}function ft(n,t){return void 0===t&&(t=n),t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t}function vt(n,t){return ct(ft(n,t))}function ht(n,t){void 0===t&&(t=s());var r=(n=ct(n,u))[3],a=2*Math.acos(r),o=Math.sqrt(1-r*r);return o<.001?(t[0]=n[0],t[1]=n[1],t[2]=n[2]):(t[0]=n[0]/o,t[1]=n[1]/o,t[2]=n[2]/o),t[3]=a,t}function Mt(n,t,r,u,f,h){h=h||M();var s=p(u,r,a),l=p(f,r,o),d=J(t,l,i),q=v(s,d);if(q<1e-6)return null;var X=p(n,r,e),Y=v(X,d);if(Y<0||Y>q)return null;var Z=J(X,s,c),b=v(t,Z);if(b<0||Y+b>q)return null;var g=v(l,Z)/q;return h[0]=n[0]+g*t[0],h[1]=n[1]+g*t[1],h[2]=n[2]+g*t[2],h}function st(n,t,r,a,o){u[0]=t[0],u[1]=t[1],u[2]=t[2],u[3]=1,zn(n,u,f),a[0]=f[0],a[1]=f[1],a[2]=f[2],u[0]=r[0],u[1]=r[1],u[2]=r[2],jn(n,u,f),_(f),o[0]=f[0],o[1]=f[1],o[2]=f[2]}export{g as addVec3,y as addVec3Scalar,q as addVec4,X as addVec4Scalar,rt as angleAxisToQuaternion,tn as angleVec3,hn as compareMat4,A as compareVec3,Kn as composeMat4,ft as conjugateQuat,en as createMat3,cn as createMat4,h as createVec2,M as createVec3,s as createVec4,J as cross3Vec3,I as cross3Vec4,Ln as decomposeMat4,Un as determinantMat4,V as distVec2,S as distVec3,B as divScalarVec3,G as divScalarVec4,j as divVec3,D as divVec3Scalar,z as divVec4,E as divVec4Scalar,N as dotVec2,v as dotVec3,H as dotVec4,_n as eulerToQuat,dn as frustumMat4,sn as frustumMat4v,m as geometricMeanVec2,Xn as identityMat3,qn as identityMat4,$n as identityQuat,gn as inverseMat4,vt as inverseQuat,Yn as isIdentityMat4,T as lenVec2,Q as lenVec3,L as lenVec4,Wn as lerpMat4,U as lerpVec3,bn as lookAtMat4v,Vn as mat4ToEuler,nt as mat4ToQuat,pn as mulMat3,An as mulMat4,wn as mulMat4v4,at as mulQuats,b as mulVec2Scalar,Z as mulVec3Scalar,k as mulVec4,Y as mulVec4Scalar,l as negateVec3,d as negateVec4,ct as normalizeQuat,nn as normalizeVec2,_ as normalizeVec3,$ as normalizeVec4,ln as orthoMat4c,Mn as perspectiveMat4,ht as quatToAngleAxis,ut as quatToEuler,it as quatToMat4,et as quatToRotationMat4,Mt as rayTriangleIntersect,W as rcpVec3,Zn as rotationMat4v,In as scaleMat4c,Bn as scaleMat4v,En as scalingMat3v,Hn as scalingMat4c,Jn as scalingMat4s,Dn as scalingMat4v,Pn as setMat4Translation,P as sqLenVec2,O as sqLenVec3,K as sqLenVec4,C as subScalarVec4,F as subVec2,p as subVec3,w as subVec4,x as subVec4Scalar,Fn as transformPoint3,mn as transformPoint4,xn as transformPoints3,Cn as transformPositions3,kn as transformPositions4,st as transformRay,jn as transformVec3,zn as transformVec4,On as translateMat4c,Nn as translateMat4v,Rn as translationMat3v,Sn as translationMat4c,Tn as translationMat4s,Qn as translationMat4v,yn as transposeMat4,on as triangleNormal,ot as vec3ApplyQuat,rn as vec3FromMat4Scale,tt as vec3PairToQuat,un as vecToArray};\n//# sourceMappingURL=index.es.map\n","/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fcompression.svg)](https://badge.fury.io/js/%40xeokit%2Fcompression)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/compression/badge)](https://www.jsdelivr.com/package/npm/@xeokit/compression)\n * \n * <img style=\"padding:20px\" src=\"media://images/geometry_icon.png\"/>\n *\n * # xeokit Geometry Compression / Decompression Utilities\n *\n * ---\n *\n * ### *Tools for geometry compression and decompression*\n *\n * ---\n *\n * The xeokit Geometry Compression/Decompression Utilities library provides functions used internally within SceneModel.createGeometry implementations to compress geometry. These functions are also provided for users who want to pre-compress their geometry \"offline\" and then use SceneModel.createGeometryCompressed to create compressed geometry directly.\n\n The compression techniques used include simplifying geometry by combining duplicate positions and adjusting indices, generating edge indices for triangle meshes, ignoring normals (as shaders auto-generate them), converting positions to relative-to-center (RTC) coordinates, quantizing positions and UVs as 16-bit unsigned integers, and splitting geometry into buckets to enable indices to use the minimum bits for storage. The bucketing technique was developed for xeokit by Toni Marti with support from Tribia AG.\n\n To use the library, install it using npm install @xeokit/compression. An example usage includes compressing a GeometryParams into a GeometryCompressedParams using the compressGeometryParams function. In this example, the geometry is simple, and only one bucket is needed. However, if the positions array was large enough to require some indices to use more than 16 bits for storage, the bucketing mechanism would split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.\n\n The resulting GeometryCompressedParams object shows that we have one bucket with vertex positions relative to the origin and quantized to 16-bit integers, duplicate positions removed, and adjusted indices. Additionally, edge indices are generated for the TrianglesPrimitive, and a positionsDecompressMatrix is included to de-quantize the positions within the Viewer.\n\n * This library provides a set of functions that are used internally within\n * {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry} implementations to\n * compress geometry. The functions are provided here in case users instead want to pre-compress their geometry \"offline\",\n * and then use {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}\n * to create the compressed geometry directly.\n *\n * ### Compression Techniques Used\n *\n * * Simplifies geometry by combining duplicate positions and adjusting indices\n * * Generates edge indices for triangle meshes\n * * Ignores normals (our shaders auto-generate them)\n * * Converts positions to relative-to-center (RTC) coordinates\n * * Quantizes positions and UVs as 16-bit unsigned integers\n * * Splits geometry into {@link @xeokit/scene!GeometryBucketParams | buckets } to enable indices to use the minimum bits for storage\n *\n * ### Aknowledgements\n *\n * * The bucketing technique mentioned above was developed for xeokit by Toni Marti, with support from Tribia AG. Read [the slides](media://pdfs/GPU_RAM_Savings_Toni_Marti_Apr22.pdf) from Toni's presentation at WebGL Meetup 2022.\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/compression\n * ````\n *\n * ## Usage\n *\n * In the example below, we'll use {@link compressGeometryParams} to compress\n * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a\n * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.\n *\n * In this example, our geometry is very simple, and our GeometryCompressedParams only gets a single\n * {@link @xeokit/scene!GeometryBucketParams | GeometryBucketParams }. Note that if the\n * {@link @xeokit/scene!GeometryParams.positions | GeometryParams.positions} array was large enough to require\n * some of the indices to use more than 16 bits for storage, then that's when the function's bucketing mechanism would\n * kick in, to split the geometry into smaller buckets, each with smaller indices that index a subset of the positions.\n *\n * ````javascript\n * import {compressGeometryParams} from \"@xeokit/compression\";\n * import {TrianglesPrimitive} from \"@xeokit/constants\";\n *\n * const geometryCompressedParams = compressGeometryParams({\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      positions: [\n *          202, 202, 202, 200, 202, 202,\n *          200, 200, 202, 202, 200, 202,\n *          202, 202, 202, 202, 200, 202,\n *          202, 200, 200, 202, 202, 200,\n *          202, 202, 202, 202, 202, 200,\n *          200, 202, 200, 200, 202, 202,\n *          200, 202, 202, 200, 202, 200,\n *          200, 200, 200, 200, 200, 202,\n *          200, 200, 200, 202, 200, 200,\n *          202, 200, 202, 200, 200, 202,\n *          202, 200, 200, 200, 200, 200,\n *          200, 202, 200, 202, 202, 200\n *      ],\n *      indices: [\n *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4,\n *          6, 7, 8, 9, 10, 8, 10, 11, 12,\n *          13, 14, 12, 14, 15, 16, 17, 18,\n *          16, 18, 19, 20, 21, 22, 20, 22, 23\n *      ]\n *  });\n * ````\n *\n * The value of our new {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams} is shown below.\n *\n * We can see that:\n *\n * * We get one bucket, because we have only a small number of indices\n * * Vertex positions are now relative to ````origin```` and quantized to 16-bit integers\n * * Duplicate positions are removed and indices adjusted\n * * Edge indices generated for our TrianglesPrimitive\n * * A ````positionsDecompressMatrix```` to de-quantize the positions within the Viewer\n *\n * ````javascript\n * {\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      origin: [200,200,200],\n *      positionsDecompressMatrix: [\n *          0.00003052270125906143, 0, 0, 0,\n *          0, 0.00003052270125906143, 0, 0,\n *          0, 0, 0.00003052270125906143, 0,\n *          -1, -1, -1, 1\n *      ],\n *      geometryBuckets: [\n *          {\n *              positionsCompressed: [\n *                  65525, 65525, 65525, 0, 65525, 65525,\n *                  0, 0, 65525, 65525, 0, 65525, 65525,\n *                  0, 0, 65525, 65525, 0, 0, 65525, 0, 0,\n *                  0, 0\n *              ],\n *              indices: [\n *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,\n *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,\n *                  4, 7, 6, 4, 6, 5\n *              ],\n *              edgeIndices: [\n *                  3, 4, 0, 4, 5, 0, 5, 6,\n *                  0, 6, 1, 1, 6, 7, 1, 7,\n *                  3, 2, 4, 7, 6, 4, 6\n *              ]\n *          }\n *      ]\n * }\n * ````\n *\n * In the next example, we'll again use {@link compressGeometryParams} to compress\n * a {@link @xeokit/scene!GeometryParams | GeometryParams} into a\n * {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}, which we'll then use to\n * create a compressed geometry within a {@link @xeokit/scene!SceneModel | SceneModel}.\n *\n * ````javascript\n * import {Scene} from \"@xeokit/scene\";\n * import {TrianglesPrimitive} from \"@xeokit/constants\";\n * import {compressGeometryParams} from \"@xeokit/compression\";\n *\n * const scene = new Scene();\n *\n * const sceneModel = scene.createModel({\n *     id: \"myModel\"\n * });\n *\n * const geometryCompressedParams = compressGeometryParams({\n *      id: \"myBoxGeometry\",\n *      primitive: TrianglesPrimitive,\n *      positions: [202, 202, 202, 200, 202, 202, ...],\n *      indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, ...]\n * });\n *\n * sceneModel.createGeometryCompressed(geometryCompressedParams);\n *\n * sceneModel.createMesh({ id: \"myMesh\", geometryId: \"myGeometry\" });\n *\n * sceneModel.createObject({ id: \"myObject1\", meshIds: [\"myMesh\"] });\n * sceneModel.createObject({ id: \"myObject2\", meshIds: [\"myMesh\"] });\n *\n * sceneModel.build();\n * ````\n *\n * @module @xeokit/compression\n */\n\nimport {\n    createMat3,\n    createMat4,\n    createVec3,\n    identityMat3,\n    identityMat4,\n    mulMat3,\n    mulMat4,\n    normalizeVec3,\n    scalingMat3v,\n    scalingMat4v,\n    transformVec3,\n    translationMat3v,\n    translationMat4v\n} from \"@xeokit/matrix\";\n\nimport type {FloatArrayParam} from \"@xeokit/math\";\n\nconst translate = createMat4();\nconst scale = createMat4();\n\n/**\n * Gets the boundary of a flat positions array.\n *\n * @param array\n * @param min\n * @param max\n */\nexport function getPositions3MinMax(array: FloatArrayParam, min?: FloatArrayParam, max?: FloatArrayParam) {\n    let i, j;\n    min = min || new Float64Array(3);\n    max = max || new Float64Array(3);\n    for (i = 0; i < 3; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 3) {\n        for (j = 0; j < 3; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min,\n        max\n    };\n}\n\n/**\n * Creates a de-quantization matrix from a boundary.\n */\nexport function createPositions3DecompressMat4(aabb: FloatArrayParam, positionsDecompressMatrix: FloatArrayParam): FloatArrayParam {\n    positionsDecompressMatrix = positionsDecompressMatrix || createMat4();\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    identityMat4(translate);\n    translationMat4v(aabb, translate);\n    identityMat4(scale);\n    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n    mulMat4(translate, scale, positionsDecompressMatrix);\n    return positionsDecompressMatrix;\n}\n\n/**\n * Compresses a flat positions array\n */\nexport function compressPositions3(array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam) {\n    const quantized = new Uint16Array(array.length);\n    var multiplier = new Float32Array([\n        max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,\n        max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,\n        max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0\n    ]);\n    let i;\n    for (i = 0; i < array.length; i += 3) {\n        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n    }\n    identityMat4(translate);\n    translationMat4v(min, translate);\n    identityMat4(scale);\n    scalingMat4v([\n        (max[0] - min[0]) / 65535,\n        (max[1] - min[1]) / 65535,\n        (max[2] - min[2]) / 65535\n    ], scale);\n    const decompressMatrix = mulMat4(translate, scale, identityMat4());\n    return {\n        quantized: quantized,\n        decompressMatrix: decompressMatrix\n    };\n}\n\n/**\n * Compresses a 3D position\n * @param p\n * @param aabb\n * @param q\n */\nexport function compressPoint3(p: FloatArrayParam, aabb: FloatArrayParam, dest: FloatArrayParam = p) {\n    const multiplier = new Float32Array([\n        aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0,\n        aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0,\n        aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0\n    ]);\n    dest[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));\n    dest[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));\n    dest[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));\n    return dest;\n}\n\n/**\n * Decompresses a 3D position\n * @param position\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressPoint3(position: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: FloatArrayParam = position): FloatArrayParam {\n    dest[0] = position[0] * decompressMatrix[0] + decompressMatrix[12];\n    dest[1] = position[1] * decompressMatrix[5] + decompressMatrix[13];\n    dest[2] = position[2] * decompressMatrix[10] + decompressMatrix[14];\n    return dest;\n}\n\n/**\n * Decompresses an axis-aligned 3D boundary\n * @param aabb\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressAABB3(aabb: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: FloatArrayParam = aabb): FloatArrayParam {\n    dest[0] = aabb[0] * decompressMatrix[0] + decompressMatrix[12];\n    dest[1] = aabb[1] * decompressMatrix[5] + decompressMatrix[13];\n    dest[2] = aabb[2] * decompressMatrix[10] + decompressMatrix[14];\n    dest[3] = aabb[3] * decompressMatrix[0] + decompressMatrix[12];\n    dest[4] = aabb[4] * decompressMatrix[5] + decompressMatrix[13];\n    dest[5] = aabb[5] * decompressMatrix[10] + decompressMatrix[14];\n    return dest;\n}\n\n/**\n * Decompresses a flat array of positions\n * @param positions\n * @param decompressMatrix\n * @param dest\n */\nexport function decompressPositions3(positions: FloatArrayParam, decompressMatrix: FloatArrayParam, dest: Float32Array = new Float32Array(positions.length)): Float32Array {\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        dest[i + 0] = positions[i + 0] * decompressMatrix[0] + decompressMatrix[12];\n        dest[i + 1] = positions[i + 1] * decompressMatrix[5] + decompressMatrix[13];\n        dest[i + 2] = positions[i + 2] * decompressMatrix[10] + decompressMatrix[14];\n    }\n    return dest;\n}\n\n/**\n * Gets the 2D min/max boundary of a flat array of UV coordinate\n * @param array\n */\nexport function getUVBounds(array: FloatArrayParam): { min: FloatArrayParam, max: FloatArrayParam } {\n    const min = new Float32Array(2);\n    const max = new Float32Array(2);\n    let i, j;\n    for (i = 0; i < 2; i++) {\n        min[i] = Number.MAX_VALUE;\n        max[i] = -Number.MAX_VALUE;\n    }\n    for (i = 0; i < array.length; i += 2) {\n        for (j = 0; j < 2; j++) {\n            min[j] = Math.min(min[j], array[i + j]);\n            max[j] = Math.max(max[j], array[i + j]);\n        }\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\n\n/**\n * Compresses a flat array of UV coordinates\n */\nexport var compressUVs = (function () {\n    const translate = createMat3();\n    const scale = createMat3();\n    return function (array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam): {\n        quantized: Uint16Array,\n        decompressMatrix: FloatArrayParam | Float64Array\n    } {\n        const quantized = new Uint16Array(array.length);\n        const multiplier = new Float32Array([\n            65535 / (max[0] - min[0]),\n            65535 / (max[1] - min[1])\n        ]);\n        let i;\n        for (i = 0; i < array.length; i += 2) {\n            quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n            quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n        }\n        identityMat3(translate);\n        translationMat3v(min, translate);\n        identityMat3(scale);\n        scalingMat3v([\n            (max[0] - min[0]) / 65535,\n            (max[1] - min[1]) / 65535\n        ], scale);\n        const decompressMatrix = mulMat3(translate, scale, identityMat3());\n        return {\n            quantized: quantized,\n            decompressMatrix: decompressMatrix\n        };\n    };\n})();\n\n/**\n * Oct-encodes a flat array of normal vectors\n * @param array\n */\nexport function compressNormals(array: FloatArrayParam): Int8Array { // http://jcgt.org/published/0003/02/01/\n\n    // Note: three elements for each encoded normal, in which the last element in each triplet is redundant.\n    // This is to work around a mysterious WebGL issue where 2-element normals just wouldn't work in the shader :/\n\n    const encoded = new Int8Array(array.length);\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < array.length; i += 3) {\n        // Test various combinations of ceil and floor\n        // to minimize rounding errors\n        best = oct = octEncodeNormalFromArray(array, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(array, i, dec);\n        oct = octEncodeNormalFromArray(array, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormalFromArray(array, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormalFromArray(array, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(array, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        encoded[i] = best[0];\n        encoded[i + 1] = best[1];\n    }\n    return encoded;\n}\n\n/**\n */\nfunction octEncodeNormalFromArray(array: FloatArrayParam, i: number, xfunc: any, yfunc: any): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n */\nfunction dot(array: FloatArrayParam, i: number, createVec3: FloatArrayParam): number {\n    return array[i] * createVec3[0] + array[i + 1] * createVec3[1] + array[i + 2] * createVec3[2];\n}\n\n/**\n */\nexport function decompressUV(uv: FloatArrayParam, decompressMatrix: FloatArrayParam, dest = new Float32Array(2)) {\n    dest[0] = uv[0] * decompressMatrix[0] + decompressMatrix[6];\n    dest[1] = uv[1] * decompressMatrix[4] + decompressMatrix[7];\n}\n\n/**\n *\n */\nexport function decompressUVs(uvs: FloatArrayParam, decompressMatrix: FloatArrayParam, dest = new Float32Array(uvs.length)) {\n    for (let i = 0, len = uvs.length; i < len; i += 3) {\n        dest[i + 0] = uvs[i + 0] * decompressMatrix[0] + decompressMatrix[6];\n        dest[i + 1] = uvs[i + 1] * decompressMatrix[4] + decompressMatrix[7];\n    }\n    return dest;\n}\n\n/**\n *\n */\nexport function decompressNormal(oct: FloatArrayParam, result: FloatArrayParam): FloatArrayParam {\n    let x = oct[0];\n    let y = oct[1];\n    x = (2 * x + 1) / 255;\n    y = (2 * y + 1) / 255;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    result[0] = x / length;\n    result[1] = y / length;\n    result[2] = z / length;\n    return result;\n}\n\n/**\n *\n */\nexport function decompressNormals(octs: string | any[], result: FloatArrayParam): FloatArrayParam {\n    for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n        let x = octs[i + 0];\n        let y = octs[i + 1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[j + 0] = x / length;\n        result[j + 1] = y / length;\n        result[j + 2] = z / length;\n        j += 3;\n    }\n    return result;\n}\n\n/**\n *\n * @param oct\n * @param result\n */\nfunction octDecodeVec2(oct: Int8Array, result: FloatArrayParam = createVec3()): FloatArrayParam {\n    let x = oct[0];\n    let y = oct[1];\n    x = (2 * x + 1) / 255;\n    y = (2 * y + 1) / 255;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    result[0] = x / length;\n    result[1] = y / length;\n    result[2] = z / length;\n    return result;\n}\n\n/**\n *\n */\nfunction octDecodeVec2s(octs: Int8Array, result: FloatArrayParam): FloatArrayParam {\n    for (let i = 0, j = 0, len = octs.length; i < len; i += 2) {\n        let x = octs[i + 0];\n        let y = octs[i + 1];\n        x = (2 * x + 1) / 255;\n        y = (2 * y + 1) / 255;\n        const z = 1 - Math.abs(x) - Math.abs(y);\n        if (z < 0) {\n            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        }\n        const length = Math.sqrt(x * x + y * y + z * z);\n        result[j + 0] = x / length;\n        result[j + 1] = y / length;\n        result[j + 2] = z / length;\n        j += 3;\n    }\n    return result;\n}\n\n/**\n * @private\n */\nexport function quantizePositions3(positions: FloatArrayParam, aabb: FloatArrayParam, positionsDecompressMatrix: FloatArrayParam) { // http://cg.postech.ac.kr/research/mesh_comp_mobile/mesh_comp_mobile_conference.pdf\n    const lenPositions = positions.length;\n    const positionsCompressed = new Uint16Array(lenPositions);\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65525;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    const verify = (num: number) => num >= 0 ? num : 0;\n    for (let i = 0; i < lenPositions; i += 3) {\n        positionsCompressed[i + 0] = Math.floor(verify(positions[i + 0] - xmin) * xMultiplier);\n        positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);\n        positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);\n    }\n    identityMat4(translate);\n    translationMat4v(aabb, translate);\n    identityMat4(scale);\n    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n    mulMat4(translate, scale, positionsDecompressMatrix);\n    return positionsCompressed;\n}\n\n/**\n * @private\n */\nexport function transformAndOctEncodeNormals(worldNormalMatrix: FloatArrayParam, normals: FloatArrayParam, lenNormals: number, compressedNormals: FloatArrayParam, lenCompressedNormals: number) {\n\n    function dot(p: FloatArrayParam, createVec3: FloatArrayParam) { // Dot product of a normal in an array against a candidate decoding\n        return p[0] * createVec3[0] + p[1] * createVec3[1] + p[2] * createVec3[2];\n    }\n\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = new Float32Array([0, 0, 0, 0]);\n    let worldNormal = new Float32Array([0, 0, 0, 0]);\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        transformVec3(worldNormalMatrix, localNormal, worldNormal);\n        normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, dec);\n        oct = octEncodeVec3(worldNormal, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nexport function octEncodeNormals(normals: FloatArrayParam) { // http://jcgt.org/published/0003/02/01/\n    const lenNormals = normals.length;\n    const compressedNormals = new Int8Array(lenNormals)\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeNormal(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeNormal(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormal(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeNormal(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[i + 0] = best[0];\n        compressedNormals[i + 1] = best[1];\n        compressedNormals[i + 2] = 0.0; // Unused\n    }\n    return compressedNormals;\n}\n\n/**\n * @private\n */\nexport function octEncodeVec3(p: FloatArrayParam, xfunc: string, yfunc: string): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = p[0] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));\n    let y = p[1] / (Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]));\n    if (p[2] < 0) {\n        let tempx = x;\n        let tempy = y;\n        tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n/**\n * @private\n */\nexport function octEncodeNormal(array: FloatArrayParam, i: number, xfunc: string, yfunc: string): Int8Array { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    // @ts-ignore\n    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);\n}\n\n\n","import {\n    createPrimsKdTree3,\n    KdLinePrim,\n    KdPointPrim,\n    KdTrianglePrim,\n    SceneObjectsKdTree3,\n    searchKdTree3WithFrustum,\n    searchKdTree3WithRay\n} from \"@xeokit/kdtree3\";\nimport {FloatArrayParam} from \"@xeokit/math\";\nimport {RayPickResult} from \"./RayPickResult\";\nimport {MarqueePickResult} from \"./MarqueePickResult\";\nimport {PickPrimsCache} from \"./PickPrimsCache\";\nimport {decompressPositions3} from \"@xeokit/compression\";\nimport {LinesPrimitive, PointsPrimitive, TrianglesPrimitive} from \"@xeokit/constants\";\nimport {Geometry, GeometryBucket, SceneObject} from \"@xeokit/scene\";\nimport {MeshHit} from \"./MeshHit\";\nimport {GeometryBucketHit} from \"./GeometryBucketHit\";\nimport {Frustum3} from \"@xeokit/boundaries\";\n\n/**\n * See {@link \"@xeokit/collision/pick\"} for usage.\n */\nexport class Picker {\n\n    #pickPrimsCache: PickPrimsCache;\n\n    constructor() {\n        this.#pickPrimsCache = new PickPrimsCache();\n    }\n\n    /**\n     * TODO\n     * @param params\n     */\n    rayPick(params: {\n        sceneObjectsKdTree3: SceneObjectsKdTree3,\n        origin: FloatArrayParam,\n        dir: FloatArrayParam\n    }): RayPickResult {\n\n        //\n        // Cache for different Scene's?\n        //\n\n        const sceneObjectsKdTree3 = params.sceneObjectsKdTree3;\n        const origin = params.origin;\n        const dir = params.dir;\n        const rayPickResult = <RayPickResult>{\n            sceneObjectHits: []\n        };\n        // const kdItems = searchKdTree3WithRay({kdTree: sceneObjectsKdTree3, origin, dir});\n        // for (let i = 0, len = kdItems.length; i < len; i++) {\n        //     const item = kdItems[i];\n        //     const sceneObject: SceneObject = item.sceneObject;\n        //     const meshHits: MeshHit[] = [];\n        //     for (let j = 0, lenj = sceneObject.meshes.length; j < lenj; j++) {\n        //         const mesh = sceneObject.meshes[j];\n        //         const geometryBucketHits: GeometryBucketHit[] = [];\n        //         //////////////////////\n        //         // Transform ray into mesh local space, by inverse of mesh matrix\n        //         ///////////////////////\n        //         const geometry = mesh.geometry;\n        //         for (let k = 0, lenk = geometry.geometryBuckets.length; k < lenk; k++) {\n        //             const primHits: any[] = [];\n        //             const geometryBucket = geometry.geometryBuckets[k];\n        //             let primsKdTree3 = this.#getPrimsKdTree3(geometry, k, geometryBucket);\n        //             const primitives = searchKdTree3WithRay({kdTree: primsKdTree3.primsKdTree3, origin, dir});\n        //             if (primitives.length) {\n        //                 switch (geometry.primitive) {\n        //                     case TrianglesPrimitive:\n        //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {\n        //                             // const triangle = <KdTrianglePrim>primitives[l];\n        //                             // const a = triangle.a;\n        //                             // const b = triangle.b;\n        //                             // const c = triangle.c;\n        //                             // const cx = primsKdTree3.positions[a * 3];\n        //                             // const cy = primsKdTree3.positions[a * 3 + 1];\n        //                             // const cz = primsKdTree3.positions[a * 3 + 2];\n        //\n        //                             //////////////////////////\n        //                             // Get ray-triangle intersection in worldPos\n        //                             /////////////////////////////\n        //\n        //                             //     primHits.push({primitive: triangle, worldPos});\n        //                         }\n        //                         break;\n        //                     case LinesPrimitive:\n        //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {\n        //                           //  const line = <KdLinePrim>primitives[l];\n        //                             //     primHits.push({primitive: line, worldPos});\n        //                         }\n        //                         break;\n        //                     case PointsPrimitive:\n        //                         for (let l = 0, lenl = primitives.length; l < lenl; l++) {\n        //                         //    const point = <KdPointPrim>primitives[l];\n        //                             //      primHits.push({primitive: point, worldPos});\n        //                         }\n        //                         break;\n        //                 }\n        //             }\n        //             if (primHits.length > 0) {\n        //                 geometryBucketHits.push({geometryBucket, primHits});\n        //             }\n        //         }\n        //         if (geometryBucketHits.length > 0) {\n        //             meshHits.push({mesh, geometry, geometryBucketHits})\n        //         }\n        //     }\n        //     if (meshHits.length) {\n        //         rayPickResult.sceneObjectHits.push({sceneObject, meshHits});\n        //     }\n        // }\n        return rayPickResult;\n    }\n\n    /**\n     * Picks a {@link SceneObjectsKdTree3} using a 2D marquee to obtain a {@link MarqueePickResult}\n     * containing picked {@link SceneObject | SceneObjects}, {@link Mesh}, {@link Geometry},\n     * {@link GeometryBucket | GeometryBuckets}, {@link KdTrianglePrim}, {@link KdLinePrim} and {@link KdPointPrim}.\n     * @param params\n     */\n    marqueePick(params: {\n        sceneObjectsKdTree3: SceneObjectsKdTree3,\n        marquee: FloatArrayParam\n    }): MarqueePickResult {\n        const sceneObjectsKdTree3 = params.sceneObjectsKdTree3;\n        const pickPrimsCache = this.#pickPrimsCache;\n        const marqueePickResult = <MarqueePickResult>{\n            sceneObjects: []\n        };\n        const frustum: Frustum3 = null; // Create from marquee\n        const kdItems = searchKdTree3WithFrustum({\n            kdTree: sceneObjectsKdTree3,\n            frustum\n        });\n        for (let i = 0, len = kdItems.length; i < len; i++) {\n            const kdItem = kdItems[i];\n            const sceneObject = kdItem.item;\n            const meshes = [];\n            for (let j = 0, lenj = sceneObject.meshes.length; j < lenj; j++) {\n                const mesh = sceneObject.meshes[j];\n                const pickedGeometryMeshes = [];\n                //////////////////////\n                // Transform frustum into mesh local space, by inverse of mesh matrix\n                ///////////////////////\n                const geometry = mesh.geometry;\n                for (let k = 0, lenk = geometry.geometryBuckets.length; k < lenk; k++) {\n                    const prims = [];\n                    const geometryBucket = geometry.geometryBuckets[k];\n                    let primsKdTree3 = this.#getPrimsKdTree3(geometry, k, geometryBucket);\n                    const items = searchKdTree3WithFrustum({\n                        kdTree: primsKdTree3.primitivesKdTree,\n                        frustum\n                    });\n                    if (items.length) {\n                        switch (geometry.primitive) {\n                            case TrianglesPrimitive:\n                                for (let l = 0, lenl = items.length; l < lenl; l++) {\n                                    const item = items[l];\n                                    const triangle = <KdTrianglePrim>item.item.prim;\n                                    const a = triangle.a;\n                                    const b = triangle.b;\n                                    const c = triangle.c;\n                                    const cx = primsKdTree3.positions[a * 3];\n                                    const cy = primsKdTree3.positions[a * 3 + 1];\n                                    const cz = primsKdTree3.positions[a * 3 + 2];\n                                    //////////////////////////\n                                    // Get FRUSTUM-TRIANGLE-CENTER intersection in worldPos\n                                    /////////////////////////////\n                                    // prims.push({primitive: triangle, worldPos});\n                                }\n                                break;\n                            case LinesPrimitive:\n                                for (let l = 0, lenl = items.length; l < lenl; l++) {\n                                    const item = items[l];\n                                    const line = <KdLinePrim>item.item.prim;\n                                    // prims.push({primitive: line, worldPos});\n                                }\n                                break;\n                            case PointsPrimitive:\n                                for (let l = 0, lenl = items.length; l < lenl; l++) {\n                                    const item = items[l];\n                                    const point = <KdPointPrim>item.item.prim;\n\n                                    //      prims.push({primitive: point, worldPos});\n                                }\n                                break;\n                        }\n                    }\n                }\n            }\n            /////////////////////////////////////////////////////////////////////////\n            const selected = false;\n\n            if (selected) {\n                marqueePickResult.sceneObjects.push(sceneObject);\n            }\n        }\n        return marqueePickResult;\n    }\n\n    #getPrimsKdTree3(geometry: Geometry, k: number, geometryBucket: GeometryBucket): any {\n        const kdTreeId = `${geometry.id}-${k}`;\n        let primsKdTree3 = this.#pickPrimsCache[kdTreeId];\n        if (!primsKdTree3) {\n            const positions = decompressPositions3(\n                geometryBucket.positionsCompressed,\n                geometry.positionsDecompressMatrix,\n                new Float32Array(geometryBucket.positionsCompressed.length));\n            primsKdTree3 = {\n                primsKdTree3: createPrimsKdTree3(geometry.primitive, positions, geometryBucket.indices),\n                positions\n            }\n            this.#pickPrimsCache[kdTreeId] = primsKdTree3;\n        }\n        return primsKdTree3;\n    }\n}"],"names":["PickPrimsCache","constructor","primitivesKdTrees","clear","s","a","v","n","t","h","FloatArrayClass","M","Float64Array","F","r","N","O","P","Q","Math","sqrt","T","en","cn","vn","qn","Xn","pn","u","o","i","e","c","f","l","d","q","X","Y","Z","b","g","Dn","En","Gn","Hn","Un","set","nt","Qn","Rn","createMat4","decompressPositions3","positions","decompressMatrix","dest","Float32Array","length","len","translate","createMat3","scale","array","min","max","quantized","Uint16Array","multiplier","floor","identityMat3","translationMat3v","scalingMat3v","mulMat3","_pickPrimsCache","_classPrivateFieldLooseKey","_getPrimsKdTree","Picker","Object","defineProperty","value","_getPrimsKdTree2","writable","_classPrivateFieldLooseBase","rayPick","params","rayPickResult","sceneObjectHits","marqueePick","sceneObjectsKdTree3","marqueePickResult","sceneObjects","frustum","kdItems","searchKdTree3WithFrustum","kdTree","kdItem","sceneObject","item","j","lenj","meshes","mesh","geometry","k","lenk","geometryBuckets","geometryBucket","primsKdTree3","primitivesKdTree","kdTreeId","id","positionsCompressed","positionsDecompressMatrix","createPrimsKdTree3","primitive","indices"],"mappings":"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"}