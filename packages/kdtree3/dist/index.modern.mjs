import{expandAABB3 as t,containsAABB3 as e,collapseAABB3 as n,expandAABB3Points3 as i,createAABB3Int16 as r,OUTSIDE as a,intersectAABB3s as o,INTERSECT as s,intersectFrustum3AABB3 as c}from"@xeokit/boundaries";import{getSceneObjectGeometry as h}from"@xeokit/scene";import{LinesPrimitive as f,TrianglesPrimitive as m,PointsPrimitive as l}from"@xeokit/constants";var u=0;function b(t){return"__private_"+u+++"_"+t}function g(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}const d=new Float32Array(3);var p=/*#__PURE__*/b("root"),x=/*#__PURE__*/b("maxDepth"),M=/*#__PURE__*/b("numNodes"),v=/*#__PURE__*/b("numObjects"),y=/*#__PURE__*/b("insertItem");class w{constructor(t){Object.defineProperty(this,y,{value:k}),Object.defineProperty(this,p,{writable:!0,value:void 0}),Object.defineProperty(this,x,{writable:!0,value:void 0}),Object.defineProperty(this,M,{writable:!0,value:void 0}),Object.defineProperty(this,v,{writable:!0,value:void 0}),g(this,x)[x]=(null==t?void 0:t.maxDepth)||10,g(this,p)[p]={index:0,aabb:t.aabb.slice()},g(this,M)[M]=0}get root(){return g(this,p)[p]}insertItem(t,e){g(this,y)[y](g(this,p)[p],{index:g(this,v)[v]++,item:t},e,1)}}function k(n,i,r,a){if(a>=g(this,x)[x])return n.items=n.items||[],n.items.push(i),void t(n.aabb,r);if(n.left&&e(n.left.aabb,r))return void g(this,y)[y](n.left,i,r,a+1);if(n.right&&e(n.right.aabb,r))return void g(this,y)[y](n.right,i,r,a+1);const o=n.aabb;d[0]=o[3]-o[0],d[1]=o[4]-o[1],d[2]=o[5]-o[2];let s=0;if(d[1]>d[s]&&(s=1),d[2]>d[s]&&(s=2),!n.left){const t=o.slice();if(t[s+3]=(o[s]+o[s+3])/2,n.left={index:g(this,M)[M]++,aabb:t},e(t,r))return void g(this,y)[y](n.left,i,r,a+1)}if(!n.right){const t=o.slice();if(t[s]=(o[s]+o[s+3])/2,n.right={index:g(this,M)[M]++,aabb:t},e(t,r))return void g(this,y)[y](n.right,i,r,a+1)}n.items=n.items||[],n.items.push(i),t(n.aabb,r)}class I extends w{}function O(e){const i=n();for(let n=0,r=e.length;n<r;n++)t(i,e[n].aabb);const r=new I({aabb:i});for(let t=0,n=e.length;t<n;t++){const n=e[t];r.insertItem(n,n.aabb)}return r}class j extends w{}function P(e){const i=new Int16Array(6);function r(t,e,n,r,a){const o=n[3*r+1],s=n[3*r+2],c=i;c[0]=c[3]=n[3*r],c[1]=c[4]=o,c[2]=c[5]=s,a.insertItem({sceneObject:t,geometryBucket:e,prim:{a:r}},c)}function a(t,e,n,r,a,o){const s=n[3*r],c=n[3*r+1],h=n[3*r+2],f=n[3*a],m=n[3*a+1],l=n[3*a+2],u=i;u[0]=Math.min(s,f),u[1]=Math.min(c,m),u[2]=Math.min(h,l),u[3]=Math.max(s,f),u[4]=Math.max(c,m),u[5]=Math.max(h,l),o.insertItem({sceneObject:t,geometryBucket:e,prim:{a:r,b:a}},u)}function o(t,e,n,r,a,o,s){const c=n[3*r],h=n[3*r+1],f=n[3*r+2],m=n[3*a],l=n[3*a+1],u=n[3*a+2],b=n[3*o],g=n[3*o+1],d=n[3*o+2],p=i;p[0]=Math.min(c,m,b),p[1]=Math.min(h,l,g),p[2]=Math.min(f,u,d),p[3]=Math.max(c,m,b),p[4]=Math.max(h,l,g),p[5]=Math.max(f,u,d),s.insertItem({sceneObject:t,geometryBucket:e,prim:{a:r,b:a,c:o}},p)}const s=n();for(let n=0,i=e.length;n<i;n++)t(s,e[n].aabb);const c=new j({aabb:s});for(let t=0,n=e.length;t<n;t++){const n=e[t];h(n,t=>{const e=t.geometryBucket,i=t.positionsWorld,s=e.indices;switch(t.geometry.primitive){case l:for(let t=0,a=i.length/3;t<a;t++)r(n,e,i,t,c);break;case m:if(s)for(let t=0,r=s.length;t<r;t+=3)o(n,e,i,s[t],s[t+1],s[t+2],c);break;case f:if(s)for(let t=0,r=s.length;t<r;t+=2)a(n,e,i,s[t],s[t+1],c)}return!0})}return c}class B extends w{}const T=new Int16Array(6);function _(t,e,n){const a=new B({aabb:i(r(),e)});switch(t){case l:for(let t=0,n=e.length/3;t<n;t++)A(e,t,a);break;case m:if(n)for(let t=0,i=n.length;t<i;t+=3)E(e,n[t],n[t+1],n[t+2],a);break;case f:if(n)for(let t=0,i=n.length;t<i;t+=2)D(e,n[t],n[t+1],a)}return a}function A(t,e,n){const i=t[3*e+1],r=t[3*e+2],a=T;a[0]=a[3]=t[3*e],a[1]=a[4]=i,a[2]=a[5]=r,n.insertItem({a:e},a)}function D(t,e,n,i){const r=t[3*e],a=t[3*e+1],o=t[3*e+2],s=t[3*n],c=t[3*n+1],h=t[3*n+2],f=T;f[0]=Math.min(r,s),f[1]=Math.min(a,c),f[2]=Math.min(o,h),f[3]=Math.max(r,s),f[4]=Math.max(a,c),f[5]=Math.max(o,h),i.insertItem({a:e,b:n},f)}function E(t,e,n,i,r){const a=t[3*e],o=t[3*e+1],s=t[3*e+2],c=t[3*n],h=t[3*n+1],f=t[3*n+2],m=t[3*i],l=t[3*i+1],u=t[3*i+2],b=T;b[0]=Math.min(a,c,m),b[1]=Math.min(o,h,l),b[2]=Math.min(s,f,u),b[3]=Math.max(a,c,m),b[4]=Math.max(o,h,l),b[5]=Math.max(s,f,u),r.insertItem({a:e,b:n,c:i},b)}function F(t){const e=t.aabb,n=[];return function t(i,r){if(r===a)return;if((r=o(e,i.aabb))===a)return;const s=i.items;if(s&&s.length>0)for(let t=0,e=s.length;t<e;t++)n.push(s[t].item);i.left&&t(i.left,r),i.right&&t(i.right,r)}(t.kdTree.root,s),n}function N(t){const e=t.frustum,n=[];return function t(i,r){if(r===a)return;if((r=c(e,i.aabb))===a)return;const o=i.items;if(o&&o.length>0)for(let t=0,e=o.length;t<e;t++)n.push(o[t].item);i.left&&t(i.left,r),i.right&&t(i.right,r)}(t.kdTree.root,s),n}function W(t){const e=[];return function t(n,i){if(i===a)return;if((i=0)===a)return;const r=n.items;if(r&&r.length>0)for(let t=0,n=r.length;t<n;t++)e.push(r[t].item);n.left&&t(n.left,i),n.right&&t(n.right,i)}(t.kdTree.root,s),e}export{w as KdTree3,B as PrimsKdTree3,I as SceneObjectsKdTree3,j as SceneObjectsPrimsKdTree3,_ as createPrimsKdTree3,P as createSceneObjectPrimsKdTree3,O as createSceneObjectsKdTree3,F as searchKdTree3WithAABB,N as searchKdTree3WithFrustum,W as searchKdTree3WithRay};
//# sourceMappingURL=index.modern.mjs.map
