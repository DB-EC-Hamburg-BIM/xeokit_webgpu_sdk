{"version":3,"file":"index.es","sources":["../src/index.ts"],"sourcesContent":["/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fsvg)](https://badge.fury.io/js/%40xeokit%2Fmath)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)\n *\n * <img style=\"padding:0px; padding-top:20px; padding-bottom:20px;  height:270px\" src=\"media://images/3D-Cart.svg\"/>\n *\n * # xeokit RTC Coordinate Utilities\n *\n * ---\n *\n * ### *Math functions for working with RTC cartesian coordinates*\n *\n * ---\n *\n * * Math functions for working with relative-to-center (RTC) coordinate systems\n * * Used internally within {@link @xeokit/viewer!Viewer}\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/rtc\n * ````\n *\n * ## Usage\n *\n * ````javascript\n * import * as rtc from \"@xeokit/rtc\";\n *\n * const worldPos = [100000000000.0, 1000000000.0, 1000000000000.0];\n * const rtcCenter = [0,0,0];\n * const rtcPos = [0,0,0];\n *\n * rtc.worldToRTCPos(worldPos, rtcCenter, rtcPos);\n *\n * //..\n * ````\n *\n * @module @xeokit/rtc\n */\nimport type {FloatArrayParam} from \"@xeokit/math\";\nimport {createVec3, dotVec3, mulVec3Scalar, normalizeVec3, setMat4Translation, transformVec4} from \"@xeokit/matrix\";\nimport {getPositions3Center} from \"@xeokit/boundaries\";\n\n\nconst tempVec3a = createVec3();\n\n\nconst tempMat = new Float32Array(16);\nconst rtcCenterWorld = new Float64Array(4);\nconst rtcCenterView = new Float64Array(4);\n\n/**\n * Given a view matrix and a relative-to-center (RTC) coordinate origin, returns a view matrix\n * to transform RTC coordinates to View-space.\n */\nexport function createRTCViewMat(viewMat: FloatArrayParam, rtcCenter: FloatArrayParam, rtcViewMat: FloatArrayParam = tempMat): FloatArrayParam {\n    rtcCenterWorld[0] = rtcCenter[0];\n    rtcCenterWorld[1] = rtcCenter[1];\n    rtcCenterWorld[2] = rtcCenter[2];\n    rtcCenterWorld[3] = 1;\n    transformVec4(viewMat, rtcCenterWorld, rtcCenterView);\n    setMat4Translation(viewMat, rtcCenterView, rtcViewMat);\n    return rtcViewMat;\n}\n\n/**\n * Converts a World-space 3D position to RTC.\n *\n * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center pos\n * and a single-precision offset fom that center.\n *\n * @param worldPos The World-space position.\n * @param rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param rtcPos Single-precision offset fom that center.\n */\nexport function worldToRTCPos(worldPos: FloatArrayParam, rtcCenter: FloatArrayParam, rtcPos: FloatArrayParam) {\n\n    const xHigh = Float32Array.from([worldPos[0]])[0];\n    const xLow = worldPos[0] - xHigh;\n\n    const yHigh = Float32Array.from([worldPos[1]])[0];\n    const yLow = worldPos[1] - yHigh;\n\n    const zHigh = Float32Array.from([worldPos[2]])[0];\n    const zLow = worldPos[2] - zHigh;\n\n    rtcCenter[0] = xHigh;\n    rtcCenter[1] = yHigh;\n    rtcCenter[2] = zHigh;\n\n    rtcPos[0] = xLow;\n    rtcPos[1] = yLow;\n    rtcPos[2] = zLow;\n}\n\n/**\n * Converts a World-space 3D position to RTC.\n *\n * Given a double-precision World-space position, returns a double-precision relative-to-center (RTC) center.\n *\n * @param worldCenter The World-space position.\n * @param rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param [cellSize=200] The size of each coordinate cell within the RTC coordinate system.\n */\nexport function worldToRTCCenter(worldCenter: FloatArrayParam, rtcCenter: FloatArrayParam, cellSize = 200) {\n    rtcCenter[0] = Math.round(worldCenter[0] / cellSize) * cellSize;\n    rtcCenter[1] = Math.round(worldCenter[1] / cellSize) * cellSize;\n    rtcCenter[2] = Math.round(worldCenter[2] / cellSize) * cellSize;\n    return rtcCenter;\n}\n\n/**\n * Converts a flat array of double-precision positions to RTC positions.\n *\n * Returns the RTC positions, along with a computed RTC center for those positions.\n *\n * When computing the RTC position, this function uses a modulus operation to ensure that, whenever possible,\n * identical RTC positions are reused for different positions arrays.\n *\n * @param worldPositions Flat array of World-space 3D positions.\n * @param rtcPositions Outputs the computed flat array of 3D RTC positions.\n * @param rtcCenter Outputs the computed double-precision relative-to-center (RTC) center pos.\n * @param [cellSize=200] The size of each coordinate cell within the RTC coordinate system.\n * @returns ````True```` if the positions actually needed conversion to RTC, else ````false````. When\n * ````false````, we can safely ignore the data returned in ````rtcPositions```` and ````rtcCenter````,\n * since ````rtcCenter```` will equal ````[0,0,0]````, and ````rtcPositions```` will contain identical values to ````positions````.\n */\nexport function worldToRTCPositions(worldPositions: FloatArrayParam, rtcPositions: FloatArrayParam, rtcCenter: FloatArrayParam, cellSize = 200): boolean {\n\n    const center = getPositions3Center(worldPositions, tempVec3a);\n\n    const rtcCenterX = Math.round(center[0] / cellSize) * cellSize;\n    const rtcCenterY = Math.round(center[1] / cellSize) * cellSize;\n    const rtcCenterZ = Math.round(center[2] / cellSize) * cellSize;\n\n    for (let i = 0, len = worldPositions.length; i < len; i += 3) {\n        rtcPositions[i + 0] = worldPositions[i + 0] - rtcCenterX;\n        rtcPositions[i + 1] = worldPositions[i + 1] - rtcCenterY;\n        rtcPositions[i + 2] = worldPositions[i + 2] - rtcCenterZ;\n    }\n\n    rtcCenter[0] = rtcCenterX;\n    rtcCenter[1] = rtcCenterY;\n    rtcCenter[2] = rtcCenterZ;\n\n    const rtcNeeded = (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0);\n\n    return rtcNeeded;\n}\n\n/**\n * Converts an RTC 3D position to World-space.\n *\n * @param rtcCenter Double-precision relative-to-center (RTC) center pos.\n * @param rtcPos Single-precision offset fom that center.\n * @param worldPos The World-space position.\n */\nexport function rtcToWorldPos(rtcCenter: FloatArrayParam, rtcPos: FloatArrayParam, worldPos: FloatArrayParam): FloatArrayParam {\n    worldPos[0] = rtcCenter[0] + rtcPos[0];\n    worldPos[1] = rtcCenter[1] + rtcPos[1];\n    worldPos[2] = rtcCenter[2] + rtcPos[2];\n    return worldPos;\n}\n\n/**\n * Given a 3D plane defined by distance from origin and direction, and an RTC center position,\n * return a plane position that is relative to the RTC center.\n *\n * @param dist\n * @param dir\n * @param rtcCenter\n * @param rtcPlanePos\n * @returns {*}\n */\nexport function getPlaneRTCPos(dist: number, dir: FloatArrayParam, rtcCenter: FloatArrayParam, rtcPlanePos: FloatArrayParam) {\n    const rtcCenterToPlaneDist = dotVec3(dir, rtcCenter) + dist;\n    const dirNormalized = normalizeVec3(dir, tempVec3a);\n    mulVec3Scalar(dirNormalized, -rtcCenterToPlaneDist, rtcPlanePos);\n    return rtcPlanePos;\n}\n"],"names":["tempVec3a","createVec3","tempMat","Float32Array","rtcCenterWorld","Float64Array","rtcCenterView","createRTCViewMat","viewMat","rtcCenter","rtcViewMat","transformVec4","setMat4Translation","worldToRTCPos","worldPos","rtcPos","xHigh","from","xLow","yHigh","yLow","zHigh","zLow","worldToRTCCenter","worldCenter","cellSize","Math","round","worldToRTCPositions","worldPositions","rtcPositions","center","getPositions3Center","rtcCenterX","rtcCenterY","rtcCenterZ","i","len","length","rtcToWorldPos","getPlaneRTCPos","dist","dir","rtcPlanePos","rtcCenterToPlaneDist","dotVec3","dirNormalized","normalizeVec3","mulVec3Scalar"],"mappings":"mMA4CA,IAAMA,EAAYC,IAGZC,EAAU,IAAIC,aAAa,IAC3BC,EAAiB,IAAIC,aAAa,GAClCC,EAAgB,IAAID,aAAa,GAMjC,SAAUE,EAAiBC,EAA0BC,EAA4BC,GAOnF,gBAPmFA,IAAAA,EAA8BR,GACjHE,EAAe,GAAKK,EAAU,GAC9BL,EAAe,GAAKK,EAAU,GAC9BL,EAAe,GAAKK,EAAU,GAC9BL,EAAe,GAAK,EACpBO,EAAcH,EAASJ,EAAgBE,GACvCM,EAAmBJ,EAASF,EAAeI,GACpCA,CACX,CAYgB,SAAAG,EAAcC,EAA2BL,EAA4BM,GAEjF,IAAMC,EAAQb,aAAac,KAAK,CAACH,EAAS,KAAK,GACzCI,EAAOJ,EAAS,GAAKE,EAErBG,EAAQhB,aAAac,KAAK,CAACH,EAAS,KAAK,GACzCM,EAAON,EAAS,GAAKK,EAErBE,EAAQlB,aAAac,KAAK,CAACH,EAAS,KAAK,GACzCQ,EAAOR,EAAS,GAAKO,EAE3BZ,EAAU,GAAKO,EACfP,EAAU,GAAKU,EACfV,EAAU,GAAKY,EAEfN,EAAO,GAAKG,EACZH,EAAO,GAAKK,EACZL,EAAO,GAAKO,CAChB,CAWgB,SAAAC,EAAiBC,EAA8Bf,EAA4BgB,GAIvF,YAJ+F,IAARA,IAAAA,EAAW,KAClGhB,EAAU,GAAKiB,KAAKC,MAAMH,EAAY,GAAKC,GAAYA,EACvDhB,EAAU,GAAKiB,KAAKC,MAAMH,EAAY,GAAKC,GAAYA,EACvDhB,EAAU,GAAKiB,KAAKC,MAAMH,EAAY,GAAKC,GAAYA,EAChDhB,CACX,UAkBgBmB,EAAoBC,EAAiCC,EAA+BrB,EAA4BgB,QAAAA,IAAAA,IAAAA,EAAW,KAQvI,IANA,IAAMM,EAASC,EAAoBH,EAAgB7B,GAE7CiC,EAAaP,KAAKC,MAAMI,EAAO,GAAKN,GAAYA,EAChDS,EAAaR,KAAKC,MAAMI,EAAO,GAAKN,GAAYA,EAChDU,EAAaT,KAAKC,MAAMI,EAAO,GAAKN,GAAYA,EAE7CW,EAAI,EAAGC,EAAMR,EAAeS,OAAQF,EAAIC,EAAKD,GAAK,EACvDN,EAAaM,EAAI,GAAKP,EAAeO,EAAI,GAAKH,EAC9CH,EAAaM,EAAI,GAAKP,EAAeO,EAAI,GAAKF,EAC9CJ,EAAaM,EAAI,GAAKP,EAAeO,EAAI,GAAKD,EASlD,OANA1B,EAAU,GAAKwB,EACfxB,EAAU,GAAKyB,EACfzB,EAAU,GAAK0B,EAEqB,IAAjB1B,EAAU,IAA6B,IAAjBA,EAAU,IAA6B,IAAjBA,EAAU,EAG7E,CASgB,SAAA8B,EAAc9B,EAA4BM,EAAyBD,GAI/E,OAHAA,EAAS,GAAKL,EAAU,GAAKM,EAAO,GACpCD,EAAS,GAAKL,EAAU,GAAKM,EAAO,GACpCD,EAAS,GAAKL,EAAU,GAAKM,EAAO,GAC7BD,CACX,CAYgB,SAAA0B,EAAeC,EAAcC,EAAsBjC,EAA4BkC,GAC3F,IAAMC,EAAuBC,EAAQH,EAAKjC,GAAagC,EACjDK,EAAgBC,EAAcL,EAAK1C,GAEzC,OADAgD,EAAcF,GAAgBF,EAAsBD,GAC7CA,CACX"}