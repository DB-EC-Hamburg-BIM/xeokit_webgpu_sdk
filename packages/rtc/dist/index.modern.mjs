import{createVec3 as r,transformVec4 as t,setMat4Translation as o,dotVec3 as n,normalizeVec3 as a,mulVec3Scalar as u}from"@xeokit/matrix";import{getPositions3Center as e}from"@xeokit/boundaries";const f=r(),i=new Float32Array(16),c=new Float64Array(4),l=new Float64Array(4);function m(r,n,a=i){return c[0]=n[0],c[1]=n[1],c[2]=n[2],c[3]=1,t(r,c,l),o(r,l,a),a}function d(r,t,o){const n=Float32Array.from([r[0]])[0],a=r[0]-n,u=Float32Array.from([r[1]])[0],e=r[1]-u,f=Float32Array.from([r[2]])[0],i=r[2]-f;t[0]=n,t[1]=u,t[2]=f,o[0]=a,o[1]=e,o[2]=i}function h(r,t,o=200){return t[0]=Math.round(r[0]/o)*o,t[1]=Math.round(r[1]/o)*o,t[2]=Math.round(r[2]/o)*o,t}function y(r,t,o,n=200){const a=e(r,f),u=Math.round(a[0]/n)*n,i=Math.round(a[1]/n)*n,c=Math.round(a[2]/n)*n;for(let o=0,n=r.length;o<n;o+=3)t[o+0]=r[o+0]-u,t[o+1]=r[o+1]-i,t[o+2]=r[o+2]-c;return o[0]=u,o[1]=i,o[2]=c,0!==o[0]||0!==o[1]||0!==o[2]}function A(r,t,o){return o[0]=r[0]+t[0],o[1]=r[1]+t[1],o[2]=r[2]+t[2],o}function F(r,t,o,e){const i=n(t,o)+r,c=a(t,f);return u(c,-i,e),e}export{m as createRTCViewMat,F as getPlaneRTCPos,A as rtcToWorldPos,h as worldToRTCCenter,d as worldToRTCPos,y as worldToRTCPositions};
//# sourceMappingURL=index.modern.mjs.map
