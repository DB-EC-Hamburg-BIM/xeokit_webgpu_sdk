import{createVec3 as r,transformVec4 as o,setMat4Translation as t,dotVec3 as n,normalizeVec3 as a,mulVec3Scalar as u}from"@xeokit/matrix";import{getPositions3Center as i}from"@xeokit/boundaries";var e=r(),f=new Float32Array(16),d=new Float64Array(4),m=new Float64Array(4);function h(r,n,a){return void 0===a&&(a=f),d[0]=n[0],d[1]=n[1],d[2]=n[2],d[3]=1,o(r,d,m),t(r,m,a),a}function l(r,o,t){var n=Float32Array.from([r[0]])[0],a=r[0]-n,u=Float32Array.from([r[1]])[0],i=r[1]-u,e=Float32Array.from([r[2]])[0],f=r[2]-e;o[0]=n,o[1]=u,o[2]=e,t[0]=a,t[1]=i,t[2]=f}function v(r,o,t){return void 0===t&&(t=200),o[0]=Math.round(r[0]/t)*t,o[1]=Math.round(r[1]/t)*t,o[2]=Math.round(r[2]/t)*t,o}function c(r,o,t,n){void 0===n&&(n=200);for(var a=i(r,e),u=Math.round(a[0]/n)*n,f=Math.round(a[1]/n)*n,d=Math.round(a[2]/n)*n,m=0,h=r.length;m<h;m+=3)o[m+0]=r[m+0]-u,o[m+1]=r[m+1]-f,o[m+2]=r[m+2]-d;return t[0]=u,t[1]=f,t[2]=d,0!==t[0]||0!==t[1]||0!==t[2]}function y(r,o,t){return t[0]=r[0]+o[0],t[1]=r[1]+o[1],t[2]=r[2]+o[2],t}function A(r,o,t,i){var f=n(o,t)+r,d=a(o,e);return u(d,-f,i),i}export{h as createRTCViewMat,A as getPlaneRTCPos,y as rtcToWorldPos,v as worldToRTCCenter,l as worldToRTCPos,c as worldToRTCPositions};
//# sourceMappingURL=index.es.map
