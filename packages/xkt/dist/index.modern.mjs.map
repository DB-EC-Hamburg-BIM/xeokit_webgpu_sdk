{"version":3,"file":"index.modern.mjs","sources":["../src/inflateXKT.ts","../src/unpackXKT.ts","../../constants/dist/index.es","../src/xktToModel.ts","../src/loadXKT.ts","../src/saveXKT.ts","../src/packXKT.ts","../src/deflateXKT.ts","../src/modelToXKT.ts","../src/XKT_INFO.ts"],"sourcesContent":["import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport type {XKTData} from \"./XKTData\";\nimport * as pako from \"pako\";\n\n/**\n * @private\n */\nexport function inflateXKT(xktDataDeflated: XKTDataDeflated): XKTData {\n\n    function inflate(array:any, options?: any):any {\n        return (array.length === 0) ? [] : (<Uint8Array><unknown>pako.inflate(array, options)).buffer;\n    }\n\n    return <XKTData>{\n        metadata: JSON.parse(pako.inflate(xktDataDeflated.metadata, {to: 'string'})),\n        textureData: new Uint8Array(inflate(xktDataDeflated.textureData)),\n        eachTextureDataPortion: new Uint32Array(inflate(xktDataDeflated.eachTextureDataPortion)),\n        eachTextureAttributes: new Uint16Array(inflate(xktDataDeflated.eachTextureAttributes)),\n        positions: new Uint16Array(inflate(xktDataDeflated.positions)),\n        colors: new Uint8Array(inflate(xktDataDeflated.colors)),\n        uvs: new Float32Array(inflate(xktDataDeflated.uvs)),\n        indices8Bit: new Uint8Array(inflate(xktDataDeflated.indices8Bit)),\n        indices16Bit: new Uint16Array(inflate(xktDataDeflated.indices16Bit)),\n        indices32Bit: new Uint32Array(inflate(xktDataDeflated.indices32Bit)),\n        edgeIndices8Bit: new Uint8Array(inflate(xktDataDeflated.edgeIndices8Bit)),\n        edgeIndices16Bit: new Uint16Array(inflate(xktDataDeflated.edgeIndices16Bit)),\n        edgeIndices32Bit: new Uint32Array(inflate(xktDataDeflated.edgeIndices32Bit)),\n        eachTextureSetTextures: new Int32Array(inflate(xktDataDeflated.eachTextureSetTextures)),\n        decodeMatrices: new Float32Array(inflate(xktDataDeflated.decodeMatrices)),\n        eachBucketPositionsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketPositionsPortion)),\n        eachBucketColorsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketColorsPortion)),\n        eachBucketUVsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketUVsPortion)),\n        eachBucketIndicesPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketIndicesPortion)),\n        eachBucketEdgeIndicesPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketEdgeIndicesPortion)),\n        eachBucketIndicesBitness: new Uint8Array(inflate(xktDataDeflated.eachBucketIndicesBitness)),\n        eachGeometryPrimitiveType: new Uint8Array(inflate(xktDataDeflated.eachGeometryPrimitiveType)),\n        eachGeometryBucketPortion: new Uint32Array(inflate(xktDataDeflated.eachGeometryBucketPortion)),\n        eachGeometryDecodeMatricesPortion: new Uint32Array(inflate(xktDataDeflated.eachGeometryDecodeMatricesPortion)),\n        matrices: new Float32Array(inflate(xktDataDeflated.matrices)), // Can be -1\n        eachMeshGeometriesPortion: new Uint32Array(inflate(xktDataDeflated.eachMeshGeometriesPortion)),\n        eachMeshMatricesPortion: new Uint32Array(inflate(xktDataDeflated.eachMeshMatricesPortion)),\n        eachMeshTextureSet: new Uint32Array(inflate(xktDataDeflated.eachMeshTextureSet)),\n        eachMeshMaterialAttributes: new Uint8Array(inflate(xktDataDeflated.eachMeshMaterialAttributes)),\n        eachObjectId: JSON.parse(pako.inflate(xktDataDeflated.eachObjectId, {to: 'string'})),\n        eachObjectMeshesPortion: new Uint32Array(inflate(xktDataDeflated.eachObjectMeshesPortion)),\n    };\n}","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\n\n/**\n * @private\n */\nexport function unpackXKT(arrayBuffer: ArrayBuffer): XKTDataDeflated {\n\n    const dataView = new DataView(arrayBuffer);\n    const dataArray = new Uint8Array(arrayBuffer);\n    const xktVersion = dataView.getUint32(0, true);\n    const numElements = dataView.getUint32(4, true);\n\n    const elements = [];\n    let byteOffset = (numElements + 2) * 4;\n    for (let i = 0; i < numElements; i++) {\n        const elementSize = dataView.getUint32((i + 2) * 4, true);\n        elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));\n        byteOffset += elementSize;\n    }\n\n    let i = 0;\n\n    return <XKTDataDeflated>{\n        metadata: elements[i++],\n        textureData: elements[i++],\n        eachTextureDataPortion: elements[i++],\n        eachTextureAttributes: elements[i++],\n        positions: elements[i++],\n        colors: elements[i++],\n        uvs: elements[i++],\n        indices8Bit: elements[i++],\n        indices16Bit: elements[i++],\n        indices32Bit: elements[i++],\n        edgeIndices8Bit: elements[i++],\n        edgeIndices16Bit: elements[i++],\n        edgeIndices32Bit: elements[i++],\n        eachTextureSetTextures: elements[i++],\n        decodeMatrices: elements[i++],\n        eachBucketPositionsPortion: elements[i++],\n        eachBucketColorsPortion: elements[i++],\n        eachBucketUVsPortion: elements[i++],\n        eachBucketIndicesPortion: elements[i++],\n        eachBucketEdgeIndicesPortion: elements[i++],\n        eachBucketIndicesBitness: elements[i++],\n        eachGeometryPrimitiveType: elements[i++],\n        eachGeometryBucketPortion: elements[i++],\n        eachGeometryDecodeMatricesPortion: elements[i++],\n        matrices: elements[i++],\n        eachMeshGeometriesPortion: elements[i++],\n        eachMeshMatricesPortion: elements[i++],\n        eachMeshTextureSet: elements[i++],\n        eachMeshMaterialAttributes: elements[i++],\n        eachObjectId: elements[i++],\n        eachObjectMeshesPortion: elements[i++]\n    };\n}\n","var e=1e3,r=1001,a=1002,o=1003,p=1004,t=1004,v=1005,x=1005,b=1006,c=1007,d=1007,f=1008,g=1008,h=1009,i=1010,j=1011,k=1012,l=1013,m=1014,n=1015,q=1016,s=1017,u=1018,w=1020,y=1021,z=1022,A=1023,B=1024,C=1025,D=1026,E=1027,F=1028,G=1029,H=1030,I=1031,J=1033,K=33776,L=33777,M=33778,N=33779,O=35840,P=35841,Q=35842,R=35843,S=36196,T=37492,U=37496,V=37808,W=37809,X=37810,Y=37811,Z=37812,$=37813,_=37814,ee=37815,re=37816,ae=37817,oe=37818,pe=37819,te=37820,ve=37821,xe=36492,be=3e3,ce=3001,de=1e4,fe=10001,ge=10002,he=2e4,ie=20001,je=20002,ke=20003,le=20004,me=3e4,ne=300001,qe=4e5,se=400001,ue=400002,we=400003,ye=400004,ze=400005,Ae=5e5,Be=500001,Ce=500002,De=500003;export{y as AlphaFormat,i as ByteType,se as CentimetersUnit,r as ClampToEdgeWrapping,De as CustomProjectionType,D as DepthFormat,E as DepthStencilFormat,ne as FastRender,ye as FeetUnit,n as FloatType,Ce as FrustumProjectionType,de as GIFMediaType,q as HalfFloatType,ze as InchesUnit,l as IntType,fe as JPEGMediaType,be as LinearEncoding,b as LinearFilter,g as LinearMipMapLinearFilter,d as LinearMipMapNearestFilter,f as LinearMipmapLinearFilter,c as LinearMipmapNearestFilter,ie as LinesPrimitive,C as LuminanceAlphaFormat,B as LuminanceFormat,qe as MetersUnit,ue as MillimetersUnit,a as MirroredRepeatWrapping,o as NearestFilter,x as NearestMipMapLinearFilter,p as NearestMipMapNearestFilter,v as NearestMipmapLinearFilter,t as NearestMipmapNearestFilter,Be as OrthoProjectionType,ge as PNGMediaType,Ae as PerspectiveProjectionType,he as PointsPrimitive,me as QualityRender,A as RGBAFormat,J as RGBAIntegerFormat,pe as RGBA_ASTC_10x10_Format,re as RGBA_ASTC_10x5_Format,ae as RGBA_ASTC_10x6_Format,oe as RGBA_ASTC_10x8_Format,te as RGBA_ASTC_12x10_Format,ve as RGBA_ASTC_12x12_Format,V as RGBA_ASTC_4x4_Format,W as RGBA_ASTC_5x4_Format,X as RGBA_ASTC_5x5_Format,Y as RGBA_ASTC_6x5_Format,Z as RGBA_ASTC_6x6_Format,$ as RGBA_ASTC_8x5_Format,_ as RGBA_ASTC_8x6_Format,ee as RGBA_ASTC_8x8_Format,xe as RGBA_BPTC_Format,U as RGBA_ETC2_EAC_Format,R as RGBA_PVRTC_2BPPV1_Format,Q as RGBA_PVRTC_4BPPV1_Format,L as RGBA_S3TC_DXT1_Format,M as RGBA_S3TC_DXT3_Format,N as RGBA_S3TC_DXT5_Format,z as RGBFormat,S as RGB_ETC1_Format,T as RGB_ETC2_Format,P as RGB_PVRTC_2BPPV1_Format,O as RGB_PVRTC_4BPPV1_Format,K as RGB_S3TC_DXT1_Format,H as RGFormat,I as RGIntegerFormat,F as RedFormat,G as RedIntegerFormat,e as RepeatWrapping,j as ShortType,ke as SolidPrimitive,le as SurfacePrimitive,je as TrianglesPrimitive,h as UnsignedByteType,w as UnsignedInt248Type,m as UnsignedIntType,s as UnsignedShort4444Type,u as UnsignedShort5551Type,k as UnsignedShortType,we as YardsUnit,ce as sRGBEncoding};\n//# sourceMappingURL=index.es.map\n","import {JPEGMediaType, LinesPrimitive, PNGMediaType, PointsPrimitive, TrianglesPrimitive} from \"@xeokit/constants\";\nimport type {DataModel, DataModelParams} from \"@xeokit/data\";\nimport type {GeometryBucketParams, GeometryCompressedParams, SceneModel} from \"@xeokit/scene\";\nimport type {XKTData} from \"./XKTData\";\nimport type {FloatArrayParam} from \"@xeokit/math\";\n\nconst NUM_TEXTURE_ATTRIBUTES = 9;\n\n/**\n * @private\n */\nexport function xktToModel(params: {\n    xktData: XKTData,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): void {\n\n    const xktData = params.xktData;\n    const sceneModel = params.sceneModel;\n    const dataModel = params.dataModel;\n\n    if (dataModel) {\n        if (xktData.metadata) {\n            dataModel.fromJSON(<DataModelParams>xktData.metadata);\n        }\n    }\n\n    const numTextures = xktData.eachTextureDataPortion.length;\n    const numTextureSets = xktData.eachTextureSetTextures.length / 5;\n    const numBuckets = xktData.eachBucketPositionsPortion.length;\n    const numMeshes = xktData.eachMeshGeometriesPortion.length;\n    const numObjects = xktData.eachObjectMeshesPortion.length;\n    const numGeometries = xktData.eachGeometryDecodeMatricesPortion.length;\n\n    let nextMeshId = 0;\n\n    const geometryCreated: {\n        [key: string]: boolean\n    } = {};\n\n    // Create textures\n\n    for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {\n\n        const atLastTexture = (textureIndex === (numTextures - 1));\n        const textureDataPortionStart = xktData.eachTextureDataPortion[textureIndex];\n        const textureDataPortionEnd = atLastTexture ? xktData.textureData.length : (xktData.eachTextureDataPortion[textureIndex + 1]);\n        const textureDataPortionSize = textureDataPortionEnd - textureDataPortionStart;\n        const textureDataPortionExists = (textureDataPortionSize > 0);\n        const textureAttrBaseIdx = (textureIndex * NUM_TEXTURE_ATTRIBUTES);\n\n        const compressed = (xktData.eachTextureAttributes[textureAttrBaseIdx] === 1);\n        const mediaType = xktData.eachTextureAttributes[textureAttrBaseIdx + 1];\n        const width = xktData.eachTextureAttributes[textureAttrBaseIdx + 2];\n        const height = xktData.eachTextureAttributes[textureAttrBaseIdx + 3];\n        const minFilter = xktData.eachTextureAttributes[textureAttrBaseIdx + 4];\n        const magFilter = xktData.eachTextureAttributes[textureAttrBaseIdx + 5]; // LinearFilter | NearestFilter\n        const wrapS = xktData.eachTextureAttributes[textureAttrBaseIdx + 6]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        const wrapT = xktData.eachTextureAttributes[textureAttrBaseIdx + 7]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        const wrapR = xktData.eachTextureAttributes[textureAttrBaseIdx + 8]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n\n        if (textureDataPortionExists) {\n\n            const imageDataSubarray = new Uint8Array(xktData.textureData.subarray(textureDataPortionStart, textureDataPortionEnd));\n            const arrayBuffer = imageDataSubarray.buffer;\n            const textureId = `texture-${textureIndex}`;\n\n            if (compressed) {\n\n                sceneModel.createTexture({\n                    id: textureId,\n                    buffers: [arrayBuffer],\n                    minFilter,\n                    magFilter,\n                    wrapS,\n                    wrapT,\n                    wrapR\n                });\n\n            } else {\n\n                const mimeType = mediaType === JPEGMediaType ? \"image/jpeg\" : (mediaType === PNGMediaType ? \"image/png\" : \"image/gif\");\n                const blob = new Blob([arrayBuffer], {type: mimeType});\n                const urlCreator = window.URL || window.webkitURL;\n                const imageUrl = urlCreator.createObjectURL(blob);\n                const img = document.createElement('img');\n                img.src = imageUrl;\n\n                sceneModel.createTexture({\n                    id: textureId,\n                    image: img,\n                    mediaType,\n                    minFilter,\n                    magFilter,\n                    wrapS,\n                    wrapT,\n                    wrapR\n                });\n            }\n        }\n    }\n\n    // Create texture sets\n\n    for (let textureSetIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {\n\n        const eachTextureSetTexturesIndex = textureSetIndex * 5; // Five textures per set\n        const textureSetId = `textureSet-${textureSetIndex}`;\n        const colorTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex];\n        const metallicRoughnessTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 1];\n        const normalsTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 2];\n        const emissiveTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 3];\n        const occlusionTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 4];\n\n        sceneModel.createTextureSet({\n            id: textureSetId,\n            colorTextureId: colorTextureIndex >= 0 ? `texture-${colorTextureIndex}` : undefined,\n            normalsTextureId: normalsTextureIndex >= 0 ? `texture-${normalsTextureIndex}` : undefined,\n            metallicRoughnessTextureId: metallicRoughnessTextureIndex >= 0 ? `texture-${metallicRoughnessTextureIndex}` : undefined,\n            emissiveTextureId: emissiveTextureIndex >= 0 ? `texture-${emissiveTextureIndex}` : undefined,\n            occlusionTextureId: occlusionTextureIndex >= 0 ? `texture-${occlusionTextureIndex}` : undefined\n        });\n    }\n\n    // Iterate objects\n\n    for (let objectIndex = 0; objectIndex <= numObjects; objectIndex++) {\n\n        const objectId = xktData.eachObjectId[objectIndex];\n        const finalObjectIndex = (numObjects - 1);\n        const atLastObject = (objectIndex === finalObjectIndex);\n        const firstMeshIndex = xktData.eachObjectMeshesPortion [objectIndex];\n        const lastMeshIndex = atLastObject ? (xktData.eachMeshGeometriesPortion.length - 1) : (xktData.eachObjectMeshesPortion[objectIndex + 1] - 1);\n\n        const meshIds = [];\n\n        // Iterate each object's meshes\n\n        for (let meshIndex = firstMeshIndex; meshIndex <= lastMeshIndex; meshIndex++) {\n\n            const geometryIndex = xktData.eachMeshGeometriesPortion[meshIndex];\n            const atLastGeometry = (geometryIndex === (numGeometries - 1));\n            const textureSetIndex = xktData.eachMeshTextureSet[meshIndex];\n            const textureSetId = (textureSetIndex >= 0) ? `textureSet-${textureSetIndex}` : undefined;\n\n            const meshColor = decompressColor(xktData.eachMeshMaterialAttributes.subarray((meshIndex * 6), (meshIndex * 6) + 3));\n            const meshOpacity = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 3] / 255.0;\n            const meshMetallic = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 4] / 255.0;\n            const meshRoughness = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 5] / 255.0;\n\n            const meshId = `mesh-${nextMeshId++}`;\n            const meshMatrixIndex = xktData.eachMeshMatricesPortion[meshIndex];\n            const meshMatrix = xktData.matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);\n\n            const geometryId = `geometry.${geometryIndex}`;\n\n            if (!geometryCreated[geometryId]) {\n\n                const geometryParams = <any>{\n                    geometryBuckets: []\n                };\n\n                geometryParams.primitive = xktData.eachGeometryPrimitiveType[geometryIndex];\n                const geometryDecodeMatrixIndex = xktData.eachGeometryDecodeMatricesPortion[geometryIndex];\n                geometryParams.positionsDecompressMatrix = xktData.eachGeometryDecodeMatricesPortion.slice(geometryDecodeMatrixIndex, geometryDecodeMatrixIndex + 16);\n\n                let geometryValid = false;\n\n                // Iterate each geometry's buckets\n\n                const firstBucketIndex = xktData.eachGeometryBucketPortion[geometryIndex];\n                const atLastBucket = (firstBucketIndex === (numBuckets - 1));\n                const lastBucketIndex = atLastBucket ? (xktData.eachMeshGeometriesPortion.length - 1) : (xktData.eachObjectMeshesPortion[objectIndex + 1] - 1);\n\n                for (let bucketIndex = firstBucketIndex; bucketIndex <= lastBucketIndex; bucketIndex++) {\n\n                    const geometryBucketParams = <GeometryBucketParams>{\n                        positionsCompressed: [],\n                        indices: []\n                    };\n\n                    const geometryIndicesBitness = xktData.eachBucketIndicesBitness[bucketIndex];\n                    const indices = geometryIndicesBitness === 8 ? xktData.indices8Bit : (geometryIndicesBitness === 16 ? xktData.indices16Bit : xktData.indices32Bit);\n                    const edgeIndices = geometryIndicesBitness === 8 ? xktData.edgeIndices8Bit : (geometryIndicesBitness === 16 ? xktData.edgeIndices16Bit : xktData.edgeIndices32Bit);\n\n                    let bucketValid = false;\n\n                    switch (geometryParams.primitive) {\n\n                        case TrianglesPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            //   geometryBucketParams.uvsCompressed = xktData.uvs.subarray(xktData.eachBucketUVsPortion [bucketIndex], atLastBucket ? xktData.uvs.length : xktData.eachBucketUVsPortion [bucketIndex + 1]);\n                            geometryBucketParams.indices = indices.subarray(xktData.eachBucketIndicesPortion [bucketIndex], atLastBucket ? indices.length : xktData.eachBucketIndicesPortion [bucketIndex + 1]);\n                            geometryBucketParams.edgeIndices = edgeIndices.subarray(xktData.eachBucketEdgeIndicesPortion [bucketIndex], atLastBucket ? edgeIndices.length : xktData.eachBucketEdgeIndicesPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0 && geometryBucketParams.indices.length > 0);\n                            break;\n\n                        case PointsPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            // geometryBucketParams.colorsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0);\n                            break;\n\n                        case LinesPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            geometryBucketParams.indices = indices.subarray(xktData.eachBucketIndicesPortion [bucketIndex], atLastBucket ? indices.length : xktData.eachBucketIndicesPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0 && geometryBucketParams.indices.length > 0);\n                            break;\n                        default:\n                            continue;\n                    }\n                    if (bucketValid) {\n                        geometryParams.geometryBuckets.push(geometryBucketParams);\n                    }\n                }\n\n                if (geometryParams.geometryBuckets.length > 0) {\n                    sceneModel.createGeometryCompressed(<GeometryCompressedParams>geometryParams);\n                    geometryCreated[geometryId] = true;\n                }\n            }\n\n            sceneModel.createMesh({\n                id: meshId,\n                geometryId,\n                textureSetId,\n                matrix: meshMatrix,\n                color: meshColor,\n                metallic: meshMetallic,\n                roughness: meshRoughness,\n                opacity: meshOpacity\n            });\n            meshIds.push(meshId);\n        }\n\n        if (meshIds.length > 0) {\n            sceneModel.createObject({\n                id: objectId,\n                meshIds: meshIds\n            });\n        }\n    }\n}\n\nconst decompressColor = (function () {\n    const floatColor = new Float32Array(3);\n    return function (intColor: FloatArrayParam) {\n        floatColor[0] = intColor[0] / 255.0;\n        floatColor[1] = intColor[1] / 255.0;\n        floatColor[2] = intColor[2] / 255.0;\n        return floatColor;\n    };\n})();\n\n","import type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport {inflateXKT} from \"./inflateXKT\";\nimport {unpackXKT} from \"./unpackXKT\";\nimport {xktToModel} from \"./xktToModel\";\nimport {SDKError} from \"@xeokit/core\";\n\n/**\n * Imports XKT file data from an ArrayBuffer into a {@link @xeokit/scene!SceneModel | SceneModel}\n * and/or a {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and\n * {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````\n * * Expects {@link @xeokit/data!DataModel.built | DataModel.built} and\n * {@link @xeokit/data!DataModel.destroyed | DataModel.destroyed} to be ````false````\n *\n * See {@link @xeokit/xkt} for usage.\n *\n * See {@link XKTData} for insights into the structure of an XKT file.\n *\n * @param params - Loading parameters.\n * @param params.data - XKT file data\n * @param params.sceneModel - SceneModel to load into.\n * @param params.dataModel - Optional DataModel to load into.\n * @returns {Promise} Resolves when XKT has been loaded.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been built.\n */\nexport function loadXKT(params: {\n    data: ArrayBuffer,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): Promise<any> {\n    if (params.sceneModel.destroyed) {\n        throw new Error(\"SceneModel already destroyed\");\n    }\n    if (params.sceneModel.built) {\n        throw new SDKError(\"SceneModel already built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new SDKError(\"DataModel already destroyed\");\n        }\n        if (params.dataModel.built) {\n            throw new SDKError(\"DataModel already built\");\n        }\n    }\n    return new Promise<void>(function (resolve, reject) {\n        xktToModel({\n            xktData: inflateXKT(unpackXKT(params.data)),\n            sceneModel: params.sceneModel,\n            dataModel: params.dataModel\n        });\n        resolve();\n    });\n}\n","import type {DataModel} from \"@xeokit/data\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport {deflateXKT} from \"./deflateXKT\";\nimport {modelToXKT} from \"./modelToXKT\";\nimport {packXKT} from \"./packXKT\";\nimport {SDKError} from \"@xeokit/core\";\n\n\n/**\n * Exports a {@link @xeokit/scene!SceneModel | SceneModel} and/or a {@link @xeokit/data!DataModel} to an ArrayBuffer\n * containing XKT file data.\n *\n * See {@link @xeokit/xkt} for usage.\n *\n * See {@link XKTData} for insights into the structure of an XKT file.\n *\n * @param params\n * @param params.sceneModel - The SceneModel to export to XKT.\n * @param params.dataModel - Optional DataModel to export to XKT.\n * @returns The XKT file data in an ArrayBuffer.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has not yet been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has not yet been built.\n */\nexport function saveXKT(params: {\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): ArrayBuffer {\n    if (params.sceneModel.destroyed) {\n        throw new SDKError(\"SceneModel already destroyed\");\n    }\n    if (!params.sceneModel.built) {\n        throw new SDKError(\"SceneModel not yet built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new SDKError(\"DataModel already destroyed\");\n        }\n        if (!params.dataModel.built) {\n            throw new SDKError(\"DataModel not yet built\");\n        }\n    }\n    return packXKT(deflateXKT(modelToXKT({\n        sceneModel: params.sceneModel,\n        dataModel: params.dataModel\n    })));\n}","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport {XKT_INFO} from \"./XKT_INFO\";\n\n/**\n * @private\n */\nexport function packXKT(deflatedData: XKTDataDeflated): ArrayBuffer {\n    return toArrayBuffer(<Buffer[]>[\n        deflatedData.metadata,\n        deflatedData.textureData,\n        deflatedData.eachTextureDataPortion,\n        deflatedData.eachTextureAttributes,\n        deflatedData.positions,\n        deflatedData.colors,\n        deflatedData.uvs,\n        deflatedData.indices8Bit,\n        deflatedData.indices16Bit,\n        deflatedData.indices32Bit,\n        deflatedData.edgeIndices8Bit,\n        deflatedData.edgeIndices16Bit,\n        deflatedData.edgeIndices32Bit,\n        deflatedData.eachTextureSetTextures,\n        deflatedData.decodeMatrices,\n        deflatedData.eachBucketPositionsPortion,\n        deflatedData.eachBucketColorsPortion,\n        deflatedData.eachBucketUVsPortion,\n        deflatedData.eachBucketIndicesPortion,\n        deflatedData.eachBucketEdgeIndicesPortion,\n        deflatedData.eachBucketIndicesBitness,\n        deflatedData.eachGeometryPrimitiveType,\n        deflatedData.eachGeometryBucketPortion,\n        deflatedData.eachGeometryDecodeMatricesPortion,\n        deflatedData.matrices,\n        deflatedData.eachMeshGeometriesPortion,\n        deflatedData.eachMeshMatricesPortion,\n        deflatedData.eachMeshTextureSet,\n        deflatedData.eachMeshMaterialAttributes,\n        deflatedData.eachObjectId,\n        deflatedData.eachObjectMeshesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements: Buffer[]): ArrayBuffer {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = XKT_INFO.xktVersion;\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    let offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    return dataArray.buffer;\n}","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport type {XKTData} from \"./XKTData\";\nimport * as pako from \"pako\";\n\n/**\n * @private\n */\nexport function deflateXKT(xktData: XKTData, metaModelJSON?: any): XKTDataDeflated {\n    let metaModelBytes;\n    if (metaModelJSON) {\n        const deflatedJSON = deflateJSON(metaModelJSON);\n        metaModelBytes = pako.deflate(deflatedJSON)\n    } else {\n        const deflatedJSON = deflateJSON([\"{}\"]);\n        metaModelBytes = pako.deflate(deflatedJSON)\n    }\n    return <XKTDataDeflated>{\n        metadata: metaModelBytes,\n        textureData: pako.deflate(xktData.textureData.buffer),\n        eachTextureDataPortion: pako.deflate(xktData.eachTextureDataPortion.buffer),\n        eachTextureAttributes: pako.deflate(xktData.eachTextureAttributes.buffer),\n        positions: pako.deflate(xktData.positions.buffer),\n        colors: pako.deflate(xktData.colors.buffer),\n        uvs: pako.deflate(xktData.uvs.buffer),\n        indices8Bit: pako.deflate(xktData.indices8Bit.buffer),\n        indices16Bit: pako.deflate(xktData.indices16Bit.buffer),\n        indices32Bit: pako.deflate(xktData.indices32Bit.buffer),\n        edgeIndices8Bit: pako.deflate(xktData.edgeIndices8Bit.buffer),\n        edgeIndices16Bit: pako.deflate(xktData.edgeIndices16Bit.buffer),\n        edgeIndices32Bit: pako.deflate(xktData.edgeIndices32Bit.buffer),\n        eachTextureSetTextures: pako.deflate(xktData.eachTextureSetTextures.buffer),\n        decodeMatrices: pako.deflate(xktData.decodeMatrices.buffer),\n        eachBucketPositionsPortion: pako.deflate(xktData.eachBucketPositionsPortion.buffer),\n        eachBucketColorsPortion: pako.deflate(xktData.eachBucketColorsPortion.buffer),\n        eachBucketUVsPortion: pako.deflate(xktData.eachBucketUVsPortion.buffer),\n        eachBucketIndicesPortion: pako.deflate(xktData.eachBucketIndicesPortion.buffer),\n        eachBucketEdgeIndicesPortion: pako.deflate(xktData.eachBucketEdgeIndicesPortion.buffer),\n        eachBucketIndicesBitness: pako.deflate(xktData.eachBucketIndicesBitness.buffer),\n        eachGeometryPrimitiveType: pako.deflate(xktData.eachGeometryPrimitiveType.buffer),\n        eachGeometryBucketPortion: pako.deflate(xktData.eachGeometryBucketPortion.buffer),\n        eachGeometryDecodeMatricesPortion: pako.deflate(xktData.eachGeometryDecodeMatricesPortion.buffer),\n        matrices: pako.deflate(xktData.matrices.buffer),\n        eachMeshGeometriesPortion: pako.deflate(xktData.eachMeshGeometriesPortion.buffer),\n        eachMeshMatricesPortion: pako.deflate(xktData.eachMeshMatricesPortion.buffer),\n        eachMeshTextureSet: pako.deflate(xktData.eachMeshTextureSet.buffer),\n        eachMeshMaterialAttributes: pako.deflate(xktData.eachMeshMaterialAttributes.buffer),\n        eachObjectId: pako.deflate(JSON.stringify(xktData.eachObjectId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachObjectMeshesPortion: pako.deflate(xktData.eachObjectMeshesPortion.buffer)\n    };\n}\n\nfunction deflateJSON(strings: string[]): string {\n    return JSON.stringify(strings)\n        .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n            return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n        });\n}\n","import {XKT_INFO} from \"./XKT_INFO\";\nimport type {XKTData} from \"./XKTData\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport {ClampToEdgeWrapping, LinearMipmapLinearFilter} from \"@xeokit/constants\";\n\nconst XKT_VERSION = XKT_INFO.xktVersion;\nconst NUM_TEXTURE_ATTRIBUTES = 9;\nconst NUM_MATERIAL_ATTRIBUTES = 6;\n\n/**\n * @private\n */\nexport function modelToXKT(params: {\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): XKTData {\n\n    const sceneModel = params.sceneModel;\n    const dataModel = params.dataModel;\n\n    const geometriesList = Object.values(sceneModel.geometries);\n    const texturesList = Object.values(sceneModel.textures);\n    const textureSetsList = Object.values(sceneModel.textureSets);\n    const meshesList = Object.values(sceneModel.meshes);\n    const objectsList = Object.values(sceneModel.objects);\n\n    const numGeometries = geometriesList.length;\n    const numTextures = texturesList.length;\n    const numTextureSets = textureSetsList.length;\n    const numMeshes = meshesList.length;\n    const numObjects = objectsList.length;\n\n    let lenBuckets = 0;\n    let lenPositions = 0;\n    let lenColors = 0;\n    let lenUVs = 0;\n    let lenIndices8Bit = 0;\n    let lenIndices16Bit = 0;\n    let lenIndices32Bit = 0;\n    let lenEdgeIndices8Bit = 0;\n    let lenEdgeIndices16Bit = 0;\n    let lenEdgeIndices32Bit = 0;\n    let lenMatrices = 0;\n    let lenTextures = 0;\n    let lenDecodeMatrices = 0;\n\n    const geometryIndices: { [key: string]: number } = {};\n    const textureIndices: { [key: string]: number } = {};\n    const textureSetIndices: { [key: string]: number } = {};\n    const meshIndices: { [key: string]: number } = {};\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        const geometryBuckets = geometry.geometryBuckets;\n        lenBuckets += geometryBuckets.length;\n        for (let i = 0, len = geometryBuckets.length; i < len; i++) {\n            const geometryBucket = geometryBuckets[i];\n            if (geometryBucket.positionsCompressed) {\n                const numPositions = geometryBucket.positionsCompressed.length / 3;\n                lenPositions += geometryBucket.positionsCompressed.length;\n                if (geometryBucket.indices) {\n                    if (numPositions <= (1 << 8)) {\n                        lenIndices8Bit += geometryBucket.indices.length;\n                    } else if (numPositions <= (1 << 16)) {\n                        lenIndices16Bit += geometryBucket.indices.length;\n                    } else {\n                        lenIndices32Bit += geometryBucket.indices.length;\n                    }\n                }\n                if (geometryBucket.edgeIndices) {\n                    if (numPositions <= (1 << 8)) {\n                        lenEdgeIndices8Bit += geometryBucket.edgeIndices.length;\n                    } else if (numPositions <= (1 << 16)) {\n                        lenEdgeIndices16Bit += geometryBucket.edgeIndices.length;\n                    } else {\n                        lenEdgeIndices32Bit += geometryBucket.edgeIndices.length;\n                    }\n                }\n                if (geometryBucket.uvsCompressed) {\n                    lenUVs += geometryBucket.uvsCompressed.length;\n                }\n            }\n        }\n    }\n\n    for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {\n        const texture = texturesList[textureIndex];\n        const imageData = texture.imageData;\n        lenTextures += imageData.byteLength;\n    }\n\n    lenDecodeMatrices = numGeometries * 16;\n\n    const xktData: XKTData = {\n        metadata: dataModel ? dataModel.getJSON() : {},\n        textureData: new Uint8Array(lenTextures), // All textures\n        eachTextureDataPortion: new Uint32Array(numTextures), // For each texture, an index to its first element in textureData\n        eachTextureAttributes: new Uint16Array(numTextures * NUM_TEXTURE_ATTRIBUTES),\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        colors: new Uint8Array(lenColors),\n        uvs: new Float32Array(lenUVs),\n        indices8Bit: new Uint8Array(lenIndices8Bit),\n        indices16Bit: new Uint16Array(lenIndices16Bit),\n        indices32Bit: new Uint32Array(lenIndices32Bit),\n        edgeIndices8Bit: new Uint8Array(lenEdgeIndices8Bit),\n        edgeIndices16Bit: new Uint16Array(lenEdgeIndices16Bit),\n        edgeIndices32Bit: new Uint32Array(lenEdgeIndices32Bit),\n        eachTextureSetTextures: new Int32Array(numTextureSets * 5), // For each texture set, a set of five Texture indices [color, metal/roughness,normals,emissive,occlusion]; each index has value -1 if no texture\n        decodeMatrices: new Float32Array(lenDecodeMatrices), // TODO\n        eachBucketPositionsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.positions. Every primitive type has positions.\n        eachBucketColorsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.colors. If the next geometry has the same index, then this geometry has no colors.\n        eachBucketUVsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.uvs. If the next geometry has the same index, then this geometry has no UVs.\n        eachBucketIndicesPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.indices. If the next geometry has the same index, then this geometry has no indices.\n        eachBucketEdgeIndicesPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.\n        eachBucketIndicesBitness: new Uint8Array(lenBuckets), // TODO\n        eachGeometryPrimitiveType: new Uint8Array(numGeometries), // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points)\n        eachGeometryBucketPortion: new Uint32Array(numGeometries), // TODO\n        eachGeometryDecodeMatricesPortion: new Uint32Array(numGeometries), // Positions dequantization matrices\n        matrices: new Float32Array(lenMatrices), // Modeling matrices\n        eachMeshGeometriesPortion: new Uint32Array(numMeshes), // For each mesh, an index into the eachGeometry* arrays\n        eachMeshMatricesPortion: new Uint32Array(numMeshes), // For each mesh that shares its geometry, an index to its first element in xktData.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.\n        eachMeshTextureSet: new Uint32Array(numMeshes), // For each mesh, the index of its texture set in xktData.eachTextureSetTextures; this array contains signed integers so that we can use -1 to indicate when a mesh has no texture set\n        eachMeshMaterialAttributes: new Uint8Array(numMeshes * NUM_MATERIAL_ATTRIBUTES), // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]\n        eachObjectId: [], // For each object, an ID string\n        eachObjectMeshesPortion: new Uint32Array(numObjects) // For each object, the index of the first element of meshes used by the object\n    };\n\n    let countBuckets = 0;\n    let countPositions = 0;\n    let countColors = 0;\n    let countUVs = 0;\n    let countIndices8Bit = 0;\n    let countIndices16Bit = 0;\n    let countIndices32Bit = 0;\n    let countEdgeIndices8Bit = 0;\n    let countEdgeIndices16Bit = 0;\n    let countEdgeIndices32Bit = 0;\n    let countDecodeMatrices = 0;\n\n    // Geometries and buckets\n\n    let geometryIndex = 0;\n\n    for (let geometryId in sceneModel.geometries) {\n\n        const geometry = sceneModel.geometries[geometryId];\n        const geometryBuckets = geometry.geometryBuckets;\n\n        xktData.eachGeometryPrimitiveType [geometryIndex] = geometry.primitive;\n        xktData.eachGeometryBucketPortion [geometryIndex] = countBuckets;\n        xktData.eachGeometryDecodeMatricesPortion [geometryIndex] = countDecodeMatrices;\n\n        xktData.decodeMatrices.set(geometry.positionsDecompressMatrix, countDecodeMatrices); // TODO: only add decode matrix if different from what's already added\n        countDecodeMatrices += 16;\n\n        for (let i = 0, len = geometryBuckets.length; i < len; i++) {\n\n            const geometryBucket = geometryBuckets[i];\n            const lenBucketPositions = geometryBucket.positionsCompressed.length;\n            const numBucketPositions = lenBucketPositions / 3;\n            const bucketIndicesBitness: number = (numBucketPositions <= (1 << 8)) ? 0 : ((numBucketPositions <= (1 << 16)) ? 1 : 2);\n\n            xktData.eachBucketPositionsPortion [countBuckets] = countPositions;\n            xktData.eachBucketColorsPortion [countBuckets] = countColors;\n            xktData.eachBucketUVsPortion [countBuckets] = countUVs;\n            xktData.eachBucketIndicesBitness [countBuckets] = bucketIndicesBitness;\n\n            xktData.positions.set(geometryBucket.positionsCompressed, countPositions);\n            countPositions += geometryBucket.positionsCompressed.length;\n\n            if (geometryBucket.indices) {\n                switch (bucketIndicesBitness) {\n                    case 0:\n                        xktData.indices8Bit.set(geometryBucket.indices, countIndices8Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices8Bit;\n                        countIndices8Bit += geometryBucket.indices.length;\n                        break;\n                    case 1:\n                        xktData.indices16Bit.set(geometryBucket.indices, countIndices16Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices16Bit;\n                        countIndices16Bit += geometryBucket.indices.length;\n                        break;\n                    case 2:\n                        xktData.indices32Bit.set(geometryBucket.indices, countIndices32Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices32Bit;\n                        countIndices32Bit += geometryBucket.indices.length;\n                        break;\n                }\n            }\n\n            if (geometryBucket.edgeIndices) {\n                switch (bucketIndicesBitness) {\n                    case 0:\n                        xktData.edgeIndices8Bit.set(geometryBucket.edgeIndices, countEdgeIndices8Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices8Bit;\n                        countEdgeIndices8Bit += geometryBucket.edgeIndices.length;\n                        break;\n                    case 1:\n                        xktData.edgeIndices16Bit.set(geometryBucket.edgeIndices, countEdgeIndices16Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices16Bit;\n                        countEdgeIndices16Bit += geometryBucket.edgeIndices.length;\n                        break;\n                    case 2:\n                        xktData.edgeIndices32Bit.set(geometryBucket.edgeIndices, countEdgeIndices32Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices32Bit;\n                        countEdgeIndices32Bit += geometryBucket.edgeIndices.length;\n                        break;\n                }\n            }\n\n            if (geometryBucket.colorsCompressed) {\n                xktData.colors.set(geometryBucket.colorsCompressed, countColors);\n                countColors += geometryBucket.colorsCompressed.length;\n            }\n\n            if (geometryBucket.uvsCompressed) {\n                xktData.uvs.set(geometryBucket.uvsCompressed, countUVs);\n                countUVs += geometryBucket.uvsCompressed.length;\n            }\n\n            countBuckets++;\n        }\n\n        geometryIndices[geometry.id] = geometryIndex;\n        geometryIndex++;\n    }\n\n    // Textures\n\n    for (let textureIndex = 0, numTextures = texturesList.length, portionIdx = 0; textureIndex < numTextures; textureIndex++) {\n\n        const texture = texturesList[textureIndex];\n        const imageData = texture.imageData;\n\n        xktData.textureData.set(imageData, portionIdx);\n        xktData.eachTextureDataPortion[textureIndex] = portionIdx;\n\n        portionIdx += imageData.byteLength;\n\n        let textureAttrIdx = textureIndex * NUM_TEXTURE_ATTRIBUTES;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.compressed ? 1 : 0;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.mediaType || 0; // GIFMediaType | PNGMediaType | JPEGMediaType\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.width;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.height;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.minFilter || LinearMipmapLinearFilter; // LinearMipmapLinearFilter | LinearMipMapNearestFilter | NearestMipMapNearestFilter | NearestMipMapLinearFilter | LinearMipMapLinearFilter\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.magFilter || LinearMipmapLinearFilter; // LinearFilter | NearestFilter\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapS || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapT || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapR || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n\n        textureIndices[texture.id] = textureIndex;\n    }\n\n    // Texture sets\n\n    for (let textureSetIndex = 0, numTextureSets = textureSetsList.length, eachTextureSetTexturesIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {\n        const textureSet = textureSetsList[textureSetIndex];\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.colorTexture ? textureIndices[textureSet.colorTexture.id] : -1; // Color map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.metallicRoughnessTexture ? textureIndices[textureSet.metallicRoughnessTexture.id] : -1; // Metal/rough map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.emissiveTexture ? textureIndices[textureSet.emissiveTexture.id] : -1; // Emissive map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.occlusionTexture ? textureIndices[textureSet.occlusionTexture.id] : -1; // Occlusion map\n\n        textureSetIndices[textureSet.id] = textureSetIndex;\n    }\n\n    // Meshes and objects\n\n    let eachMeshMaterialAttributesIndex = 0;\n    let matricesIndex = 0;\n    let countMeshes = 0;\n\n    for (let objectIndex = 0; objectIndex < numObjects; objectIndex++) {\n\n        const object = objectsList[objectIndex];\n        const numObjectMeshes = object.meshes.length;\n\n        xktData.eachObjectId[objectIndex] = object.id;\n        xktData.eachObjectMeshesPortion[objectIndex] = countMeshes;\n\n        for (let meshIndex = 0; meshIndex < numObjectMeshes; meshIndex++) {\n\n            const mesh = object.meshes[meshIndex];\n\n            xktData.eachMeshGeometriesPortion [meshIndex] = geometryIndices[mesh.geometry.id];\n\n            xktData.eachMeshMatricesPortion [meshIndex] = matricesIndex;\n            xktData.matrices.set(mesh.matrix, matricesIndex); // TODO: only add matrix if different from what's already added\n            matricesIndex += 16;\n\n            xktData.eachMeshTextureSet[meshIndex] = mesh.textureSet ? textureSetIndices[mesh.textureSet.id] : -1;\n\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[0] * 255); // Color RGB\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[1] * 255);\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[2] * 255);\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.opacity * 255); // Opacity\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.metallic * 255); // Metallic\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.roughness * 255); // Roughness\n        }\n\n        countMeshes += numObjectMeshes;\n    }\n\n    return xktData;\n}\n","/**\n * Provides info on the XKT generated by xeokit-convert.\n *\n * See {@link @xeokit/xkt} for usage.\n */\nexport const XKT_INFO = {\n\n    /**\n     * The XKT version generated by xeokit-convert.\n     *\n     * @property xktVersion\n     * @type {number}\n     */\n    xktVersion: 11\n};"],"names":["inflateXKT","xktDataDeflated","inflate","array","options","length","pako","buffer","metadata","JSON","parse","to","textureData","Uint8Array","eachTextureDataPortion","Uint32Array","eachTextureAttributes","Uint16Array","positions","colors","uvs","Float32Array","indices8Bit","indices16Bit","indices32Bit","edgeIndices8Bit","edgeIndices16Bit","edgeIndices32Bit","eachTextureSetTextures","Int32Array","decodeMatrices","eachBucketPositionsPortion","eachBucketColorsPortion","eachBucketUVsPortion","eachBucketIndicesPortion","eachBucketEdgeIndicesPortion","eachBucketIndicesBitness","eachGeometryPrimitiveType","eachGeometryBucketPortion","eachGeometryDecodeMatricesPortion","matrices","eachMeshGeometriesPortion","eachMeshMatricesPortion","eachMeshTextureSet","eachMeshMaterialAttributes","eachObjectId","eachObjectMeshesPortion","unpackXKT","arrayBuffer","dataView","DataView","dataArray","getUint32","numElements","elements","byteOffset","i","elementSize","push","subarray","r","decompressColor","floatColor","intColor","loadXKT","params","sceneModel","destroyed","Error","built","SDKError","dataModel","Promise","resolve","reject","xktData","fromJSON","numTextures","numTextureSets","numBuckets","numObjects","nextMeshId","geometryCreated","textureIndex","textureDataPortionStart","textureDataPortionEnd","textureAttrBaseIdx","compressed","mediaType","minFilter","magFilter","wrapS","wrapT","wrapR","textureId","createTexture","id","buffers","blob","Blob","type","imageUrl","window","URL","webkitURL","createObjectURL","img","document","createElement","src","image","textureSetIndex","eachTextureSetTexturesIndex","colorTextureIndex","metallicRoughnessTextureIndex","normalsTextureIndex","emissiveTextureIndex","occlusionTextureIndex","createTextureSet","colorTextureId","undefined","normalsTextureId","metallicRoughnessTextureId","emissiveTextureId","occlusionTextureId","objectIndex","objectId","lastMeshIndex","meshIds","meshIndex","geometryIndex","textureSetId","meshColor","meshOpacity","meshMetallic","meshRoughness","meshId","meshMatrixIndex","meshMatrix","slice","geometryId","geometryParams","geometryBuckets","primitive","geometryDecodeMatrixIndex","positionsDecompressMatrix","firstBucketIndex","atLastBucket","lastBucketIndex","bucketIndex","geometryBucketParams","positionsCompressed","indices","geometryIndicesBitness","edgeIndices","bucketValid","createGeometryCompressed","createMesh","matrix","color","metallic","roughness","opacity","createObject","xktToModel","data","saveXKT","deflatedData","metaModelJSON","metaModelBytes","deflatedJSON","stringify","replace","chr","charCodeAt","toString","substr","deflate","deflateXKT","geometriesList","Object","values","geometries","texturesList","textures","textureSetsList","textureSets","meshesList","meshes","objectsList","objects","numGeometries","numMeshes","lenBuckets","lenPositions","lenUVs","lenIndices8Bit","lenIndices16Bit","lenIndices32Bit","lenEdgeIndices8Bit","lenEdgeIndices16Bit","lenEdgeIndices32Bit","lenTextures","lenDecodeMatrices","geometryIndices","textureIndices","textureSetIndices","len","geometryBucket","numPositions","uvsCompressed","imageData","byteLength","getJSON","countBuckets","countPositions","countColors","countUVs","countIndices8Bit","countIndices16Bit","countIndices32Bit","countEdgeIndices8Bit","countEdgeIndices16Bit","countEdgeIndices32Bit","countDecodeMatrices","geometry","set","numBucketPositions","bucketIndicesBitness","colorsCompressed","portionIdx","texture","textureAttrIdx","width","height","ClampToEdgeWrapping","textureSet","colorTexture","metallicRoughnessTexture","emissiveTexture","occlusionTexture","eachMeshMaterialAttributesIndex","matricesIndex","countMeshes","object","numObjectMeshes","mesh","modelToXKT","indexData","dataLen","elementsize","indexBuf","offset","element","toArrayBuffer"],"mappings":"+DAOgB,SAAAA,EAAWC,GAEvB,SAASC,EAAQC,EAAWC,GACxB,OAAyB,IAAjBD,EAAME,OAAgB,GAA2BC,EAAKJ,QAAQC,EAAOC,GAAUG,MAC3F,CAEA,MAAgB,CACZC,SAAUC,KAAKC,MAAMJ,EAAKJ,QAAQD,EAAgBO,SAAU,CAACG,GAAI,YACjEC,YAAa,IAAIC,WAAWX,EAAQD,EAAgBW,cACpDE,uBAAwB,IAAIC,YAAYb,EAAQD,EAAgBa,yBAChEE,sBAAuB,IAAIC,YAAYf,EAAQD,EAAgBe,wBAC/DE,UAAW,IAAID,YAAYf,EAAQD,EAAgBiB,YACnDC,OAAQ,IAAIN,WAAWX,EAAQD,EAAgBkB,SAC/CC,IAAK,IAAIC,aAAanB,EAAQD,EAAgBmB,MAC9CE,YAAa,IAAIT,WAAWX,EAAQD,EAAgBqB,cACpDC,aAAc,IAAIN,YAAYf,EAAQD,EAAgBsB,eACtDC,aAAc,IAAIT,YAAYb,EAAQD,EAAgBuB,eACtDC,gBAAiB,IAAIZ,WAAWX,EAAQD,EAAgBwB,kBACxDC,iBAAkB,IAAIT,YAAYf,EAAQD,EAAgByB,mBAC1DC,iBAAkB,IAAIZ,YAAYb,EAAQD,EAAgB0B,mBAC1DC,uBAAwB,IAAIC,WAAW3B,EAAQD,EAAgB2B,yBAC/DE,eAAgB,IAAIT,aAAanB,EAAQD,EAAgB6B,iBACzDC,2BAA4B,IAAIhB,YAAYb,EAAQD,EAAgB8B,6BACpEC,wBAAyB,IAAIjB,YAAYb,EAAQD,EAAgB+B,0BACjEC,qBAAsB,IAAIlB,YAAYb,EAAQD,EAAgBgC,uBAC9DC,yBAA0B,IAAInB,YAAYb,EAAQD,EAAgBiC,2BAClEC,6BAA8B,IAAIpB,YAAYb,EAAQD,EAAgBkC,+BACtEC,yBAA0B,IAAIvB,WAAWX,EAAQD,EAAgBmC,2BACjEC,0BAA2B,IAAIxB,WAAWX,EAAQD,EAAgBoC,4BAClEC,0BAA2B,IAAIvB,YAAYb,EAAQD,EAAgBqC,4BACnEC,kCAAmC,IAAIxB,YAAYb,EAAQD,EAAgBsC,oCAC3EC,SAAU,IAAInB,aAAanB,EAAQD,EAAgBuC,WACnDC,0BAA2B,IAAI1B,YAAYb,EAAQD,EAAgBwC,4BACnEC,wBAAyB,IAAI3B,YAAYb,EAAQD,EAAgByC,0BACjEC,mBAAoB,IAAI5B,YAAYb,EAAQD,EAAgB0C,qBAC5DC,2BAA4B,IAAI/B,WAAWX,EAAQD,EAAgB2C,6BACnEC,aAAcpC,KAAKC,MAAMJ,EAAKJ,QAAQD,EAAgB4C,aAAc,CAAClC,GAAI,YACzEmC,wBAAyB,IAAI/B,YAAYb,EAAQD,EAAgB6C,0BAEzE,CCzCM,SAAUC,EAAUC,GAEtB,MAAMC,EAAW,IAAIC,SAASF,GACxBG,EAAY,IAAItC,WAAWmC,GACdC,EAASG,UAAU,GAAG,GACzC,MAAMC,EAAcJ,EAASG,UAAU,GAAG,GAEpCE,EAAW,GACjB,IAAIC,EAAiC,GAAnBF,EAAc,GAChC,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAaG,IAAK,CAClC,MAAMC,EAAcR,EAASG,UAAoB,GAATI,EAAI,IAAQ,GACpDF,EAASI,KAAKP,EAAUQ,SAASJ,EAAYA,EAAaE,IAC1DF,GAAcE,CACjB,CAED,IAAID,EAAI,EAER,MAAwB,CACpBhD,SAAU8C,EAASE,KACnB5C,YAAa0C,EAASE,KACtB1C,uBAAwBwC,EAASE,KACjCxC,sBAAuBsC,EAASE,KAChCtC,UAAWoC,EAASE,KACpBrC,OAAQmC,EAASE,KACjBpC,IAAKkC,EAASE,KACdlC,YAAagC,EAASE,KACtBjC,aAAc+B,EAASE,KACvBhC,aAAc8B,EAASE,KACvB/B,gBAAiB6B,EAASE,KAC1B9B,iBAAkB4B,EAASE,KAC3B7B,iBAAkB2B,EAASE,KAC3B5B,uBAAwB0B,EAASE,KACjC1B,eAAgBwB,EAASE,KACzBzB,2BAA4BuB,EAASE,KACrCxB,wBAAyBsB,EAASE,KAClCvB,qBAAsBqB,EAASE,KAC/BtB,yBAA0BoB,EAASE,KACnCrB,6BAA8BmB,EAASE,KACvCpB,yBAA0BkB,EAASE,KACnCnB,0BAA2BiB,EAASE,KACpClB,0BAA2BgB,EAASE,KACpCjB,kCAAmCe,EAASE,KAC5ChB,SAAUc,EAASE,KACnBf,0BAA2Ba,EAASE,KACpCd,wBAAyBY,EAASE,KAClCb,mBAAoBW,EAASE,KAC7BZ,2BAA4BU,EAASE,KACrCX,aAAcS,EAASE,KACvBV,wBAAyBQ,EAASE,KAE1C,CCxCa,IAKAI,EAAsB,KCdnC,MA8OMC,EAAmB,WACrB,MAAMC,EAAa,IAAIzC,aAAa,GACpC,gBAAiB0C,GAIb,OAHAD,EAAW,GAAKC,EAAS,GAAK,IAC9BD,EAAW,GAAKC,EAAS,GAAK,IAC9BD,EAAW,GAAKC,EAAS,GAAK,IACvBD,CACX,CACJ,CARyB,GCtNT,SAAAE,EAAQC,GAKpB,GAAIA,EAAOC,WAAWC,UAClB,MAAU,IAAAC,MAAM,gCAEpB,GAAIH,EAAOC,WAAWG,MAClB,MAAU,IAAAC,EAAS,4BAEvB,GAAIL,EAAOM,UAAW,CAClB,GAAIN,EAAOM,UAAUJ,UACjB,MAAU,IAAAG,EAAS,+BAEvB,GAAIL,EAAOM,UAAUF,MACjB,MAAU,IAAAC,EAAS,0BAE1B,CACD,OAAW,IAAAE,QAAc,SAAUC,EAASC,aDtCrBT,GAMvB,MAAMU,EAAUV,EAAOU,QACjBT,EAAaD,EAAOC,WACpBK,EAAYN,EAAOM,UAErBA,GACII,EAAQnE,UACR+D,EAAUK,SAA0BD,EAAQnE,UAIpD,MAAMqE,EAAcF,EAAQ7D,uBAAuBT,OAC7CyE,EAAiBH,EAAQ/C,uBAAuBvB,OAAS,EACzD0E,EAAaJ,EAAQ5C,2BAA2B1B,OAEhD2E,EAAaL,EAAQ7B,wBAAwBzC,OAGnD,IAAI4E,EAAa,EAEjB,MAAMC,EAEF,GAIJ,IAAK,IAAIC,EAAe,EAAGA,EAAeN,EAAaM,IAAgB,CAEnE,MACMC,EAA0BT,EAAQ7D,uBAAuBqE,GACzDE,EAFiBF,IAAkBN,EAAc,EAETF,EAAQ/D,YAAYP,OAAUsE,EAAQ7D,uBAAuBqE,EAAe,GAGpHG,EA3CiB,EA2CKH,EAEtBI,EAAoE,IAAtDZ,EAAQ3D,sBAAsBsE,GAC5CE,EAAYb,EAAQ3D,sBAAsBsE,EAAqB,GAG/DG,EAAYd,EAAQ3D,sBAAsBsE,EAAqB,GAC/DI,EAAYf,EAAQ3D,sBAAsBsE,EAAqB,GAC/DK,EAAQhB,EAAQ3D,sBAAsBsE,EAAqB,GAC3DM,EAAQjB,EAAQ3D,sBAAsBsE,EAAqB,GAC3DO,EAAQlB,EAAQ3D,sBAAsBsE,EAAqB,GAEjE,GAd+BD,EAAwBD,EACI,EAa7B,CAE1B,MACMpC,EADoB,IAAInC,WAAW8D,EAAQ/D,YAAY+C,SAASyB,EAAyBC,IACzD9E,OAChCuF,EAAuB,WAAAX,IAE7B,GAAII,EAEArB,EAAW6B,cAAc,CACrBC,GAAIF,EACJG,QAAS,CAACjD,GACVyC,YACAC,YACAC,QACAC,QACAC,cAGD,CAEH,MACMK,EAAO,IAAIC,KAAK,CAACnD,GAAc,CAACoD,KDkSzB,QCnSIZ,EAA8B,aDwSnC,QCxSmDA,EAA6B,YAAc,cAGpGa,GADaC,OAAOC,KAAOD,OAAOE,WACZC,gBAAgBP,GACtCQ,EAAMC,SAASC,cAAc,OACnCF,EAAIG,IAAMR,EAEVnC,EAAW6B,cAAc,CACrBC,GAAIF,EACJgB,MAAOJ,EACPlB,YACAC,YACAC,YACAC,QACAC,QACAC,SAEP,CACJ,CACJ,CAID,IAAK,IAAIkB,EAAkB,EAAGA,EAAkBjC,EAAgBiC,IAAmB,CAE/E,MAAMC,EAAgD,EAAlBD,EAE9BE,EAAoBtC,EAAQ/C,uBAAuBoF,GACnDE,EAAgCvC,EAAQ/C,uBAAuBoF,EAA8B,GAC7FG,EAAsBxC,EAAQ/C,uBAAuBoF,EAA8B,GACnFI,EAAuBzC,EAAQ/C,uBAAuBoF,EAA8B,GACpFK,EAAwB1C,EAAQ/C,uBAAuBoF,EAA8B,GAE3F9C,EAAWoD,iBAAiB,CACxBtB,GAR+B,cAAAe,IAS/BQ,eAAgBN,GAAqB,EAAI,WAAWA,SAAsBO,EAC1EC,iBAAkBN,GAAuB,EAAI,WAAWA,SAAwBK,EAChFE,2BAA4BR,GAAiC,EAAI,WAAWA,SAAkCM,EAC9GG,kBAAmBP,GAAwB,EAAI,WAAWA,SAAyBI,EACnFI,mBAAoBP,GAAyB,EAAI,WAAWA,SAA0BG,GAE7F,CAID,IAAK,IAAIK,EAAc,EAAGA,GAAe7C,EAAY6C,IAAe,CAEhE,MAAMC,EAAWnD,EAAQ9B,aAAagF,GAIhCE,EAFgBF,IADI7C,EAAa,EAGDL,EAAQlC,0BAA0BpC,OAAS,EAAMsE,EAAQ7B,wBAAwB+E,EAAc,GAAK,EAEpIG,EAAU,GAIhB,IAAK,IAAIC,EAPctD,EAAQ7B,wBAAyB+E,GAOnBI,GAAaF,EAAeE,IAAa,CAE1E,MAAMC,EAAgBvD,EAAQlC,0BAA0BwF,GAElDlB,EAAkBpC,EAAQhC,mBAAmBsF,GAC7CE,EAAgBpB,GAAmB,gBAAmBA,SAAoBS,EAE1EY,EAAYvE,EAAgBc,EAAQ/B,2BAA2Be,SAAsB,EAAZsE,EAA6B,EAAZA,EAAiB,IAC3GI,EAAc1D,EAAQ/B,2BAAwC,EAAZqF,EAAiB,GAAK,IACxEK,EAAe3D,EAAQ/B,2BAAwC,EAAZqF,EAAiB,GAAK,IACzEM,EAAgB5D,EAAQ/B,2BAAwC,EAAZqF,EAAiB,GAAK,IAE1EO,EAAS,QAAQvD,IACjBwD,EAAkB9D,EAAQjC,wBAAwBuF,GAClDS,EAAa/D,EAAQnC,SAASmG,MAAMF,EAAiBA,EAAkB,IAEvEG,EAAyB,YAAAV,IAE/B,IAAKhD,EAAgB0D,GAAa,CAE9B,MAAMC,EAAsB,CACxBC,gBAAiB,IAGrBD,EAAeE,UAAYpE,EAAQtC,0BAA0B6F,GAC7D,MAAMc,EAA4BrE,EAAQpC,kCAAkC2F,GAC5EW,EAAeI,0BAA4BtE,EAAQpC,kCAAkCoG,MAAMK,EAA2BA,EAA4B,IAMlJ,MAAME,EAAmBvE,EAAQrC,0BAA0B4F,GACrDiB,EAAgBD,IAAsBnE,EAAa,EACnDqE,EAAkBD,EAAgBxE,EAAQlC,0BAA0BpC,OAAS,EAAMsE,EAAQ7B,wBAAwB+E,EAAc,GAAK,EAE5I,IAAK,IAAIwB,EAAcH,EAAkBG,GAAeD,EAAiBC,IAAe,CAEpF,MAAMC,EAA6C,CAC/CC,oBAAqB,GACrBC,QAAS,IAGPC,EAAyB9E,EAAQvC,yBAAyBiH,GAC1DG,EAAqC,IAA3BC,EAA+B9E,EAAQrD,YAA0C,KAA3BmI,EAAgC9E,EAAQpD,aAAeoD,EAAQnD,aAC/HkI,EAAyC,IAA3BD,EAA+B9E,EAAQlD,gBAA8C,KAA3BgI,EAAgC9E,EAAQjD,iBAAmBiD,EAAQhD,iBAEjJ,IAAIgI,GAAc,EAElB,OAAQd,EAAeE,WAEnB,KD8MU,MC7MNO,EAAqBC,oBAAsB5E,EAAQzD,UAAUyC,SAASgB,EAAQ5C,2BAA4BsH,GAAcF,EAAexE,EAAQzD,UAAUb,OAASsE,EAAQ5C,2BAA4BsH,EAAc,IAEpNC,EAAqBE,QAAUA,EAAQ7F,SAASgB,EAAQzC,yBAA0BmH,GAAcF,EAAeK,EAAQnJ,OAASsE,EAAQzC,yBAA0BmH,EAAc,IAChLC,EAAqBI,YAAcA,EAAY/F,SAASgB,EAAQxC,6BAA8BkH,GAAcF,EAAeO,EAAYrJ,OAASsE,EAAQxC,6BAA8BkH,EAAc,IACpMM,EAAeL,EAAqBC,oBAAoBlJ,OAAS,GAAKiJ,EAAqBE,QAAQnJ,OAAS,EAC5G,MAEJ,KDyLO,ICxLHiJ,EAAqBC,oBAAsB5E,EAAQzD,UAAUyC,SAASgB,EAAQ5C,2BAA4BsH,GAAcF,EAAexE,EAAQzD,UAAUb,OAASsE,EAAQ5C,2BAA4BsH,EAAc,IAEpNM,EAAeL,EAAqBC,oBAAoBlJ,OAAS,EACjE,MAEJ,KDwLM,MCvLFiJ,EAAqBC,oBAAsB5E,EAAQzD,UAAUyC,SAASgB,EAAQ5C,2BAA4BsH,GAAcF,EAAexE,EAAQzD,UAAUb,OAASsE,EAAQ5C,2BAA4BsH,EAAc,IACpNC,EAAqBE,QAAUA,EAAQ7F,SAASgB,EAAQzC,yBAA0BmH,GAAcF,EAAeK,EAAQnJ,OAASsE,EAAQzC,yBAA0BmH,EAAc,IAChLM,EAAeL,EAAqBC,oBAAoBlJ,OAAS,GAAKiJ,EAAqBE,QAAQnJ,OAAS,EAC5G,MACJ,QACI,SAEJsJ,GACAd,EAAeC,gBAAgBpF,KAAK4F,EAE3C,CAEGT,EAAeC,gBAAgBzI,OAAS,IACxC6D,EAAW0F,yBAAmDf,GAC9D3D,EAAgB0D,IAAc,EAErC,CAED1E,EAAW2F,WAAW,CAClB7D,GAAIwC,EACJI,aACAT,eACA2B,OAAQpB,EACRqB,MAAO3B,EACP4B,SAAU1B,EACV2B,UAAW1B,EACX2B,QAAS7B,IAEbL,EAAQtE,KAAK8E,EAChB,CAEGR,EAAQ3H,OAAS,GACjB6D,EAAWiG,aAAa,CACpBnE,GAAI8B,EACJE,QAASA,GAGpB,CACL,CChMQoC,CAAW,CACPzF,QAAS3E,EAAW+C,EAAUkB,EAAOoG,OACrCnG,WAAYD,EAAOC,WACnBK,UAAWN,EAAOM,YAEtBE,GACJ,EACJ,CChCM,SAAU6F,EAAQrG,GAIpB,GAAIA,EAAOC,WAAWC,UAClB,MAAM,IAAIG,EAAS,gCAEvB,IAAKL,EAAOC,WAAWG,MACnB,MAAU,IAAAC,EAAS,4BAEvB,GAAIL,EAAOM,UAAW,CAClB,GAAIN,EAAOM,UAAUJ,UACjB,MAAU,IAAAG,EAAS,+BAEvB,IAAKL,EAAOM,UAAUF,MAClB,MAAM,IAAIC,EAAS,0BAE1B,CACD,OCrCoBiG,ECCR,SAAW5F,EAAkB6F,GACzC,IAAIC,EAIG,CACH,MAAMC,EA0CHjK,KAAKkK,UA1CyB,CAAC,OA2CjCC,QAAQ,mBAAoB,SAAUC,GACnC,MAAO,OAAS,OAASA,EAAIC,WAAW,GAAGC,SAAS,KAAKC,QAAQ,EACrE,GA5CAP,EAAiBnK,EAAK2K,QAAQP,EACjC,CACD,MAAwB,CACpBlK,SAAUiK,EACV7J,YAAaN,EAAK2K,QAAQtG,EAAQ/D,YAAYL,QAC9CO,uBAAwBR,EAAK2K,QAAQtG,EAAQ7D,uBAAuBP,QACpES,sBAAuBV,EAAK2K,QAAQtG,EAAQ3D,sBAAsBT,QAClEW,UAAWZ,EAAK2K,QAAQtG,EAAQzD,UAAUX,QAC1CY,OAAQb,EAAK2K,QAAQtG,EAAQxD,OAAOZ,QACpCa,IAAKd,EAAK2K,QAAQtG,EAAQvD,IAAIb,QAC9Be,YAAahB,EAAK2K,QAAQtG,EAAQrD,YAAYf,QAC9CgB,aAAcjB,EAAK2K,QAAQtG,EAAQpD,aAAahB,QAChDiB,aAAclB,EAAK2K,QAAQtG,EAAQnD,aAAajB,QAChDkB,gBAAiBnB,EAAK2K,QAAQtG,EAAQlD,gBAAgBlB,QACtDmB,iBAAkBpB,EAAK2K,QAAQtG,EAAQjD,iBAAiBnB,QACxDoB,iBAAkBrB,EAAK2K,QAAQtG,EAAQhD,iBAAiBpB,QACxDqB,uBAAwBtB,EAAK2K,QAAQtG,EAAQ/C,uBAAuBrB,QACpEuB,eAAgBxB,EAAK2K,QAAQtG,EAAQ7C,eAAevB,QACpDwB,2BAA4BzB,EAAK2K,QAAQtG,EAAQ5C,2BAA2BxB,QAC5EyB,wBAAyB1B,EAAK2K,QAAQtG,EAAQ3C,wBAAwBzB,QACtE0B,qBAAsB3B,EAAK2K,QAAQtG,EAAQ1C,qBAAqB1B,QAChE2B,yBAA0B5B,EAAK2K,QAAQtG,EAAQzC,yBAAyB3B,QACxE4B,6BAA8B7B,EAAK2K,QAAQtG,EAAQxC,6BAA6B5B,QAChF6B,yBAA0B9B,EAAK2K,QAAQtG,EAAQvC,yBAAyB7B,QACxE8B,0BAA2B/B,EAAK2K,QAAQtG,EAAQtC,0BAA0B9B,QAC1E+B,0BAA2BhC,EAAK2K,QAAQtG,EAAQrC,0BAA0B/B,QAC1EgC,kCAAmCjC,EAAK2K,QAAQtG,EAAQpC,kCAAkChC,QAC1FiC,SAAUlC,EAAK2K,QAAQtG,EAAQnC,SAASjC,QACxCkC,0BAA2BnC,EAAK2K,QAAQtG,EAAQlC,0BAA0BlC,QAC1EmC,wBAAyBpC,EAAK2K,QAAQtG,EAAQjC,wBAAwBnC,QACtEoC,mBAAoBrC,EAAK2K,QAAQtG,EAAQhC,mBAAmBpC,QAC5DqC,2BAA4BtC,EAAK2K,QAAQtG,EAAQ/B,2BAA2BrC,QAC5EsC,aAAcvC,EAAK2K,QAAQxK,KAAKkK,UAAUhG,EAAQ9B,cAC7C+H,QAAQ,mBAAoB,SAAUC,GACnC,MAAO,OAAS,OAASA,EAAIC,WAAW,GAAGC,SAAS,KAAKC,QAAQ,EACrE,IACJlI,wBAAyBxC,EAAK2K,QAAQtG,EAAQ7B,wBAAwBvC,QAE9E,CFTmB2K,CG9BH,SAAWjH,GAKvB,MAAMC,EAAaD,EAAOC,WACpBK,EAAYN,EAAOM,UAEnB4G,EAAiBC,OAAOC,OAAOnH,EAAWoH,YAC1CC,EAAeH,OAAOC,OAAOnH,EAAWsH,UACxCC,EAAkBL,OAAOC,OAAOnH,EAAWwH,aAC3CC,EAAaP,OAAOC,OAAOnH,EAAW0H,QACtCC,EAAcT,OAAOC,OAAOnH,EAAW4H,SAEvCC,EAAgBZ,EAAe9K,OAC/BwE,EAAc0G,EAAalL,OAC3ByE,EAAiB2G,EAAgBpL,OACjC2L,EAAYL,EAAWtL,OACvB2E,EAAa6G,EAAYxL,OAE/B,IAAI4L,EAAa,EACbC,EAAe,EAEfC,EAAS,EACTC,EAAiB,EACjBC,EAAkB,EAClBC,EAAkB,EAClBC,EAAqB,EACrBC,EAAsB,EACtBC,EAAsB,EAEtBC,EAAc,EACdC,EAAoB,EAExB,MAAMC,EAA6C,CAAA,EAC7CC,EAA4C,CAAE,EAC9CC,EAA+C,CAAE,EAGvD,IAAK,IAAI5E,EAAgB,EAAGA,EAAgB6D,EAAe7D,IAAiB,CACxE,MACMY,EADWqC,EAAgBjD,GACAY,gBACjCmD,GAAcnD,EAAgBzI,OAC9B,IAAK,IAAImD,EAAI,EAAGuJ,EAAMjE,EAAgBzI,OAAQmD,EAAIuJ,EAAKvJ,IAAK,CACxD,MAAMwJ,EAAiBlE,EAAgBtF,GACvC,GAAIwJ,EAAezD,oBAAqB,CACpC,MAAM0D,EAAeD,EAAezD,oBAAoBlJ,OAAS,EACjE6L,GAAgBc,EAAezD,oBAAoBlJ,OAC/C2M,EAAexD,UACXyD,GAAiB,IACjBb,GAAkBY,EAAexD,QAAQnJ,OAClC4M,GAAiB,MACxBZ,GAAmBW,EAAexD,QAAQnJ,OAE1CiM,GAAmBU,EAAexD,QAAQnJ,QAG9C2M,EAAetD,cACXuD,GAAiB,IACjBV,GAAsBS,EAAetD,YAAYrJ,OAC1C4M,GAAiB,MACxBT,GAAuBQ,EAAetD,YAAYrJ,OAElDoM,GAAuBO,EAAetD,YAAYrJ,QAGtD2M,EAAeE,gBACff,GAAUa,EAAeE,cAAc7M,OAE9C,CACJ,CACJ,CAED,IAAK,IAAI8E,EAAe,EAAGA,EAAeN,EAAaM,IAGnDuH,GAFgBnB,EAAapG,GACHgI,UACDC,WAG7BT,EAAoC,GAAhBZ,EAEpB,MAAMpH,EAAmB,CACrBnE,SAAU+D,EAAYA,EAAU8I,UAAY,CAAE,EAC9CzM,YAAa,IAAIC,WAAW6L,GAC5B5L,uBAAwB,IAAIC,YAAY8D,GACxC7D,sBAAuB,IAAIC,YA3FJ,EA2FgB4D,GACvC3D,UAAW,IAAID,YAAYiL,GAC3B/K,OAAQ,IAAIN,WAjEA,GAkEZO,IAAK,IAAIC,aAAa8K,GACtB7K,YAAa,IAAIT,WAAWuL,GAC5B7K,aAAc,IAAIN,YAAYoL,GAC9B7K,aAAc,IAAIT,YAAYuL,GAC9B7K,gBAAiB,IAAIZ,WAAW0L,GAChC7K,iBAAkB,IAAIT,YAAYuL,GAClC7K,iBAAkB,IAAIZ,YAAY0L,GAClC7K,uBAAwB,IAAIC,WAA4B,EAAjBiD,GACvChD,eAAgB,IAAIT,aAAasL,GACjC5K,2BAA4B,IAAIhB,YAAYkL,GAC5CjK,wBAAyB,IAAIjB,YAAYkL,GACzChK,qBAAsB,IAAIlB,YAAYkL,GACtC/J,yBAA0B,IAAInB,YAAYkL,GAC1C9J,6BAA8B,IAAIpB,YAAYkL,GAC9C7J,yBAA0B,IAAIvB,WAAWoL,GACzC5J,0BAA2B,IAAIxB,WAAWkL,GAC1CzJ,0BAA2B,IAAIvB,YAAYgL,GAC3CxJ,kCAAmC,IAAIxB,YAAYgL,GACnDvJ,SAAU,IAAInB,aA5EA,GA6EdoB,0BAA2B,IAAI1B,YAAYiL,GAC3CtJ,wBAAyB,IAAI3B,YAAYiL,GACzCrJ,mBAAoB,IAAI5B,YAAYiL,GACpCpJ,2BAA4B,IAAI/B,WAnHR,EAmHmBmL,GAC3CnJ,aAAc,GACdC,wBAAyB,IAAI/B,YAAYiE,IAG7C,IAAIsI,EAAe,EACfC,EAAiB,EACjBC,EAAc,EACdC,EAAW,EACXC,EAAmB,EACnBC,EAAoB,EACpBC,EAAoB,EACpBC,EAAuB,EACvBC,EAAwB,EACxBC,EAAwB,EACxBC,EAAsB,EAItB9F,EAAgB,EAEpB,IAAK,IAAIU,KAAc1E,EAAWoH,WAAY,CAE1C,MAAM2C,EAAW/J,EAAWoH,WAAW1C,GACjCE,EAAkBmF,EAASnF,gBAEjCnE,EAAQtC,0BAA2B6F,GAAiB+F,EAASlF,UAC7DpE,EAAQrC,0BAA2B4F,GAAiBoF,EACpD3I,EAAQpC,kCAAmC2F,GAAiB8F,EAE5DrJ,EAAQ7C,eAAeoM,IAAID,EAAShF,0BAA2B+E,GAC/DA,GAAuB,GAEvB,IAAK,IAAIxK,EAAI,EAAGuJ,EAAMjE,EAAgBzI,OAAQmD,EAAIuJ,EAAKvJ,IAAK,CAExD,MAAMwJ,EAAiBlE,EAAgBtF,GAEjC2K,EADqBnB,EAAezD,oBAAoBlJ,OACd,EAC1C+N,EAAgCD,GAAuB,IAAW,EAAMA,GAAuB,MAAY,EAAI,EAUrH,GARAxJ,EAAQ5C,2BAA4BuL,GAAgBC,EACpD5I,EAAQ3C,wBAAyBsL,GAAgBE,EACjD7I,EAAQ1C,qBAAsBqL,GAAgBG,EAC9C9I,EAAQvC,yBAA0BkL,GAAgBc,EAElDzJ,EAAQzD,UAAUgN,IAAIlB,EAAezD,oBAAqBgE,GAC1DA,GAAkBP,EAAezD,oBAAoBlJ,OAEjD2M,EAAexD,QACf,OAAQ4E,GACJ,KAAM,EACFzJ,EAAQrD,YAAY4M,IAAIlB,EAAexD,QAASkE,GAChD/I,EAAQzC,yBAA0BgG,GAAiBwF,EACnDA,GAAoBV,EAAexD,QAAQnJ,OAC3C,MACJ,KAAK,EACDsE,EAAQpD,aAAa2M,IAAIlB,EAAexD,QAASmE,GACjDhJ,EAAQzC,yBAA0BgG,GAAiByF,EACnDA,GAAqBX,EAAexD,QAAQnJ,OAC5C,MACJ,KAAM,EACFsE,EAAQnD,aAAa0M,IAAIlB,EAAexD,QAASoE,GACjDjJ,EAAQzC,yBAA0BgG,GAAiB0F,EACnDA,GAAqBZ,EAAexD,QAAQnJ,OAKxD,GAAI2M,EAAetD,YACf,OAAQ0E,GACJ,KAAM,EACFzJ,EAAQlD,gBAAgByM,IAAIlB,EAAetD,YAAamE,GACxDlJ,EAAQxC,6BAA8B+F,GAAiB2F,EACvDA,GAAwBb,EAAetD,YAAYrJ,OACnD,MACJ,KAAM,EACFsE,EAAQjD,iBAAiBwM,IAAIlB,EAAetD,YAAaoE,GACzDnJ,EAAQxC,6BAA8B+F,GAAiB4F,EACvDA,GAAyBd,EAAetD,YAAYrJ,OACpD,MACJ,KAAM,EACFsE,EAAQhD,iBAAiBuM,IAAIlB,EAAetD,YAAaqE,GACzDpJ,EAAQxC,6BAA8B+F,GAAiB6F,EACvDA,GAAyBf,EAAetD,YAAYrJ,OAK5D2M,EAAeqB,mBACf1J,EAAQxD,OAAO+M,IAAIlB,EAAeqB,iBAAkBb,GACpDA,GAAeR,EAAeqB,iBAAiBhO,QAG/C2M,EAAeE,gBACfvI,EAAQvD,IAAI8M,IAAIlB,EAAeE,cAAeO,GAC9CA,GAAYT,EAAeE,cAAc7M,QAG7CiN,GACH,CAEDV,EAAgBqB,EAASjI,IAAMkC,EAC/BA,GACH,CAID,IAAK,IAAI/C,EAAe,EAAGN,EAAc0G,EAAalL,OAAQiO,EAAa,EAAGnJ,EAAeN,EAAaM,IAAgB,CAEtH,MAAMoJ,EAAUhD,EAAapG,GACvBgI,EAAYoB,EAAQpB,UAE1BxI,EAAQ/D,YAAYsN,IAAIf,EAAWmB,GACnC3J,EAAQ7D,uBAAuBqE,GAAgBmJ,EAE/CA,GAAcnB,EAAUC,WAExB,IAAIoB,EAzOmB,EAyOFrJ,EACrBR,EAAQ3D,sBAAsBwN,KAAoBD,EAAQhJ,WAAa,EAAI,EAC3EZ,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ/I,WAAa,EACvEb,EAAQ3D,sBAAsBwN,KAAoBD,EAAQE,MAC1D9J,EAAQ3D,sBAAsBwN,KAAoBD,EAAQG,OAC1D/J,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ9I,WNxK1B,KMyKhCd,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ7I,WNzK1B,KM0KhCf,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ5I,OAASgJ,EACnEhK,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ3I,OAAS+I,EACnEhK,EAAQ3D,sBAAsBwN,KAAoBD,EAAQ1I,OAAS8I,EAEnE9B,EAAe0B,EAAQvI,IAAMb,CAChC,CAID,IAAK,IAAI4B,EAAkB,EAAGjC,EAAiB2G,EAAgBpL,OAAQ2G,EAA8B,EAAGD,EAAkBjC,EAAgBiC,IAAmB,CACzJ,MAAM6H,EAAanD,EAAgB1E,GACnCpC,EAAQ/C,uBAAuBoF,KAAiC4H,EAAWC,aAAehC,EAAe+B,EAAWC,aAAa7I,KAAO,EACxIrB,EAAQ/C,uBAAuBoF,KAAiC4H,EAAWE,yBAA2BjC,EAAe+B,EAAWE,yBAAyB9I,KAAO,EAChKrB,EAAQ/C,uBAAuBoF,KAAiC4H,EAAWG,gBAAkBlC,EAAe+B,EAAWG,gBAAgB/I,KAAO,EAC9IrB,EAAQ/C,uBAAuBoF,KAAiC4H,EAAWI,iBAAmBnC,EAAe+B,EAAWI,iBAAiBhJ,KAAO,EAEhJ8G,EAAkB8B,EAAW5I,IAAMe,CACtC,CAID,IAAIkI,EAAkC,EAClCC,EAAgB,EAChBC,EAAc,EAElB,IAAK,IAAItH,EAAc,EAAGA,EAAc7C,EAAY6C,IAAe,CAE/D,MAAMuH,EAASvD,EAAYhE,GACrBwH,EAAkBD,EAAOxD,OAAOvL,OAEtCsE,EAAQ9B,aAAagF,GAAeuH,EAAOpJ,GAC3CrB,EAAQ7B,wBAAwB+E,GAAesH,EAE/C,IAAK,IAAIlH,EAAY,EAAGA,EAAYoH,EAAiBpH,IAAa,CAE9D,MAAMqH,EAAOF,EAAOxD,OAAO3D,GAE3BtD,EAAQlC,0BAA2BwF,GAAa2E,EAAgB0C,EAAKrB,SAASjI,IAE9ErB,EAAQjC,wBAAyBuF,GAAaiH,EAC9CvK,EAAQnC,SAAS0L,IAAIoB,EAAKxF,OAAQoF,GAClCA,GAAiB,GAEjBvK,EAAQhC,mBAAmBsF,GAAaqH,EAAKV,WAAa9B,EAAkBwC,EAAKV,WAAW5I,KAAO,EAEnGrB,EAAQ/B,2BAA2BqM,KAAsD,IAAhBK,EAAKvF,MAAM,GACpFpF,EAAQ/B,2BAA2BqM,KAAsD,IAAhBK,EAAKvF,MAAM,GACpFpF,EAAQ/B,2BAA2BqM,KAAsD,IAAhBK,EAAKvF,MAAM,GACpFpF,EAAQ/B,2BAA2BqM,KAAqD,IAAfK,EAAKpF,QAC9EvF,EAAQ/B,2BAA2BqM,KAAsD,IAAhBK,EAAKtF,SAC9ErF,EAAQ/B,2BAA2BqM,KAAuD,IAAjBK,EAAKrF,SACjF,CAEDkF,GAAeE,CAClB,CAED,OAAO1K,CACX,CHrQ8B4K,CAAW,CACjCrL,WAAYD,EAAOC,WACnBK,UAAWN,EAAOM,aCH1B,SAAuBjB,GACnB,MAAMkM,EAAY,IAAIzO,YAAYuC,EAASjD,OAAS,GACpDmP,EAAU,GG/BE,GHgCZA,EAAW,GAAKlM,EAASjD,OACzB,IAAIoP,EAAU,EACd,IAAK,IAAIjM,EAAI,EAAGuJ,EAAMzJ,EAASjD,OAAQmD,EAAIuJ,EAAKvJ,IAAK,CACjD,MACMkM,EADUpM,EAASE,GACGnD,OAC5BmP,EAAUhM,EAAI,GAAKkM,EACnBD,GAAWC,CACd,CACD,MAAMC,EAAW,IAAI9O,WAAW2O,EAAUjP,QACpC4C,EAAY,IAAItC,WAAW8O,EAAStP,OAASoP,GACnDtM,EAAU+K,IAAIyB,GACd,IAAIC,EAASD,EAAStP,OACtB,IAAK,IAAImD,EAAI,EAAGuJ,EAAMzJ,EAASjD,OAAQmD,EAAIuJ,EAAKvJ,IAAK,CACjD,MAAMqM,EAAUvM,EAASE,GACzBL,EAAU+K,IAAI2B,EAASD,GACvBA,GAAUC,EAAQxP,MACrB,CACD,OAAO8C,EAAU5C,MACrB,CAxDWuP,CAAwB,CAC3BvF,EAAa/J,SACb+J,EAAa3J,YACb2J,EAAazJ,uBACbyJ,EAAavJ,sBACbuJ,EAAarJ,UACbqJ,EAAapJ,OACboJ,EAAanJ,IACbmJ,EAAajJ,YACbiJ,EAAahJ,aACbgJ,EAAa/I,aACb+I,EAAa9I,gBACb8I,EAAa7I,iBACb6I,EAAa5I,iBACb4I,EAAa3I,uBACb2I,EAAazI,eACbyI,EAAaxI,2BACbwI,EAAavI,wBACbuI,EAAatI,qBACbsI,EAAarI,yBACbqI,EAAapI,6BACboI,EAAanI,yBACbmI,EAAalI,0BACbkI,EAAajI,0BACbiI,EAAahI,kCACbgI,EAAa/H,SACb+H,EAAa9H,0BACb8H,EAAa7H,wBACb6H,EAAa5H,mBACb4H,EAAa3H,2BACb2H,EAAa1H,aACb0H,EAAazH,8BAhCGyH,CDyCxB"}