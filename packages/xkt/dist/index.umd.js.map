{"version":3,"file":"index.umd.js","sources":["../src/inflateXKT.ts","../src/unpackXKT.ts","../../constants/dist/index.es","../src/xktToModel.ts","../src/loadXKT.ts","../src/saveXKT.ts","../src/deflateXKT.ts","../src/modelToXKT.ts","../src/packXKT.ts","../src/XKT_INFO.ts"],"sourcesContent":["import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport type {XKTData} from \"./XKTData\";\nimport * as pako from \"pako\";\n\n/**\n * @private\n */\nexport function inflateXKT(xktDataDeflated: XKTDataDeflated): XKTData {\n\n    function inflate(array:any, options?: any):any {\n        return (array.length === 0) ? [] : (<Uint8Array><unknown>pako.inflate(array, options)).buffer;\n    }\n\n    return <XKTData>{\n        metadata: JSON.parse(pako.inflate(xktDataDeflated.metadata, {to: 'string'})),\n        textureData: new Uint8Array(inflate(xktDataDeflated.textureData)),\n        eachTextureDataPortion: new Uint32Array(inflate(xktDataDeflated.eachTextureDataPortion)),\n        eachTextureAttributes: new Uint16Array(inflate(xktDataDeflated.eachTextureAttributes)),\n        positions: new Uint16Array(inflate(xktDataDeflated.positions)),\n        colors: new Uint8Array(inflate(xktDataDeflated.colors)),\n        uvs: new Float32Array(inflate(xktDataDeflated.uvs)),\n        indices8Bit: new Uint8Array(inflate(xktDataDeflated.indices8Bit)),\n        indices16Bit: new Uint16Array(inflate(xktDataDeflated.indices16Bit)),\n        indices32Bit: new Uint32Array(inflate(xktDataDeflated.indices32Bit)),\n        edgeIndices8Bit: new Uint8Array(inflate(xktDataDeflated.edgeIndices8Bit)),\n        edgeIndices16Bit: new Uint16Array(inflate(xktDataDeflated.edgeIndices16Bit)),\n        edgeIndices32Bit: new Uint32Array(inflate(xktDataDeflated.edgeIndices32Bit)),\n        eachTextureSetTextures: new Int32Array(inflate(xktDataDeflated.eachTextureSetTextures)),\n        decodeMatrices: new Float32Array(inflate(xktDataDeflated.decodeMatrices)),\n        eachBucketPositionsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketPositionsPortion)),\n        eachBucketColorsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketColorsPortion)),\n        eachBucketUVsPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketUVsPortion)),\n        eachBucketIndicesPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketIndicesPortion)),\n        eachBucketEdgeIndicesPortion: new Uint32Array(inflate(xktDataDeflated.eachBucketEdgeIndicesPortion)),\n        eachBucketIndicesBitness: new Uint8Array(inflate(xktDataDeflated.eachBucketIndicesBitness)),\n        eachGeometryPrimitiveType: new Uint8Array(inflate(xktDataDeflated.eachGeometryPrimitiveType)),\n        eachGeometryBucketPortion: new Uint32Array(inflate(xktDataDeflated.eachGeometryBucketPortion)),\n        eachGeometryDecodeMatricesPortion: new Uint32Array(inflate(xktDataDeflated.eachGeometryDecodeMatricesPortion)),\n        matrices: new Float32Array(inflate(xktDataDeflated.matrices)), // Can be -1\n        eachMeshGeometriesPortion: new Uint32Array(inflate(xktDataDeflated.eachMeshGeometriesPortion)),\n        eachMeshMatricesPortion: new Uint32Array(inflate(xktDataDeflated.eachMeshMatricesPortion)),\n        eachMeshTextureSet: new Uint32Array(inflate(xktDataDeflated.eachMeshTextureSet)),\n        eachMeshMaterialAttributes: new Uint8Array(inflate(xktDataDeflated.eachMeshMaterialAttributes)),\n        eachObjectId: JSON.parse(pako.inflate(xktDataDeflated.eachObjectId, {to: 'string'})),\n        eachObjectMeshesPortion: new Uint32Array(inflate(xktDataDeflated.eachObjectMeshesPortion)),\n    };\n}","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\n\n/**\n * @private\n */\nexport function unpackXKT(arrayBuffer: ArrayBuffer): XKTDataDeflated {\n\n    const dataView = new DataView(arrayBuffer);\n    const dataArray = new Uint8Array(arrayBuffer);\n    const xktVersion = dataView.getUint32(0, true);\n    const numElements = dataView.getUint32(4, true);\n\n    const elements = [];\n    let byteOffset = (numElements + 2) * 4;\n    for (let i = 0; i < numElements; i++) {\n        const elementSize = dataView.getUint32((i + 2) * 4, true);\n        elements.push(dataArray.subarray(byteOffset, byteOffset + elementSize));\n        byteOffset += elementSize;\n    }\n\n    let i = 0;\n\n    return <XKTDataDeflated>{\n        metadata: elements[i++],\n        textureData: elements[i++],\n        eachTextureDataPortion: elements[i++],\n        eachTextureAttributes: elements[i++],\n        positions: elements[i++],\n        colors: elements[i++],\n        uvs: elements[i++],\n        indices8Bit: elements[i++],\n        indices16Bit: elements[i++],\n        indices32Bit: elements[i++],\n        edgeIndices8Bit: elements[i++],\n        edgeIndices16Bit: elements[i++],\n        edgeIndices32Bit: elements[i++],\n        eachTextureSetTextures: elements[i++],\n        decodeMatrices: elements[i++],\n        eachBucketPositionsPortion: elements[i++],\n        eachBucketColorsPortion: elements[i++],\n        eachBucketUVsPortion: elements[i++],\n        eachBucketIndicesPortion: elements[i++],\n        eachBucketEdgeIndicesPortion: elements[i++],\n        eachBucketIndicesBitness: elements[i++],\n        eachGeometryPrimitiveType: elements[i++],\n        eachGeometryBucketPortion: elements[i++],\n        eachGeometryDecodeMatricesPortion: elements[i++],\n        matrices: elements[i++],\n        eachMeshGeometriesPortion: elements[i++],\n        eachMeshMatricesPortion: elements[i++],\n        eachMeshTextureSet: elements[i++],\n        eachMeshMaterialAttributes: elements[i++],\n        eachObjectId: elements[i++],\n        eachObjectMeshesPortion: elements[i++]\n    };\n}\n","var e=1e3,r=1001,a=1002,o=1003,p=1004,t=1004,v=1005,x=1005,b=1006,c=1007,d=1007,f=1008,g=1008,h=1009,i=1010,j=1011,k=1012,l=1013,m=1014,n=1015,q=1016,s=1017,u=1018,w=1020,y=1021,z=1022,A=1023,B=1024,C=1025,D=1026,E=1027,F=1028,G=1029,H=1030,I=1031,J=1033,K=33776,L=33777,M=33778,N=33779,O=35840,P=35841,Q=35842,R=35843,S=36196,T=37492,U=37496,V=37808,W=37809,X=37810,Y=37811,Z=37812,$=37813,_=37814,ee=37815,re=37816,ae=37817,oe=37818,pe=37819,te=37820,ve=37821,xe=36492,be=3e3,ce=3001,de=1e4,fe=10001,ge=10002,he=2e4,ie=20001,je=20002,ke=20003,le=20004,me=3e4,ne=300001,qe=4e5,se=400001,ue=400002,we=400003,ye=400004,ze=400005,Ae=5e5,Be=500001,Ce=500002,De=500003;export{y as AlphaFormat,i as ByteType,se as CentimetersUnit,r as ClampToEdgeWrapping,De as CustomProjectionType,D as DepthFormat,E as DepthStencilFormat,ne as FastRender,ye as FeetUnit,n as FloatType,Ce as FrustumProjectionType,de as GIFMediaType,q as HalfFloatType,ze as InchesUnit,l as IntType,fe as JPEGMediaType,be as LinearEncoding,b as LinearFilter,g as LinearMipMapLinearFilter,d as LinearMipMapNearestFilter,f as LinearMipmapLinearFilter,c as LinearMipmapNearestFilter,ie as LinesPrimitive,C as LuminanceAlphaFormat,B as LuminanceFormat,qe as MetersUnit,ue as MillimetersUnit,a as MirroredRepeatWrapping,o as NearestFilter,x as NearestMipMapLinearFilter,p as NearestMipMapNearestFilter,v as NearestMipmapLinearFilter,t as NearestMipmapNearestFilter,Be as OrthoProjectionType,ge as PNGMediaType,Ae as PerspectiveProjectionType,he as PointsPrimitive,me as QualityRender,A as RGBAFormat,J as RGBAIntegerFormat,pe as RGBA_ASTC_10x10_Format,re as RGBA_ASTC_10x5_Format,ae as RGBA_ASTC_10x6_Format,oe as RGBA_ASTC_10x8_Format,te as RGBA_ASTC_12x10_Format,ve as RGBA_ASTC_12x12_Format,V as RGBA_ASTC_4x4_Format,W as RGBA_ASTC_5x4_Format,X as RGBA_ASTC_5x5_Format,Y as RGBA_ASTC_6x5_Format,Z as RGBA_ASTC_6x6_Format,$ as RGBA_ASTC_8x5_Format,_ as RGBA_ASTC_8x6_Format,ee as RGBA_ASTC_8x8_Format,xe as RGBA_BPTC_Format,U as RGBA_ETC2_EAC_Format,R as RGBA_PVRTC_2BPPV1_Format,Q as RGBA_PVRTC_4BPPV1_Format,L as RGBA_S3TC_DXT1_Format,M as RGBA_S3TC_DXT3_Format,N as RGBA_S3TC_DXT5_Format,z as RGBFormat,S as RGB_ETC1_Format,T as RGB_ETC2_Format,P as RGB_PVRTC_2BPPV1_Format,O as RGB_PVRTC_4BPPV1_Format,K as RGB_S3TC_DXT1_Format,H as RGFormat,I as RGIntegerFormat,F as RedFormat,G as RedIntegerFormat,e as RepeatWrapping,j as ShortType,ke as SolidPrimitive,le as SurfacePrimitive,je as TrianglesPrimitive,h as UnsignedByteType,w as UnsignedInt248Type,m as UnsignedIntType,s as UnsignedShort4444Type,u as UnsignedShort5551Type,k as UnsignedShortType,we as YardsUnit,ce as sRGBEncoding};\n//# sourceMappingURL=index.es.map\n","import {JPEGMediaType, LinesPrimitive, PNGMediaType, PointsPrimitive, TrianglesPrimitive} from \"@xeokit/constants\";\nimport type {DataModel, DataModelParams} from \"@xeokit/data\";\nimport type {GeometryBucketParams, GeometryCompressedParams, SceneModel} from \"@xeokit/scene\";\nimport type {XKTData} from \"./XKTData\";\nimport type {FloatArrayParam} from \"@xeokit/math\";\n\nconst NUM_TEXTURE_ATTRIBUTES = 9;\n\n/**\n * @private\n */\nexport function xktToModel(params: {\n    xktData: XKTData,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): void {\n\n    const xktData = params.xktData;\n    const sceneModel = params.sceneModel;\n    const dataModel = params.dataModel;\n\n    if (dataModel) {\n        if (xktData.metadata) {\n            dataModel.fromJSON(<DataModelParams>xktData.metadata);\n        }\n    }\n\n    const numTextures = xktData.eachTextureDataPortion.length;\n    const numTextureSets = xktData.eachTextureSetTextures.length / 5;\n    const numBuckets = xktData.eachBucketPositionsPortion.length;\n    const numMeshes = xktData.eachMeshGeometriesPortion.length;\n    const numObjects = xktData.eachObjectMeshesPortion.length;\n    const numGeometries = xktData.eachGeometryDecodeMatricesPortion.length;\n\n    let nextMeshId = 0;\n\n    const geometryCreated: {\n        [key: string]: boolean\n    } = {};\n\n    // Create textures\n\n    for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {\n\n        const atLastTexture = (textureIndex === (numTextures - 1));\n        const textureDataPortionStart = xktData.eachTextureDataPortion[textureIndex];\n        const textureDataPortionEnd = atLastTexture ? xktData.textureData.length : (xktData.eachTextureDataPortion[textureIndex + 1]);\n        const textureDataPortionSize = textureDataPortionEnd - textureDataPortionStart;\n        const textureDataPortionExists = (textureDataPortionSize > 0);\n        const textureAttrBaseIdx = (textureIndex * NUM_TEXTURE_ATTRIBUTES);\n\n        const compressed = (xktData.eachTextureAttributes[textureAttrBaseIdx] === 1);\n        const mediaType = xktData.eachTextureAttributes[textureAttrBaseIdx + 1];\n        const width = xktData.eachTextureAttributes[textureAttrBaseIdx + 2];\n        const height = xktData.eachTextureAttributes[textureAttrBaseIdx + 3];\n        const minFilter = xktData.eachTextureAttributes[textureAttrBaseIdx + 4];\n        const magFilter = xktData.eachTextureAttributes[textureAttrBaseIdx + 5]; // LinearFilter | NearestFilter\n        const wrapS = xktData.eachTextureAttributes[textureAttrBaseIdx + 6]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        const wrapT = xktData.eachTextureAttributes[textureAttrBaseIdx + 7]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        const wrapR = xktData.eachTextureAttributes[textureAttrBaseIdx + 8]; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n\n        if (textureDataPortionExists) {\n\n            const imageDataSubarray = new Uint8Array(xktData.textureData.subarray(textureDataPortionStart, textureDataPortionEnd));\n            const arrayBuffer = imageDataSubarray.buffer;\n            const textureId = `texture-${textureIndex}`;\n\n            if (compressed) {\n\n                sceneModel.createTexture({\n                    id: textureId,\n                    buffers: [arrayBuffer],\n                    minFilter,\n                    magFilter,\n                    wrapS,\n                    wrapT,\n                    wrapR\n                });\n\n            } else {\n\n                const mimeType = mediaType === JPEGMediaType ? \"image/jpeg\" : (mediaType === PNGMediaType ? \"image/png\" : \"image/gif\");\n                const blob = new Blob([arrayBuffer], {type: mimeType});\n                const urlCreator = window.URL || window.webkitURL;\n                const imageUrl = urlCreator.createObjectURL(blob);\n                const img = document.createElement('img');\n                img.src = imageUrl;\n\n                sceneModel.createTexture({\n                    id: textureId,\n                    image: img,\n                    mediaType,\n                    minFilter,\n                    magFilter,\n                    wrapS,\n                    wrapT,\n                    wrapR\n                });\n            }\n        }\n    }\n\n    // Create texture sets\n\n    for (let textureSetIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {\n\n        const eachTextureSetTexturesIndex = textureSetIndex * 5; // Five textures per set\n        const textureSetId = `textureSet-${textureSetIndex}`;\n        const colorTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex];\n        const metallicRoughnessTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 1];\n        const normalsTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 2];\n        const emissiveTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 3];\n        const occlusionTextureIndex = xktData.eachTextureSetTextures[eachTextureSetTexturesIndex + 4];\n\n        sceneModel.createTextureSet({\n            id: textureSetId,\n            colorTextureId: colorTextureIndex >= 0 ? `texture-${colorTextureIndex}` : undefined,\n            normalsTextureId: normalsTextureIndex >= 0 ? `texture-${normalsTextureIndex}` : undefined,\n            metallicRoughnessTextureId: metallicRoughnessTextureIndex >= 0 ? `texture-${metallicRoughnessTextureIndex}` : undefined,\n            emissiveTextureId: emissiveTextureIndex >= 0 ? `texture-${emissiveTextureIndex}` : undefined,\n            occlusionTextureId: occlusionTextureIndex >= 0 ? `texture-${occlusionTextureIndex}` : undefined\n        });\n    }\n\n    // Iterate objects\n\n    for (let objectIndex = 0; objectIndex <= numObjects; objectIndex++) {\n\n        const objectId = xktData.eachObjectId[objectIndex];\n        const finalObjectIndex = (numObjects - 1);\n        const atLastObject = (objectIndex === finalObjectIndex);\n        const firstMeshIndex = xktData.eachObjectMeshesPortion [objectIndex];\n        const lastMeshIndex = atLastObject ? (xktData.eachMeshGeometriesPortion.length - 1) : (xktData.eachObjectMeshesPortion[objectIndex + 1] - 1);\n\n        const meshIds = [];\n\n        // Iterate each object's meshes\n\n        for (let meshIndex = firstMeshIndex; meshIndex <= lastMeshIndex; meshIndex++) {\n\n            const geometryIndex = xktData.eachMeshGeometriesPortion[meshIndex];\n            const atLastGeometry = (geometryIndex === (numGeometries - 1));\n            const textureSetIndex = xktData.eachMeshTextureSet[meshIndex];\n            const textureSetId = (textureSetIndex >= 0) ? `textureSet-${textureSetIndex}` : undefined;\n\n            const meshColor = decompressColor(xktData.eachMeshMaterialAttributes.subarray((meshIndex * 6), (meshIndex * 6) + 3));\n            const meshOpacity = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 3] / 255.0;\n            const meshMetallic = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 4] / 255.0;\n            const meshRoughness = xktData.eachMeshMaterialAttributes[(meshIndex * 6) + 5] / 255.0;\n\n            const meshId = `mesh-${nextMeshId++}`;\n            const meshMatrixIndex = xktData.eachMeshMatricesPortion[meshIndex];\n            const meshMatrix = xktData.matrices.slice(meshMatrixIndex, meshMatrixIndex + 16);\n\n            const geometryId = `geometry.${geometryIndex}`;\n\n            if (!geometryCreated[geometryId]) {\n\n                const geometryParams = <any>{\n                    geometryBuckets: []\n                };\n\n                geometryParams.primitive = xktData.eachGeometryPrimitiveType[geometryIndex];\n                const geometryDecodeMatrixIndex = xktData.eachGeometryDecodeMatricesPortion[geometryIndex];\n                geometryParams.positionsDecompressMatrix = xktData.eachGeometryDecodeMatricesPortion.slice(geometryDecodeMatrixIndex, geometryDecodeMatrixIndex + 16);\n\n                let geometryValid = false;\n\n                // Iterate each geometry's buckets\n\n                const firstBucketIndex = xktData.eachGeometryBucketPortion[geometryIndex];\n                const atLastBucket = (firstBucketIndex === (numBuckets - 1));\n                const lastBucketIndex = atLastBucket ? (xktData.eachMeshGeometriesPortion.length - 1) : (xktData.eachObjectMeshesPortion[objectIndex + 1] - 1);\n\n                for (let bucketIndex = firstBucketIndex; bucketIndex <= lastBucketIndex; bucketIndex++) {\n\n                    const geometryBucketParams = <GeometryBucketParams>{\n                        positionsCompressed: [],\n                        indices: []\n                    };\n\n                    const geometryIndicesBitness = xktData.eachBucketIndicesBitness[bucketIndex];\n                    const indices = geometryIndicesBitness === 8 ? xktData.indices8Bit : (geometryIndicesBitness === 16 ? xktData.indices16Bit : xktData.indices32Bit);\n                    const edgeIndices = geometryIndicesBitness === 8 ? xktData.edgeIndices8Bit : (geometryIndicesBitness === 16 ? xktData.edgeIndices16Bit : xktData.edgeIndices32Bit);\n\n                    let bucketValid = false;\n\n                    switch (geometryParams.primitive) {\n\n                        case TrianglesPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            //   geometryBucketParams.uvsCompressed = xktData.uvs.subarray(xktData.eachBucketUVsPortion [bucketIndex], atLastBucket ? xktData.uvs.length : xktData.eachBucketUVsPortion [bucketIndex + 1]);\n                            geometryBucketParams.indices = indices.subarray(xktData.eachBucketIndicesPortion [bucketIndex], atLastBucket ? indices.length : xktData.eachBucketIndicesPortion [bucketIndex + 1]);\n                            geometryBucketParams.edgeIndices = edgeIndices.subarray(xktData.eachBucketEdgeIndicesPortion [bucketIndex], atLastBucket ? edgeIndices.length : xktData.eachBucketEdgeIndicesPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0 && geometryBucketParams.indices.length > 0);\n                            break;\n\n                        case PointsPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            // geometryBucketParams.colorsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0);\n                            break;\n\n                        case LinesPrimitive:\n                            geometryBucketParams.positionsCompressed = xktData.positions.subarray(xktData.eachBucketPositionsPortion [bucketIndex], atLastBucket ? xktData.positions.length : xktData.eachBucketPositionsPortion [bucketIndex + 1]);\n                            geometryBucketParams.indices = indices.subarray(xktData.eachBucketIndicesPortion [bucketIndex], atLastBucket ? indices.length : xktData.eachBucketIndicesPortion [bucketIndex + 1]);\n                            bucketValid = (geometryBucketParams.positionsCompressed.length > 0 && geometryBucketParams.indices.length > 0);\n                            break;\n                        default:\n                            continue;\n                    }\n                    if (bucketValid) {\n                        geometryParams.geometryBuckets.push(geometryBucketParams);\n                    }\n                }\n\n                if (geometryParams.geometryBuckets.length > 0) {\n                    sceneModel.createGeometryCompressed(<GeometryCompressedParams>geometryParams);\n                    geometryCreated[geometryId] = true;\n                }\n            }\n\n            sceneModel.createMesh({\n                id: meshId,\n                geometryId,\n                textureSetId,\n                matrix: meshMatrix,\n                color: meshColor,\n                metallic: meshMetallic,\n                roughness: meshRoughness,\n                opacity: meshOpacity\n            });\n            meshIds.push(meshId);\n        }\n\n        if (meshIds.length > 0) {\n            sceneModel.createObject({\n                id: objectId,\n                meshIds: meshIds\n            });\n        }\n    }\n}\n\nconst decompressColor = (function () {\n    const floatColor = new Float32Array(3);\n    return function (intColor: FloatArrayParam) {\n        floatColor[0] = intColor[0] / 255.0;\n        floatColor[1] = intColor[1] / 255.0;\n        floatColor[2] = intColor[2] / 255.0;\n        return floatColor;\n    };\n})();\n\n","import type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport {inflateXKT} from \"./inflateXKT\";\nimport {unpackXKT} from \"./unpackXKT\";\nimport {xktToModel} from \"./xktToModel\";\nimport {SDKError} from \"@xeokit/core\";\n\n/**\n * Imports XKT file data from an ArrayBuffer into a {@link @xeokit/scene!SceneModel | SceneModel}\n * and/or a {@link @xeokit/data!DataModel | DataModel}.\n *\n * * Expects {@link @xeokit/scene!SceneModel.built | SceneModel.built} and\n * {@link @xeokit/scene!SceneModel.destroyed | SceneModel.destroyed} to be ````false````\n * * Expects {@link @xeokit/data!DataModel.built | DataModel.built} and\n * {@link @xeokit/data!DataModel.destroyed | DataModel.destroyed} to be ````false````\n *\n * See {@link @xeokit/xkt} for usage.\n *\n * See {@link XKTData} for insights into the structure of an XKT file.\n *\n * @param params - Loading parameters.\n * @param params.data - XKT file data\n * @param params.sceneModel - SceneModel to load into.\n * @param params.dataModel - Optional DataModel to load into.\n * @returns {Promise} Resolves when XKT has been loaded.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been built.\n */\nexport function loadXKT(params: {\n    data: ArrayBuffer,\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): Promise<any> {\n    if (params.sceneModel.destroyed) {\n        throw new Error(\"SceneModel already destroyed\");\n    }\n    if (params.sceneModel.built) {\n        throw new SDKError(\"SceneModel already built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new SDKError(\"DataModel already destroyed\");\n        }\n        if (params.dataModel.built) {\n            throw new SDKError(\"DataModel already built\");\n        }\n    }\n    return new Promise<void>(function (resolve, reject) {\n        xktToModel({\n            xktData: inflateXKT(unpackXKT(params.data)),\n            sceneModel: params.sceneModel,\n            dataModel: params.dataModel\n        });\n        resolve();\n    });\n}\n","import type {DataModel} from \"@xeokit/data\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport {deflateXKT} from \"./deflateXKT\";\nimport {modelToXKT} from \"./modelToXKT\";\nimport {packXKT} from \"./packXKT\";\nimport {SDKError} from \"@xeokit/core\";\n\n\n/**\n * Exports a {@link @xeokit/scene!SceneModel | SceneModel} and/or a {@link @xeokit/data!DataModel} to an ArrayBuffer\n * containing XKT file data.\n *\n * See {@link @xeokit/xkt} for usage.\n *\n * See {@link XKTData} for insights into the structure of an XKT file.\n *\n * @param params\n * @param params.sceneModel - The SceneModel to export to XKT.\n * @param params.dataModel - Optional DataModel to export to XKT.\n * @returns The XKT file data in an ArrayBuffer.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the SceneModel has not yet been built.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has already been destroyed.\n * @returns {@link @xeokit/core!SDKError} If the DataModel has not yet been built.\n */\nexport function saveXKT(params: {\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): ArrayBuffer {\n    if (params.sceneModel.destroyed) {\n        throw new SDKError(\"SceneModel already destroyed\");\n    }\n    if (!params.sceneModel.built) {\n        throw new SDKError(\"SceneModel not yet built\");\n    }\n    if (params.dataModel) {\n        if (params.dataModel.destroyed) {\n            throw new SDKError(\"DataModel already destroyed\");\n        }\n        if (!params.dataModel.built) {\n            throw new SDKError(\"DataModel not yet built\");\n        }\n    }\n    return packXKT(deflateXKT(modelToXKT({\n        sceneModel: params.sceneModel,\n        dataModel: params.dataModel\n    })));\n}","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport type {XKTData} from \"./XKTData\";\nimport * as pako from \"pako\";\n\n/**\n * @private\n */\nexport function deflateXKT(xktData: XKTData, metaModelJSON?: any): XKTDataDeflated {\n    let metaModelBytes;\n    if (metaModelJSON) {\n        const deflatedJSON = deflateJSON(metaModelJSON);\n        metaModelBytes = pako.deflate(deflatedJSON)\n    } else {\n        const deflatedJSON = deflateJSON([\"{}\"]);\n        metaModelBytes = pako.deflate(deflatedJSON)\n    }\n    return <XKTDataDeflated>{\n        metadata: metaModelBytes,\n        textureData: pako.deflate(xktData.textureData.buffer),\n        eachTextureDataPortion: pako.deflate(xktData.eachTextureDataPortion.buffer),\n        eachTextureAttributes: pako.deflate(xktData.eachTextureAttributes.buffer),\n        positions: pako.deflate(xktData.positions.buffer),\n        colors: pako.deflate(xktData.colors.buffer),\n        uvs: pako.deflate(xktData.uvs.buffer),\n        indices8Bit: pako.deflate(xktData.indices8Bit.buffer),\n        indices16Bit: pako.deflate(xktData.indices16Bit.buffer),\n        indices32Bit: pako.deflate(xktData.indices32Bit.buffer),\n        edgeIndices8Bit: pako.deflate(xktData.edgeIndices8Bit.buffer),\n        edgeIndices16Bit: pako.deflate(xktData.edgeIndices16Bit.buffer),\n        edgeIndices32Bit: pako.deflate(xktData.edgeIndices32Bit.buffer),\n        eachTextureSetTextures: pako.deflate(xktData.eachTextureSetTextures.buffer),\n        decodeMatrices: pako.deflate(xktData.decodeMatrices.buffer),\n        eachBucketPositionsPortion: pako.deflate(xktData.eachBucketPositionsPortion.buffer),\n        eachBucketColorsPortion: pako.deflate(xktData.eachBucketColorsPortion.buffer),\n        eachBucketUVsPortion: pako.deflate(xktData.eachBucketUVsPortion.buffer),\n        eachBucketIndicesPortion: pako.deflate(xktData.eachBucketIndicesPortion.buffer),\n        eachBucketEdgeIndicesPortion: pako.deflate(xktData.eachBucketEdgeIndicesPortion.buffer),\n        eachBucketIndicesBitness: pako.deflate(xktData.eachBucketIndicesBitness.buffer),\n        eachGeometryPrimitiveType: pako.deflate(xktData.eachGeometryPrimitiveType.buffer),\n        eachGeometryBucketPortion: pako.deflate(xktData.eachGeometryBucketPortion.buffer),\n        eachGeometryDecodeMatricesPortion: pako.deflate(xktData.eachGeometryDecodeMatricesPortion.buffer),\n        matrices: pako.deflate(xktData.matrices.buffer),\n        eachMeshGeometriesPortion: pako.deflate(xktData.eachMeshGeometriesPortion.buffer),\n        eachMeshMatricesPortion: pako.deflate(xktData.eachMeshMatricesPortion.buffer),\n        eachMeshTextureSet: pako.deflate(xktData.eachMeshTextureSet.buffer),\n        eachMeshMaterialAttributes: pako.deflate(xktData.eachMeshMaterialAttributes.buffer),\n        eachObjectId: pako.deflate(JSON.stringify(xktData.eachObjectId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachObjectMeshesPortion: pako.deflate(xktData.eachObjectMeshesPortion.buffer)\n    };\n}\n\nfunction deflateJSON(strings: string[]): string {\n    return JSON.stringify(strings)\n        .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n            return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n        });\n}\n","import {XKT_INFO} from \"./XKT_INFO\";\nimport type {XKTData} from \"./XKTData\";\nimport type {SceneModel} from \"@xeokit/scene\";\nimport type {DataModel} from \"@xeokit/data\";\nimport {ClampToEdgeWrapping, LinearMipmapLinearFilter} from \"@xeokit/constants\";\n\nconst XKT_VERSION = XKT_INFO.xktVersion;\nconst NUM_TEXTURE_ATTRIBUTES = 9;\nconst NUM_MATERIAL_ATTRIBUTES = 6;\n\n/**\n * @private\n */\nexport function modelToXKT(params: {\n    sceneModel: SceneModel,\n    dataModel?: DataModel\n}): XKTData {\n\n    const sceneModel = params.sceneModel;\n    const dataModel = params.dataModel;\n\n    const geometriesList = Object.values(sceneModel.geometries);\n    const texturesList = Object.values(sceneModel.textures);\n    const textureSetsList = Object.values(sceneModel.textureSets);\n    const meshesList = Object.values(sceneModel.meshes);\n    const objectsList = Object.values(sceneModel.objects);\n\n    const numGeometries = geometriesList.length;\n    const numTextures = texturesList.length;\n    const numTextureSets = textureSetsList.length;\n    const numMeshes = meshesList.length;\n    const numObjects = objectsList.length;\n\n    let lenBuckets = 0;\n    let lenPositions = 0;\n    let lenColors = 0;\n    let lenUVs = 0;\n    let lenIndices8Bit = 0;\n    let lenIndices16Bit = 0;\n    let lenIndices32Bit = 0;\n    let lenEdgeIndices8Bit = 0;\n    let lenEdgeIndices16Bit = 0;\n    let lenEdgeIndices32Bit = 0;\n    let lenMatrices = 0;\n    let lenTextures = 0;\n    let lenDecodeMatrices = 0;\n\n    const geometryIndices: { [key: string]: number } = {};\n    const textureIndices: { [key: string]: number } = {};\n    const textureSetIndices: { [key: string]: number } = {};\n    const meshIndices: { [key: string]: number } = {};\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        const geometryBuckets = geometry.geometryBuckets;\n        lenBuckets += geometryBuckets.length;\n        for (let i = 0, len = geometryBuckets.length; i < len; i++) {\n            const geometryBucket = geometryBuckets[i];\n            if (geometryBucket.positionsCompressed) {\n                const numPositions = geometryBucket.positionsCompressed.length / 3;\n                lenPositions += geometryBucket.positionsCompressed.length;\n                if (geometryBucket.indices) {\n                    if (numPositions <= (1 << 8)) {\n                        lenIndices8Bit += geometryBucket.indices.length;\n                    } else if (numPositions <= (1 << 16)) {\n                        lenIndices16Bit += geometryBucket.indices.length;\n                    } else {\n                        lenIndices32Bit += geometryBucket.indices.length;\n                    }\n                }\n                if (geometryBucket.edgeIndices) {\n                    if (numPositions <= (1 << 8)) {\n                        lenEdgeIndices8Bit += geometryBucket.edgeIndices.length;\n                    } else if (numPositions <= (1 << 16)) {\n                        lenEdgeIndices16Bit += geometryBucket.edgeIndices.length;\n                    } else {\n                        lenEdgeIndices32Bit += geometryBucket.edgeIndices.length;\n                    }\n                }\n                if (geometryBucket.uvsCompressed) {\n                    lenUVs += geometryBucket.uvsCompressed.length;\n                }\n            }\n        }\n    }\n\n    for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {\n        const texture = texturesList[textureIndex];\n        const imageData = texture.imageData;\n        lenTextures += imageData.byteLength;\n    }\n\n    lenDecodeMatrices = numGeometries * 16;\n\n    const xktData: XKTData = {\n        metadata: dataModel ? dataModel.getJSON() : {},\n        textureData: new Uint8Array(lenTextures), // All textures\n        eachTextureDataPortion: new Uint32Array(numTextures), // For each texture, an index to its first element in textureData\n        eachTextureAttributes: new Uint16Array(numTextures * NUM_TEXTURE_ATTRIBUTES),\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        colors: new Uint8Array(lenColors),\n        uvs: new Float32Array(lenUVs),\n        indices8Bit: new Uint8Array(lenIndices8Bit),\n        indices16Bit: new Uint16Array(lenIndices16Bit),\n        indices32Bit: new Uint32Array(lenIndices32Bit),\n        edgeIndices8Bit: new Uint8Array(lenEdgeIndices8Bit),\n        edgeIndices16Bit: new Uint16Array(lenEdgeIndices16Bit),\n        edgeIndices32Bit: new Uint32Array(lenEdgeIndices32Bit),\n        eachTextureSetTextures: new Int32Array(numTextureSets * 5), // For each texture set, a set of five Texture indices [color, metal/roughness,normals,emissive,occlusion]; each index has value -1 if no texture\n        decodeMatrices: new Float32Array(lenDecodeMatrices), // TODO\n        eachBucketPositionsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.positions. Every primitive type has positions.\n        eachBucketColorsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.colors. If the next geometry has the same index, then this geometry has no colors.\n        eachBucketUVsPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.uvs. If the next geometry has the same index, then this geometry has no UVs.\n        eachBucketIndicesPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.indices. If the next geometry has the same index, then this geometry has no indices.\n        eachBucketEdgeIndicesPortion: new Uint32Array(lenBuckets), // For each geometry, an index to its first element in xktData.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.\n        eachBucketIndicesBitness: new Uint8Array(lenBuckets), // TODO\n        eachGeometryPrimitiveType: new Uint8Array(numGeometries), // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points)\n        eachGeometryBucketPortion: new Uint32Array(numGeometries), // TODO\n        eachGeometryDecodeMatricesPortion: new Uint32Array(numGeometries), // Positions dequantization matrices\n        matrices: new Float32Array(lenMatrices), // Modeling matrices\n        eachMeshGeometriesPortion: new Uint32Array(numMeshes), // For each mesh, an index into the eachGeometry* arrays\n        eachMeshMatricesPortion: new Uint32Array(numMeshes), // For each mesh that shares its geometry, an index to its first element in xktData.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.\n        eachMeshTextureSet: new Uint32Array(numMeshes), // For each mesh, the index of its texture set in xktData.eachTextureSetTextures; this array contains signed integers so that we can use -1 to indicate when a mesh has no texture set\n        eachMeshMaterialAttributes: new Uint8Array(numMeshes * NUM_MATERIAL_ATTRIBUTES), // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]\n        eachObjectId: [], // For each object, an ID string\n        eachObjectMeshesPortion: new Uint32Array(numObjects) // For each object, the index of the first element of meshes used by the object\n    };\n\n    let countBuckets = 0;\n    let countPositions = 0;\n    let countColors = 0;\n    let countUVs = 0;\n    let countIndices8Bit = 0;\n    let countIndices16Bit = 0;\n    let countIndices32Bit = 0;\n    let countEdgeIndices8Bit = 0;\n    let countEdgeIndices16Bit = 0;\n    let countEdgeIndices32Bit = 0;\n    let countDecodeMatrices = 0;\n\n    // Geometries and buckets\n\n    let geometryIndex = 0;\n\n    for (let geometryId in sceneModel.geometries) {\n\n        const geometry = sceneModel.geometries[geometryId];\n        const geometryBuckets = geometry.geometryBuckets;\n\n        xktData.eachGeometryPrimitiveType [geometryIndex] = geometry.primitive;\n        xktData.eachGeometryBucketPortion [geometryIndex] = countBuckets;\n        xktData.eachGeometryDecodeMatricesPortion [geometryIndex] = countDecodeMatrices;\n\n        xktData.decodeMatrices.set(geometry.positionsDecompressMatrix, countDecodeMatrices); // TODO: only add decode matrix if different from what's already added\n        countDecodeMatrices += 16;\n\n        for (let i = 0, len = geometryBuckets.length; i < len; i++) {\n\n            const geometryBucket = geometryBuckets[i];\n            const lenBucketPositions = geometryBucket.positionsCompressed.length;\n            const numBucketPositions = lenBucketPositions / 3;\n            const bucketIndicesBitness: number = (numBucketPositions <= (1 << 8)) ? 0 : ((numBucketPositions <= (1 << 16)) ? 1 : 2);\n\n            xktData.eachBucketPositionsPortion [countBuckets] = countPositions;\n            xktData.eachBucketColorsPortion [countBuckets] = countColors;\n            xktData.eachBucketUVsPortion [countBuckets] = countUVs;\n            xktData.eachBucketIndicesBitness [countBuckets] = bucketIndicesBitness;\n\n            xktData.positions.set(geometryBucket.positionsCompressed, countPositions);\n            countPositions += geometryBucket.positionsCompressed.length;\n\n            if (geometryBucket.indices) {\n                switch (bucketIndicesBitness) {\n                    case 0:\n                        xktData.indices8Bit.set(geometryBucket.indices, countIndices8Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices8Bit;\n                        countIndices8Bit += geometryBucket.indices.length;\n                        break;\n                    case 1:\n                        xktData.indices16Bit.set(geometryBucket.indices, countIndices16Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices16Bit;\n                        countIndices16Bit += geometryBucket.indices.length;\n                        break;\n                    case 2:\n                        xktData.indices32Bit.set(geometryBucket.indices, countIndices32Bit);\n                        xktData.eachBucketIndicesPortion [geometryIndex] = countIndices32Bit;\n                        countIndices32Bit += geometryBucket.indices.length;\n                        break;\n                }\n            }\n\n            if (geometryBucket.edgeIndices) {\n                switch (bucketIndicesBitness) {\n                    case 0:\n                        xktData.edgeIndices8Bit.set(geometryBucket.edgeIndices, countEdgeIndices8Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices8Bit;\n                        countEdgeIndices8Bit += geometryBucket.edgeIndices.length;\n                        break;\n                    case 1:\n                        xktData.edgeIndices16Bit.set(geometryBucket.edgeIndices, countEdgeIndices16Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices16Bit;\n                        countEdgeIndices16Bit += geometryBucket.edgeIndices.length;\n                        break;\n                    case 2:\n                        xktData.edgeIndices32Bit.set(geometryBucket.edgeIndices, countEdgeIndices32Bit);\n                        xktData.eachBucketEdgeIndicesPortion [geometryIndex] = countEdgeIndices32Bit;\n                        countEdgeIndices32Bit += geometryBucket.edgeIndices.length;\n                        break;\n                }\n            }\n\n            if (geometryBucket.colorsCompressed) {\n                xktData.colors.set(geometryBucket.colorsCompressed, countColors);\n                countColors += geometryBucket.colorsCompressed.length;\n            }\n\n            if (geometryBucket.uvsCompressed) {\n                xktData.uvs.set(geometryBucket.uvsCompressed, countUVs);\n                countUVs += geometryBucket.uvsCompressed.length;\n            }\n\n            countBuckets++;\n        }\n\n        geometryIndices[geometry.id] = geometryIndex;\n        geometryIndex++;\n    }\n\n    // Textures\n\n    for (let textureIndex = 0, numTextures = texturesList.length, portionIdx = 0; textureIndex < numTextures; textureIndex++) {\n\n        const texture = texturesList[textureIndex];\n        const imageData = texture.imageData;\n\n        xktData.textureData.set(imageData, portionIdx);\n        xktData.eachTextureDataPortion[textureIndex] = portionIdx;\n\n        portionIdx += imageData.byteLength;\n\n        let textureAttrIdx = textureIndex * NUM_TEXTURE_ATTRIBUTES;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.compressed ? 1 : 0;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.mediaType || 0; // GIFMediaType | PNGMediaType | JPEGMediaType\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.width;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.height;\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.minFilter || LinearMipmapLinearFilter; // LinearMipmapLinearFilter | LinearMipMapNearestFilter | NearestMipMapNearestFilter | NearestMipMapLinearFilter | LinearMipMapLinearFilter\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.magFilter || LinearMipmapLinearFilter; // LinearFilter | NearestFilter\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapS || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapT || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        xktData.eachTextureAttributes[textureAttrIdx++] = texture.wrapR || ClampToEdgeWrapping; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n\n        textureIndices[texture.id] = textureIndex;\n    }\n\n    // Texture sets\n\n    for (let textureSetIndex = 0, numTextureSets = textureSetsList.length, eachTextureSetTexturesIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {\n        const textureSet = textureSetsList[textureSetIndex];\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.colorTexture ? textureIndices[textureSet.colorTexture.id] : -1; // Color map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.metallicRoughnessTexture ? textureIndices[textureSet.metallicRoughnessTexture.id] : -1; // Metal/rough map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.emissiveTexture ? textureIndices[textureSet.emissiveTexture.id] : -1; // Emissive map\n        xktData.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.occlusionTexture ? textureIndices[textureSet.occlusionTexture.id] : -1; // Occlusion map\n\n        textureSetIndices[textureSet.id] = textureSetIndex;\n    }\n\n    // Meshes and objects\n\n    let eachMeshMaterialAttributesIndex = 0;\n    let matricesIndex = 0;\n    let countMeshes = 0;\n\n    for (let objectIndex = 0; objectIndex < numObjects; objectIndex++) {\n\n        const object = objectsList[objectIndex];\n        const numObjectMeshes = object.meshes.length;\n\n        xktData.eachObjectId[objectIndex] = object.id;\n        xktData.eachObjectMeshesPortion[objectIndex] = countMeshes;\n\n        for (let meshIndex = 0; meshIndex < numObjectMeshes; meshIndex++) {\n\n            const mesh = object.meshes[meshIndex];\n\n            xktData.eachMeshGeometriesPortion [meshIndex] = geometryIndices[mesh.geometry.id];\n\n            xktData.eachMeshMatricesPortion [meshIndex] = matricesIndex;\n            xktData.matrices.set(mesh.matrix, matricesIndex); // TODO: only add matrix if different from what's already added\n            matricesIndex += 16;\n\n            xktData.eachMeshTextureSet[meshIndex] = mesh.textureSet ? textureSetIndices[mesh.textureSet.id] : -1;\n\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[0] * 255); // Color RGB\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[1] * 255);\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[2] * 255);\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.opacity * 255); // Opacity\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.metallic * 255); // Metallic\n            xktData.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.roughness * 255); // Roughness\n        }\n\n        countMeshes += numObjectMeshes;\n    }\n\n    return xktData;\n}\n","import type {XKTDataDeflated} from \"./XKTDataDeflated\";\nimport {XKT_INFO} from \"./XKT_INFO\";\n\n/**\n * @private\n */\nexport function packXKT(deflatedData: XKTDataDeflated): ArrayBuffer {\n    return toArrayBuffer(<Buffer[]>[\n        deflatedData.metadata,\n        deflatedData.textureData,\n        deflatedData.eachTextureDataPortion,\n        deflatedData.eachTextureAttributes,\n        deflatedData.positions,\n        deflatedData.colors,\n        deflatedData.uvs,\n        deflatedData.indices8Bit,\n        deflatedData.indices16Bit,\n        deflatedData.indices32Bit,\n        deflatedData.edgeIndices8Bit,\n        deflatedData.edgeIndices16Bit,\n        deflatedData.edgeIndices32Bit,\n        deflatedData.eachTextureSetTextures,\n        deflatedData.decodeMatrices,\n        deflatedData.eachBucketPositionsPortion,\n        deflatedData.eachBucketColorsPortion,\n        deflatedData.eachBucketUVsPortion,\n        deflatedData.eachBucketIndicesPortion,\n        deflatedData.eachBucketEdgeIndicesPortion,\n        deflatedData.eachBucketIndicesBitness,\n        deflatedData.eachGeometryPrimitiveType,\n        deflatedData.eachGeometryBucketPortion,\n        deflatedData.eachGeometryDecodeMatricesPortion,\n        deflatedData.matrices,\n        deflatedData.eachMeshGeometriesPortion,\n        deflatedData.eachMeshMatricesPortion,\n        deflatedData.eachMeshTextureSet,\n        deflatedData.eachMeshMaterialAttributes,\n        deflatedData.eachObjectId,\n        deflatedData.eachObjectMeshesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements: Buffer[]): ArrayBuffer {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = XKT_INFO.xktVersion;\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    let offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    return dataArray.buffer;\n}","/**\n * Provides info on the XKT generated by xeokit-convert.\n *\n * See {@link @xeokit/xkt} for usage.\n */\nexport const XKT_INFO = {\n\n    /**\n     * The XKT version generated by xeokit-convert.\n     *\n     * @property xktVersion\n     * @type {number}\n     */\n    xktVersion: 11\n};"],"names":["inflateXKT","xktDataDeflated","inflate","array","options","length","pako","buffer","metadata","JSON","parse","to","textureData","Uint8Array","eachTextureDataPortion","Uint32Array","eachTextureAttributes","Uint16Array","positions","colors","uvs","Float32Array","indices8Bit","indices16Bit","indices32Bit","edgeIndices8Bit","edgeIndices16Bit","edgeIndices32Bit","eachTextureSetTextures","Int32Array","decodeMatrices","eachBucketPositionsPortion","eachBucketColorsPortion","eachBucketUVsPortion","eachBucketIndicesPortion","eachBucketEdgeIndicesPortion","eachBucketIndicesBitness","eachGeometryPrimitiveType","eachGeometryBucketPortion","eachGeometryDecodeMatricesPortion","matrices","eachMeshGeometriesPortion","eachMeshMatricesPortion","eachMeshTextureSet","eachMeshMaterialAttributes","eachObjectId","eachObjectMeshesPortion","unpackXKT","arrayBuffer","dataView","DataView","dataArray","getUint32","numElements","elements","byteOffset","i","elementSize","push","subarray","r","floatColor","decompressColor","intColor","params","sceneModel","destroyed","Error","built","SDKError","dataModel","Promise","resolve","reject","xktData","fromJSON","numTextures","numTextureSets","numBuckets","numObjects","nextMeshId","geometryCreated","textureIndex","textureDataPortionStart","textureDataPortionEnd","textureAttrBaseIdx","compressed","mediaType","minFilter","magFilter","wrapS","wrapT","wrapR","textureId","createTexture","id","buffers","blob","Blob","type","imageUrl","window","URL","webkitURL","createObjectURL","img","document","createElement","src","image","textureSetIndex","eachTextureSetTexturesIndex","colorTextureIndex","metallicRoughnessTextureIndex","normalsTextureIndex","emissiveTextureIndex","occlusionTextureIndex","createTextureSet","colorTextureId","undefined","normalsTextureId","metallicRoughnessTextureId","emissiveTextureId","occlusionTextureId","objectIndex","objectId","lastMeshIndex","meshIds","meshIndex","geometryIndex","textureSetId","meshColor","meshOpacity","meshMetallic","meshRoughness","meshId","meshMatrixIndex","meshMatrix","slice","geometryId","geometryParams","geometryBuckets","primitive","geometryDecodeMatrixIndex","positionsDecompressMatrix","firstBucketIndex","atLastBucket","lastBucketIndex","bucketIndex","geometryBucketParams","positionsCompressed","indices","geometryIndicesBitness","edgeIndices","bucketValid","createGeometryCompressed","createMesh","matrix","color","metallic","roughness","opacity","createObject","xktToModel","data","lenDecodeMatrices","geometriesList","Object","values","geometries","texturesList","textures","textureSetsList","textureSets","meshesList","meshes","objectsList","objects","numGeometries","numMeshes","lenBuckets","lenPositions","lenUVs","lenIndices8Bit","lenIndices16Bit","lenIndices32Bit","lenEdgeIndices8Bit","lenEdgeIndices16Bit","lenEdgeIndices32Bit","lenTextures","geometryIndices","textureIndices","textureSetIndices","len","geometryBucket","numPositions","uvsCompressed","imageData","byteLength","getJSON","countBuckets","countPositions","countColors","countUVs","countIndices8Bit","countIndices16Bit","countIndices32Bit","countEdgeIndices8Bit","countEdgeIndices16Bit","countEdgeIndices32Bit","countDecodeMatrices","geometry","set","numBucketPositions","bucketIndicesBitness","colorsCompressed","portionIdx","texture","textureAttrIdx","width","height","ClampToEdgeWrapping","textureSet","colorTexture","metallicRoughnessTexture","emissiveTexture","occlusionTexture","eachMeshMaterialAttributesIndex","matricesIndex","countMeshes","object","numObjectMeshes","mesh","modelToXKT","deflatedJSON","stringify","replace","chr","charCodeAt","toString","substr","indexData","dataLen","elementsize","indexBuf","offset","element","toArrayBuffer","deflatedData","deflate"],"mappings":"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"}