{"version":3,"file":"index.js","sources":["../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js","../../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js","../../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js","../../../node_modules/@loaders.gl/textures/dist/esm/ktx2-basis-writer.js","../../../node_modules/@loaders.gl/textures/dist/esm/lib/encoders/encode-ktx2-basis-texture.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js","../../../node_modules/@loaders.gl/images/dist/esm/image-loader.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js","../../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","../../constants/dist/index.es","../../boundaries/src/index.ts","../src/GeometryBucket.ts","../src/Geometry.ts","../src/getSceneObjectGeometry.ts","../src/SceneObject.ts","../src/TextureSet.ts","../src/Texture.ts","../src/Mesh.ts","../src/buildEdgeIndices.ts","../src/calculateUniquePositions.ts","../src/rebucketPositions.ts","../src/compressGeometryParams.ts","../../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","../../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","../../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","../../../node_modules/@probe.gl/env/dist/esm/lib/globals.js","../../../node_modules/@probe.gl/env/dist/esm/utils/globals.js","../../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","../../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js","../../../node_modules/@probe.gl/log/dist/esm/utils/color.js","../../../node_modules/@probe.gl/log/dist/esm/utils/assert.js","../../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js","../../../node_modules/@probe.gl/log/dist/esm/log.js","../../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js","../../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js","../../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js","../../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js","../../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js","../../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","../../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js","../../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","../src/SceneModel.ts","../../../node_modules/@loaders.gl/core/dist/esm/lib/api/load.js","../src/Scene.ts"],"sourcesContent":["\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map","\n\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\nconst self_ = globals.self || globals.window || globals.global || {};\nconst window_ = globals.window || globals.self || globals.global || {};\nconst global_ = globals.global || globals.self || globals.window || {};\nconst document_ = globals.document || {};\nexport { self_ as self, window_ as window, global_ as global, document_ as document };\n\nexport const isBrowser =\nBoolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\n\nexport const isWorker = typeof importScripts === 'function';\n\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nexport const nodeVersion = matches && parseFloat(matches[1]) || 0;\n//# sourceMappingURL=globals.js.map","\n\nexport function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map","\n\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\nconst self_ = globals.self || globals.window || globals.global || {};\nconst window_ = globals.window || globals.self || globals.global || {};\nconst global_ = globals.global || globals.self || globals.window || {};\nconst document_ = globals.document || {};\nexport { self_ as self, window_ as window, global_ as global, document_ as document };\n\nexport const isBrowser =\ntypeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\nexport const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\nexport const nodeVersion = matches && parseFloat(matches[1]) || 0;\n//# sourceMappingURL=globals.js.map","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../env-utils/assert';\n\nexport default class WorkerJob {\n\n  constructor(jobName, workerThread) {\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"workerThread\", void 0);\n    _defineProperty(this, \"isRunning\", true);\n    _defineProperty(this, \"result\", void 0);\n    _defineProperty(this, \"_resolve\", () => {});\n    _defineProperty(this, \"_reject\", () => {});\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  postMessage(type, payload) {\n    this.workerThread.postMessage({\n      source: 'loaders.gl',\n      type,\n      payload\n    });\n  }\n\n  done(value) {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  error(error) {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n//# sourceMappingURL=worker-job.js.map","\nexport class Worker {\n  terminate() {}\n}\nexport { Worker as NodeWorker };\nexport { Worker as NodeWorkerType };\nexport const parentPort = null;\n//# sourceMappingURL=worker_threads-browser.js.map","import { assert } from '../env-utils/assert';\nconst workerURLCache = new Map();\n\nexport function getLoadableWorkerURL(props) {\n  assert(props.source && !props.url || !props.source && props.url);\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n  assert(workerURL);\n  return workerURL;\n}\n\nfunction getLoadableWorkerURLFromURL(url) {\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\nfunction getLoadableWorkerURLFromSource(workerSource) {\n  const blob = new Blob([workerSource], {\n    type: 'application/javascript'\n  });\n  return URL.createObjectURL(blob);\n}\n\nfunction buildScriptSource(workerUrl) {\n  return \"try {\\n  importScripts('\".concat(workerUrl, \"');\\n} catch (error) {\\n  console.error(error);\\n  throw error;\\n}\");\n}\n//# sourceMappingURL=get-loadable-worker-url.js.map","\n\nexport function getTransferList(object) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let transfers = arguments.length > 2 ? arguments[2] : undefined;\n  const transfersSet = transfers || new Set();\n  if (!object) {\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\nexport function getTransferListForWriter(object) {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n  Object.keys(clone).forEach(key => {\n    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n  return clone;\n}\n//# sourceMappingURL=get-transfer-list.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nimport { NodeWorker } from '../node/worker_threads';\nimport { isBrowser } from '../env-utils/globals';\nimport { assert } from '../env-utils/assert';\nimport { getLoadableWorkerURL } from '../worker-utils/get-loadable-worker-url';\nimport { getTransferList } from '../worker-utils/get-transfer-list';\nconst NOOP = () => {};\nexport default class WorkerThread {\n  static isSupported() {\n    return typeof Worker !== 'undefined' && isBrowser || typeof NodeWorker !== 'undefined' && !isBrowser;\n  }\n  constructor(props) {\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"source\", void 0);\n    _defineProperty(this, \"url\", void 0);\n    _defineProperty(this, \"terminated\", false);\n    _defineProperty(this, \"worker\", void 0);\n    _defineProperty(this, \"onMessage\", void 0);\n    _defineProperty(this, \"onError\", void 0);\n    _defineProperty(this, \"_loadableURL\", '');\n    const {\n      name,\n      source,\n      url\n    } = props;\n    assert(source || url);\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = error => console.log(error);\n\n    this.worker = isBrowser ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  destroy() {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    this.worker.terminate();\n    this.terminated = true;\n  }\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  postMessage(data, transferList) {\n    transferList = transferList || getTransferList(data);\n    this.worker.postMessage(data, transferList);\n  }\n\n  _getErrorFromErrorEvent(event) {\n    let message = 'Failed to load ';\n    message += \"worker \".concat(this.name, \" from \").concat(this.url, \". \");\n    if (event.message) {\n      message += \"\".concat(event.message, \" in \");\n    }\n    if (event.lineno) {\n      message += \":\".concat(event.lineno, \":\").concat(event.colno);\n    }\n    return new Error(message);\n  }\n\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({\n      source: this.source,\n      url: this.url\n    });\n    const worker = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    worker.onmessage = event => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    worker.onerror = error => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    worker.onmessageerror = event => console.error(event);\n\n    return worker;\n  }\n\n  _createNodeWorker() {\n    let worker;\n    if (this.url) {\n      const absolute = this.url.includes(':/') || this.url.startsWith('/');\n      const url = absolute ? this.url : \"./\".concat(this.url);\n      worker = new NodeWorker(url, {\n        eval: false\n      });\n    } else if (this.source) {\n      worker = new NodeWorker(this.source, {\n        eval: true\n      });\n    } else {\n      throw new Error('no worker');\n    }\n    worker.on('message', data => {\n      this.onMessage(data);\n    });\n    worker.on('error', error => {\n      this.onError(error);\n    });\n    worker.on('exit', code => {\n    });\n    return worker;\n  }\n}\n//# sourceMappingURL=worker-thread.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isMobile } from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\nexport default class WorkerPool {\n\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n\n  constructor(props) {\n    _defineProperty(this, \"name\", 'unnamed');\n    _defineProperty(this, \"source\", void 0);\n    _defineProperty(this, \"url\", void 0);\n    _defineProperty(this, \"maxConcurrency\", 1);\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n    _defineProperty(this, \"onDebug\", () => {});\n    _defineProperty(this, \"reuseWorkers\", true);\n    _defineProperty(this, \"props\", {});\n    _defineProperty(this, \"jobQueue\", []);\n    _defineProperty(this, \"idleQueue\", []);\n    _defineProperty(this, \"count\", 0);\n    _defineProperty(this, \"isDestroyed\", false);\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n  async startJob(name) {\n    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);\n    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);\n    const startPromise = new Promise(onStart => {\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n    this._startQueuedJob();\n    return await startPromise;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = error => queuedJob.onError(job, error);\n\n      queuedJob.onStart(job);\n\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n    if (!this.isDestroyed) {\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n//# sourceMappingURL=worker-pool.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\nconst DEFAULT_PROPS = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: true,\n  onDebug: () => {}\n};\n\nexport default class WorkerFarm {\n\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n\n  static getWorkerFarm() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  constructor(props) {\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"workerPools\", new Map());\n    this.props = {\n      ...DEFAULT_PROPS\n    };\n    this.setProps(props);\n    this.workerPools = new Map();\n  }\n\n  destroy() {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n    this.workerPools = new Map();\n  }\n\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  getWorkerPool(options) {\n    const {\n      name,\n      source,\n      url\n    } = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n_defineProperty(WorkerFarm, \"_workerFarm\", void 0);\n//# sourceMappingURL=worker-farm.js.map","\n\nimport { assert } from '../env-utils/assert';\nimport { VERSION as __VERSION__ } from '../env-utils/version';\nconst NPM_TAG = 'latest';\nconst VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : NPM_TAG;\n\nexport function getWorkerName(worker) {\n  const warning = worker.version !== VERSION ? \" (worker-utils@\".concat(VERSION, \")\") : '';\n  return \"\".concat(worker.name, \"@\").concat(worker.version).concat(warning);\n}\n\nexport function getWorkerURL(worker) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const workerOptions = options[worker.id] || {};\n  const workerFile = \"\".concat(worker.id, \"-worker.js\");\n  let url = workerOptions.workerUrl;\n\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  if (options._workerType === 'test') {\n    url = \"modules/\".concat(worker.module, \"/dist/\").concat(workerFile);\n  }\n\n  if (!url) {\n    let version = worker.version;\n    if (version === 'latest') {\n      version = NPM_TAG;\n    }\n    const versionTag = version ? \"@\".concat(version) : '';\n    url = \"https://unpkg.com/@loaders.gl/\".concat(worker.module).concat(versionTag, \"/dist/\").concat(workerFile);\n  }\n  assert(url);\n\n  return url;\n}\n//# sourceMappingURL=get-worker-url.js.map","import WorkerFarm from '../worker-farm/worker-farm';\nimport { getWorkerURL, getWorkerName } from './get-worker-url';\nimport { getTransferListForWriter } from '../worker-utils/get-transfer-list';\nexport function canProcessOnWorker(worker, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\n\nexport async function processOnWorker(worker, data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const name = getWorkerName(worker);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const {\n    source\n  } = options;\n  const workerPoolProps = {\n    name,\n    source\n  };\n  if (!source) {\n    workerPoolProps.url = getWorkerURL(worker, options);\n  }\n  const workerPool = workerFarm.getWorkerPool(workerPoolProps);\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(jobName,\n  onMessage.bind(null, context));\n\n  const transferableOptions = getTransferListForWriter(options);\n  job.postMessage('process', {\n    input: data,\n    options: transferableOptions\n  });\n  const result = await job.result;\n  return result.result;\n}\n\nasync function onMessage(context, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n    case 'process':\n      const {\n        id,\n        input,\n        options\n      } = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {\n            id,\n            error: 'Worker not set up to process on main thread'\n          });\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n      break;\n    default:\n      console.warn(\"process-on-worker: unknown message \".concat(type));\n  }\n}\n//# sourceMappingURL=process-on-worker.js.map","\nimport { global, isBrowser, isWorker } from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport { assert } from '../env-utils/assert';\nimport { VERSION as __VERSION__ } from '../env-utils/version';\n\nconst LATEST = 'latest';\nconst VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : LATEST;\nconst loadLibraryPromises = {};\n\nexport async function loadLibrary(libraryUrl) {\n  let moduleName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  loadLibraryPromises[libraryUrl] =\n  loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\nexport function getLibraryUrl(library, moduleName, options) {\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  if (!isBrowser) {\n    return \"modules/\".concat(moduleName, \"/dist/libs/\").concat(library);\n  }\n\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return \"\".concat(options.CDN, \"/\").concat(moduleName, \"@\").concat(VERSION, \"/dist/libs/\").concat(library);\n  }\n\n  if (isWorker) {\n    return \"../src/libs/\".concat(library);\n  }\n  return \"modules/\".concat(moduleName, \"/src/libs/\").concat(library);\n}\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n  if (!isBrowser) {\n    try {\n      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n  if (isWorker) {\n    eval.call(global, scriptSource);\n    return null;\n  }\n  const script = document.createElement('script');\n  script.id = id;\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n//# sourceMappingURL=library-utils.js.map","import { isBrowser } from '@loaders.gl/worker-utils';\nimport { WorkerFarm, getWorkerURL } from '@loaders.gl/worker-utils';\n\nexport function canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  if (!isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {\n    return false;\n  }\n  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\n\nexport async function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n  const name = loader.id;\n  const url = getWorkerURL(loader, options);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({\n    name,\n    url\n  });\n\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n  const job = await workerPool.startJob('process-on-worker',\n  onMessage.bind(null, parseOnMainThread));\n\n  job.postMessage('process', {\n    input: data,\n    options,\n    context\n  });\n  const result = await job.result;\n  return await result.result;\n}\n\nasync function onMessage(parseOnMainThread, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n    case 'process':\n      const {\n        id,\n        input,\n        options\n      } = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n      break;\n    default:\n      console.warn(\"parse-with-worker unknown message \".concat(type));\n  }\n}\n//# sourceMappingURL=parse-with-worker.js.map","\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  const result = new Uint8Array(byteLength);\n\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  return result.buffer;\n}\n\nexport function concatenateTypedArrays() {\n  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    typedArrays[_key2] = arguments[_key2];\n  }\n  const arrays = typedArrays;\n  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;\n  if (!TypedArrayConstructor) {\n    throw new Error('\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types');\n  }\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n//# sourceMappingURL=array-buffer-utils.js.map","\n\nlet pathPrefix = '';\nconst fileAliases = {};\n\nexport function setPathPrefix(prefix) {\n  pathPrefix = prefix;\n}\n\nexport function getPathPrefix() {\n  return pathPrefix;\n}\n\nexport function addAliases(aliases) {\n  Object.assign(fileAliases, aliases);\n}\n\nexport function resolvePath(filename) {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = \"\".concat(pathPrefix).concat(filename);\n  }\n  return filename;\n}\n//# sourceMappingURL=file-aliases.js.map","\n\nimport * as node from '../node/buffer';\n\nexport function isBuffer(value) {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\nexport function toBuffer(data) {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\nexport function toArrayBuffer(data) {\n  if (isBuffer(data)) {\n    return node.toArrayBuffer(data);\n  }\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n  throw new Error('toArrayBuffer');\n}\n//# sourceMappingURL=memory-conversion-utils.js.map","\nexport const VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : 'beta';\n//# sourceMappingURL=version.js.map","\nconst VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : 'beta';\n\nimport { loadLibrary } from '@loaders.gl/worker-utils';\nconst BASIS_CDN_ENCODER_WASM = \"https://unpkg.com/@loaders.gl/textures@\".concat(VERSION, \"/dist/libs/basis_encoder.wasm\");\nconst BASIS_CDN_ENCODER_JS = \"https://unpkg.com/@loaders.gl/textures@\".concat(VERSION, \"/dist/libs/basis_encoder.js\");\nlet loadBasisTranscoderPromise;\n\nexport async function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basis) {\n    return modules.basis;\n  }\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n  [BASIS, wasmBinary] = await Promise.all([await loadLibrary('basis_transcoder.js', 'textures', options), await loadLibrary('basis_transcoder.wasm', 'textures', options)]);\n\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    BasisModule(options).then(module => {\n      const {\n        BasisFile,\n        initializeBasis\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile\n      });\n    });\n  });\n}\nlet loadBasisEncoderPromise;\n\nexport async function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options), await loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)]);\n\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    BasisEncoderModule(options).then(module => {\n      const {\n        BasisFile,\n        KTX2File,\n        initializeBasis,\n        BasisEncoder\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile,\n        KTX2File,\n        BasisEncoder\n      });\n    });\n  });\n}\n//# sourceMappingURL=basis-module-loader.js.map","import { VERSION } from './lib/utils/version';\nimport { encodeKTX2BasisTexture } from './lib/encoders/encode-ktx2-basis-texture';\n\nexport const KTX2BasisWriter = {\n  name: 'Basis Universal Supercompressed GPU Texture',\n  id: 'ktx2-basis-writer',\n  module: 'textures',\n  version: VERSION,\n  extensions: ['ktx2'],\n  options: {\n    useSRGB: false,\n    qualityLevel: 10,\n    encodeUASTC: false,\n    mipmaps: false\n  },\n  encode: encodeKTX2BasisTexture\n};\n\nexport const _TypecheckKTX2TextureWriter = KTX2BasisWriter;\n//# sourceMappingURL=ktx2-basis-writer.js.map","import { loadBasisEncoderModule } from '../parsers/basis-module-loader';\n\nexport async function encodeKTX2BasisTexture(image) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    useSRGB = false,\n    qualityLevel = 10,\n    encodeUASTC = false,\n    mipmaps = false\n  } = options;\n  const {\n    BasisEncoder\n  } = await loadBasisEncoderModule(options);\n  const basisEncoder = new BasisEncoder();\n  try {\n    const basisFileData = new Uint8Array(image.width * image.height * 4);\n    basisEncoder.setCreateKTX2File(true);\n    basisEncoder.setKTX2UASTCSupercompression(true);\n    basisEncoder.setKTX2SRGBTransferFunc(true);\n    basisEncoder.setSliceSourceImage(0, image.data, image.width, image.height, false);\n    basisEncoder.setPerceptual(useSRGB);\n    basisEncoder.setMipSRGB(useSRGB);\n    basisEncoder.setQualityLevel(qualityLevel);\n    basisEncoder.setUASTC(encodeUASTC);\n    basisEncoder.setMipGen(mipmaps);\n    const numOutputBytes = basisEncoder.encode(basisFileData);\n    const actualKTX2FileData = basisFileData.subarray(0, numOutputBytes).buffer;\n    return actualKTX2FileData;\n  } catch (error) {\n    console.error('Basis Universal Supercompressed GPU Texture encoder Error: ', error);\n    throw error;\n  } finally {\n    basisEncoder.delete();\n  }\n}\n//# sourceMappingURL=encode-ktx2-basis-texture.js.map","import { isBrowser } from '@loaders.gl/loader-utils';\nconst {\n  _parseImageNode\n} = globalThis;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined';\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\nexport function isImageTypeSupported(type) {\n  switch (type) {\n    case 'auto':\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n    default:\n      throw new Error(\"@loaders.gl/images: image \".concat(type, \" not supported in this environment\"));\n  }\n}\n\nexport function getDefaultImageType() {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n//# sourceMappingURL=image-type.js.map","\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error(error.message);\n    }\n    const src = \"data:image/svg+xml;base64,\".concat(btoa(xmlText));\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  return new Blob([new Uint8Array(arrayBuffer)]);\n}\n//# sourceMappingURL=svg-utils.js.map","import { getBlobOrSVGDataUrl } from './svg-utils';\n\nexport default async function parseToImage(arrayBuffer, options, url) {\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n//# sourceMappingURL=parse-to-image.js.map","import { isSVG, getBlob } from './svg-utils';\nimport parseToImage from './parse-to-image';\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\n\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  if (isSVG(url)) {\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    blob = getBlob(arrayBuffer, url);\n  }\n  const imagebitmapOptions = options && options.imagebitmap;\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\nasync function safeCreateImageBitmap(blob) {\n  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n  if (imagebitmapOptions) {\n    try {\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error);\n      imagebitmapOptionsSupported = false;\n    }\n  }\n  return await createImageBitmap(blob);\n}\nfunction isEmptyObject(object) {\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n//# sourceMappingURL=parse-to-image-bitmap.js.map","\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\nexport function getBinaryImageMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);\n}\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n  if (!isBmp) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;\n  if (!isJpeg) {\n    return null;\n  }\n  const {\n    tableMarkers,\n    sofMarkers\n  } = getJpegMarkers();\n\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN),\n        width: dataView.getUint16(i + 7, BIG_ENDIAN)\n      };\n    }\n\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n  return null;\n}\nfunction getJpegMarkers() {\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);\n  return {\n    tableMarkers,\n    sofMarkers\n  };\n}\n\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n//# sourceMappingURL=binary-image-api.js.map","import { VERSION } from './lib/utils/version';\nimport parseImage from './lib/parsers/parse-image';\nimport { getBinaryImageMetadata } from './lib/category-api/binary-image-api';\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n  image: {\n    type: 'auto',\n    decode: true\n  }\n};\n\nexport const ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  tests: [arrayBuffer => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\nexport const _typecheckImageLoader = ImageLoader;\n//# sourceMappingURL=image-loader.js.map","\nexport const VERSION = typeof \"3.3.1\" !== 'undefined' ? \"3.3.1\" : 'latest';\n//# sourceMappingURL=version.js.map","import { assert } from '@loaders.gl/loader-utils';\nimport { isImageTypeSupported, getDefaultImageType } from '../category-api/image-type';\nimport { getImageData } from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  const imageType = imageOptions.type || 'auto';\n  const {\n    url\n  } = context || {};\n\n  const loadType = getLoadableImageType(imageType);\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n  return image;\n}\n\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      return getDefaultImageType();\n    default:\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n//# sourceMappingURL=parse-image.js.map","import { assert } from '@loaders.gl/loader-utils';\nimport { getBinaryImageMetadata } from '../category-api/binary-image-api';\n\nexport default async function parseToNodeImage(arrayBuffer, options) {\n  const {\n    mimeType\n  } = getBinaryImageMetadata(arrayBuffer) || {};\n\n  const _parseImageNode = globalThis._parseImageNode;\n  assert(_parseImageNode);\n\n  return await _parseImageNode(arrayBuffer, mimeType);\n}\n//# sourceMappingURL=parse-to-node-image.js.map","export function isImage(image) {\n  return Boolean(getImageTypeOrNull(image));\n}\nexport function deleteImage(image) {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      image.close();\n      break;\n    default:\n  }\n}\n\nexport function getImageType(image) {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\nexport function getImageSize(image) {\n  return getImageData(image);\n}\nexport function getImageData(image) {\n  switch (getImageType(image)) {\n    case 'data':\n      return image;\n    case 'image':\n    case 'imagebitmap':\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, image.width, image.height);\n    default:\n      throw new Error('getImageData');\n  }\n}\n\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n//# sourceMappingURL=parsed-image-api.js.map","var e=1e3,r=1001,a=1002,o=1003,p=1004,t=1004,v=1005,x=1005,b=1006,c=1007,d=1007,f=1008,g=1008,h=1009,i=1010,j=1011,k=1012,l=1013,m=1014,n=1015,q=1016,s=1017,u=1018,w=1020,y=1021,z=1022,A=1023,B=1024,C=1025,D=1026,E=1027,F=1028,G=1029,H=1030,I=1031,J=1033,K=33776,L=33777,M=33778,N=33779,O=35840,P=35841,Q=35842,R=35843,S=36196,T=37492,U=37496,V=37808,W=37809,X=37810,Y=37811,Z=37812,$=37813,_=37814,ee=37815,re=37816,ae=37817,oe=37818,pe=37819,te=37820,ve=37821,xe=36492,be=3e3,ce=3001,de=1e4,fe=10001,ge=10002,he=2e4,ie=20001,je=20002,ke=20003,le=20004,me=3e4,ne=300001,qe=4e5,se=400001,ue=400002,we=400003,ye=400004,ze=400005,Ae=5e5,Be=500001,Ce=500002,De=500003;export{y as AlphaFormat,i as ByteType,se as CentimetersUnit,r as ClampToEdgeWrapping,De as CustomProjectionType,D as DepthFormat,E as DepthStencilFormat,ne as FastRender,ye as FeetUnit,n as FloatType,Ce as FrustumProjectionType,de as GIFMediaType,q as HalfFloatType,ze as InchesUnit,l as IntType,fe as JPEGMediaType,be as LinearEncoding,b as LinearFilter,g as LinearMipMapLinearFilter,d as LinearMipMapNearestFilter,f as LinearMipmapLinearFilter,c as LinearMipmapNearestFilter,ie as LinesPrimitive,C as LuminanceAlphaFormat,B as LuminanceFormat,qe as MetersUnit,ue as MillimetersUnit,a as MirroredRepeatWrapping,o as NearestFilter,x as NearestMipMapLinearFilter,p as NearestMipMapNearestFilter,v as NearestMipmapLinearFilter,t as NearestMipmapNearestFilter,Be as OrthoProjectionType,ge as PNGMediaType,Ae as PerspectiveProjectionType,he as PointsPrimitive,me as QualityRender,A as RGBAFormat,J as RGBAIntegerFormat,pe as RGBA_ASTC_10x10_Format,re as RGBA_ASTC_10x5_Format,ae as RGBA_ASTC_10x6_Format,oe as RGBA_ASTC_10x8_Format,te as RGBA_ASTC_12x10_Format,ve as RGBA_ASTC_12x12_Format,V as RGBA_ASTC_4x4_Format,W as RGBA_ASTC_5x4_Format,X as RGBA_ASTC_5x5_Format,Y as RGBA_ASTC_6x5_Format,Z as RGBA_ASTC_6x6_Format,$ as RGBA_ASTC_8x5_Format,_ as RGBA_ASTC_8x6_Format,ee as RGBA_ASTC_8x8_Format,xe as RGBA_BPTC_Format,U as RGBA_ETC2_EAC_Format,R as RGBA_PVRTC_2BPPV1_Format,Q as RGBA_PVRTC_4BPPV1_Format,L as RGBA_S3TC_DXT1_Format,M as RGBA_S3TC_DXT3_Format,N as RGBA_S3TC_DXT5_Format,z as RGBFormat,S as RGB_ETC1_Format,T as RGB_ETC2_Format,P as RGB_PVRTC_2BPPV1_Format,O as RGB_PVRTC_4BPPV1_Format,K as RGB_S3TC_DXT1_Format,H as RGFormat,I as RGIntegerFormat,F as RedFormat,G as RedIntegerFormat,e as RepeatWrapping,j as ShortType,ke as SolidPrimitive,le as SurfacePrimitive,je as TrianglesPrimitive,h as UnsignedByteType,w as UnsignedInt248Type,m as UnsignedIntType,s as UnsignedShort4444Type,u as UnsignedShort5551Type,k as UnsignedShortType,we as YardsUnit,ce as sRGBEncoding};\n//# sourceMappingURL=index.es.map\n","/**\n * [![npm version](https://badge.fury.io/js/%40xeokit%2Fsvg)](https://badge.fury.io/js/%40xeokit%2Fmath)\n * [![](https://data.jsdelivr.com/v1/package/npm/@xeokit/badge)](https://www.jsdelivr.com/package/npm/@xeokit/math)\n *\n * <img src=\"http://xeokit.io/img/kdtree.jpeg\" />\n *\n * # xeokit Boundaries Math Library\n *\n * ---\n *\n * ### *Tools for 2D and 3D boundary analysis, boundary transformation, and collision detection*\n *\n * ---\n *\n * * Axis-aligned boundaries (AABB2 and AABB3)\n * * Object-aligned boundaries (OBB)\n * * Transformable OOBs\n * * Create boundaries from positions\n * * Find center of positions\n * * FrustumProjection-boundary intersection tests\n *\n * ## Installation\n *\n * ````bash\n * npm install @xeokit/boundaries\n * ````\n *\n * ## Usage\n *\n * ````javascript\n * import * as boundaries from \"@xeokit/boundaries\";\n *\n * //..TODO\n * ````\n *\n * @module @xeokit/boundaries\n */\nimport type {FloatArrayParam, IntArrayParam} from \"@xeokit/math\";\nimport {createMat4, createVec2, createVec3, lenVec3, mulMat4, subVec3} from \"@xeokit/matrix\";\nimport {MAX_DOUBLE, MIN_DOUBLE, newFloatArray} from \"@xeokit/math\";\nimport {decompressPoint3} from \"@xeokit/compression\";\n\n\nconst tempVec3a = createVec3();\nconst tempVec3b = createVec3();\nconst tempMat4a = createMat4();\n\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3(values?: FloatArrayParam): Float64Array {\n    // @ts-ignore\n    return new Float64Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 3D axis-aligned bounding box.\n */\nexport function createAABB3Int16(values?: IntArrayParam): Int16Array {\n    // @ts-ignore\n    return new Int16Array(values || 6);\n}\n\n/**\n * Returns a new, uninitialized 2D axis-aligned bounding box.\n */\nexport function createAABB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 4);\n}\n\n/**\n * Returns a new, uninitialized 3D oriented bounding box (OBB).\n */\nexport function createOBB3(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 32);\n}\n\n/**\n * Returns a new, uninitialized 2D oriented bounding box (OBB).\n */\nexport function createOBB2(values?: FloatArrayParam): FloatArrayParam {\n    // @ts-ignore\n    return newFloatArray(values || 16);\n}\n\n/** Returns a new 3D bounding sphere */\nexport function createSphere3(\n    x: number,\n    y: number,\n    z: number,\n    r: number\n): FloatArrayParam {\n    return newFloatArray([x, y, z, r]);\n}\n\n/**\n * Transforms an createOBB3 by a 4x4 \n */\nexport function transformOBB3(\n    m: FloatArrayParam,\n    p: FloatArrayParam,\n    p2: FloatArrayParam = p\n): FloatArrayParam {\n    let i;\n    const len = p.length;\n\n    let x;\n    let y;\n    let z;\n\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n\n    for (i = 0; i < len; i += 4) {\n        x = p[i + 0];\n        y = p[i + 1];\n        z = p[i + 2];\n\n        p2[i + 0] = m0 * x + m4 * y + m8 * z + m12;\n        p2[i + 1] = m1 * x + m5 * y + m9 * z + m13;\n        p2[i + 2] = m2 * x + m6 * y + m10 * z + m14;\n        p2[i + 3] = m3 * x + m7 * y + m11 * z + m15;\n    }\n\n    return p2;\n}\n\n\n/** Returns true if the first AABB2 contains the second AABB2.\n */\nexport function containsAABB2(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    return aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb1[2] <= aabb2[2];\n}\n\n/** Returns true if the first AABB3 contains the second AABB3.\n */\nexport function containsAABB3(\n    aabb1: FloatArrayParam,\n    aabb2: FloatArrayParam\n): boolean {\n    const result =\n        aabb1[0] <= aabb2[0] &&\n        aabb2[3] <= aabb1[3] &&\n        aabb1[1] <= aabb2[1] &&\n        aabb2[4] <= aabb1[4] &&\n        aabb1[2] <= aabb2[2] &&\n        aabb2[5] <= aabb1[5];\n    return result;\n}\n\n/**\n * Gets the diagonal size of an createAABB3 given as minima and maxima.\n */\nexport const getAABB3Diag: Function = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n    return (aabb: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n        subVec3(max, min, tempVec3);\n        return Math.abs(lenVec3(tempVec3));\n    };\n})();\n\n/**\n * Get a diagonal boundary size that is symmetrical about the given point.\n */\nexport const getAABB3DiagPoint = (() => {\n    const min = newFloatArray(3);\n    const max = newFloatArray(3);\n    const tempVec3 = newFloatArray(3);\n\n    return (aabb: FloatArrayParam, p: FloatArrayParam): number => {\n        min[0] = aabb[0];\n        min[1] = aabb[1];\n        min[2] = aabb[2];\n\n        max[0] = aabb[3];\n        max[1] = aabb[4];\n        max[2] = aabb[5];\n\n        const diagVec = subVec3(max, min, tempVec3);\n\n        const xneg = p[0] - aabb[0];\n        const xpos = aabb[3] - p[0];\n        const yneg = p[1] - aabb[1];\n        const ypos = aabb[4] - p[1];\n        const zneg = p[2] - aabb[2];\n        const zpos = aabb[5] - p[2];\n\n        diagVec[0] += xneg > xpos ? xneg : xpos;\n        diagVec[1] += yneg > ypos ? yneg : ypos;\n        diagVec[2] += zneg > zpos ? zneg : zpos;\n\n        return Math.abs(lenVec3(diagVec));\n    };\n})();\n\n/**\n * Gets the area of an AABB.\n */\nexport function getAABB3Area(aabb: FloatArrayParam): number {\n    const width = aabb[3] - aabb[0];\n    const height = aabb[4] - aabb[1];\n    const depth = aabb[5] - aabb[2];\n    return width * height * depth;\n}\n\n/**\n * Gets the center of an AABB.\n */\nexport function getAABB3Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    dest[0] = (aabb[0] + aabb[3]) / 2;\n    dest[1] = (aabb[1] + aabb[4]) / 2;\n    dest[2] = (aabb[2] + aabb[5]) / 2;\n    return dest;\n}\n\n/**\n * Gets the center of a 2D AABB.\n */\nexport function getAABB2Center(\n    aabb: FloatArrayParam,\n    dest: FloatArrayParam = createVec2()\n): FloatArrayParam {\n    dest[0] = (aabb[2] + aabb[0]) / 2;\n    dest[1] = (aabb[3] + aabb[1]) / 2;\n    return dest;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3(aabb: FloatArrayParam = createAABB3()): FloatArrayParam {\n    aabb[0] = MAX_DOUBLE;\n    aabb[1] = MAX_DOUBLE;\n    aabb[2] = MAX_DOUBLE;\n    aabb[3] = MIN_DOUBLE;\n    aabb[4] = MIN_DOUBLE;\n    aabb[5] = MIN_DOUBLE;\n    return aabb;\n}\n\n/**\n * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n * Creates new AABB if none supplied.\n */\nexport function collapseAABB3Int16(aabb: IntArrayParam = createAABB3Int16()): IntArrayParam {\n    aabb[0] = 65535;\n    aabb[1] = 65535;\n    aabb[2] = 65535;\n    aabb[3] = -65535;\n    aabb[4] = -65535;\n    aabb[5] = -65535;\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n *\n * @private\n */\nexport function AABB3ToOBB3(aabb: FloatArrayParam = createAABB3(), obb = createOBB3()): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n */\nexport function expandAABB3(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[2] > aabb2[2]) {\n        aabb1[2] = aabb2[2];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    if (aabb1[5] < aabb2[5]) {\n        aabb1[5] = aabb2[5];\n    }\n    return aabb1;\n}\n\n/**\n * Expands the first axis-aligned 2D boundary to enclose the second, if required.\n */\nexport function expandAABB2(aabb1: FloatArrayParam, aabb2: FloatArrayParam) {\n    if (aabb1[0] > aabb2[0]) {\n        aabb1[0] = aabb2[0];\n    }\n    if (aabb1[1] > aabb2[1]) {\n        aabb1[1] = aabb2[1];\n    }\n    if (aabb1[3] < aabb2[3]) {\n        aabb1[3] = aabb2[3];\n    }\n    if (aabb1[4] < aabb2[4]) {\n        aabb1[4] = aabb2[4];\n    }\n    return aabb1;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n */\nexport function expandAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[2] > p[2]) {\n        aabb[2] = p[2];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    if (aabb[5] < p[2]) {\n        aabb[5] = p[2];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 2D boundary to enclose the given point, if needed.\n */\nexport function expandAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n\n    if (aabb[0] > p[0]) {\n        aabb[0] = p[0];\n    }\n\n    if (aabb[1] > p[1]) {\n        aabb[1] = p[1];\n    }\n\n    if (aabb[3] < p[0]) {\n        aabb[3] = p[0];\n    }\n\n    if (aabb[4] < p[1]) {\n        aabb[4] = p[1];\n    }\n\n    return aabb;\n}\n\n/**\n * Expands an axis-aligned 3D boundary to enclose the given points, if needed.\n */\nexport function expandAABB3Points3(aabb: FloatArrayParam, positions: FloatArrayParam): FloatArrayParam {\n    var x;\n    var y;\n    var z;\n    for (var i = 0, len = positions.length; i < len; i += 3) {\n        x = positions[i];\n        y = positions[i + 1];\n        z = positions[i + 2];\n        if (aabb[0] > x) {\n            aabb[0] = x;\n        }\n        if (aabb[1] > y) {\n            aabb[1] = y;\n        }\n        if (aabb[2] > z) {\n            aabb[2] = z;\n        }\n        if (aabb[3] < x) {\n            aabb[3] = x;\n        }\n        if (aabb[4] < y) {\n            aabb[4] = y;\n        }\n        if (aabb[5] < z) {\n            aabb[5] = z;\n        }\n    }\n    return aabb;\n}\n\n/**\n * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n * an array of eight 3D positions, one for each corner of the boundary.\n */\nexport function ABB3ToOBB3(\n    aabb: FloatArrayParam,\n    obb: FloatArrayParam = createOBB3()\n): FloatArrayParam {\n    obb[0] = aabb[0];\n    obb[1] = aabb[1];\n    obb[2] = aabb[2];\n    obb[3] = 1;\n\n    obb[4] = aabb[3];\n    obb[5] = aabb[1];\n    obb[6] = aabb[2];\n    obb[7] = 1;\n\n    obb[8] = aabb[3];\n    obb[9] = aabb[4];\n    obb[10] = aabb[2];\n    obb[11] = 1;\n\n    obb[12] = aabb[0];\n    obb[13] = aabb[4];\n    obb[14] = aabb[2];\n    obb[15] = 1;\n\n    obb[16] = aabb[0];\n    obb[17] = aabb[1];\n    obb[18] = aabb[5];\n    obb[19] = 1;\n\n    obb[20] = aabb[3];\n    obb[21] = aabb[1];\n    obb[22] = aabb[5];\n    obb[23] = 1;\n\n    obb[24] = aabb[3];\n    obb[25] = aabb[4];\n    obb[26] = aabb[5];\n    obb[27] = 1;\n\n    obb[28] = aabb[0];\n    obb[29] = aabb[4];\n    obb[30] = aabb[5];\n    obb[31] = 1;\n\n    return obb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport const positions3ToAABB3 = (() => {\n    const p = newFloatArray(3);\n\n    return (\n        positions: FloatArrayParam,\n        aabb: FloatArrayParam,\n        positionsDecompressMatrix: FloatArrayParam\n    ): FloatArrayParam => {\n        aabb = aabb || createAABB3();\n\n        let xmin = MAX_DOUBLE;\n        let ymin = MAX_DOUBLE;\n        let zmin = MAX_DOUBLE;\n        let xmax = MIN_DOUBLE;\n        let ymax = MIN_DOUBLE;\n        let zmax = MIN_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = positions.length; i < len; i += 3) {\n            if (positionsDecompressMatrix) {\n                p[0] = positions[i + 0];\n                p[1] = positions[i + 1];\n                p[2] = positions[i + 2];\n\n                decompressPoint3(p, positionsDecompressMatrix, p);\n\n                x = p[0];\n                y = p[1];\n                z = p[2];\n            } else {\n                x = positions[i + 0];\n                y = positions[i + 1];\n                z = positions[i + 2];\n            }\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    };\n})();\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n */\nexport function OBB3ToAABB3(\n    obb: FloatArrayParam,\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = obb.length; i < len; i += 4) {\n        x = obb[i + 0];\n        y = obb[i + 1];\n        z = obb[i + 2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n */\nexport function points3ToAABB3(\n    points: number[][],\n    aabb: FloatArrayParam = createAABB3()\n): FloatArrayParam {\n    let xmin = MAX_DOUBLE;\n    let ymin = MAX_DOUBLE;\n    let zmin = MAX_DOUBLE;\n    let xmax = MIN_DOUBLE;\n    let ymax = MIN_DOUBLE;\n    let zmax = MIN_DOUBLE;\n\n    let x;\n    let y;\n    let z;\n\n    for (let i = 0, len = points.length; i < len; i++) {\n        x = points[i][0];\n        y = points[i][1];\n        z = points[i][2];\n\n        if (x < xmin) {\n            xmin = x;\n        }\n\n        if (y < ymin) {\n            ymin = y;\n        }\n\n        if (z < zmin) {\n            zmin = z;\n        }\n\n        if (x > xmax) {\n            xmax = x;\n        }\n\n        if (y > ymax) {\n            ymax = y;\n        }\n\n        if (z > zmax) {\n            zmax = z;\n        }\n    }\n\n    aabb[0] = xmin;\n    aabb[1] = ymin;\n    aabb[2] = zmin;\n    aabb[3] = xmax;\n    aabb[4] = ymax;\n    aabb[5] = zmax;\n\n    return aabb;\n}\n\n/**\n * Gets the 3D center of the given flat array of 3D positions.\n */\nexport function getPositions3Center(\n    positions: FloatArrayParam,\n    center: FloatArrayParam = createVec3()\n): FloatArrayParam {\n    let xCenter = 0;\n    let yCenter = 0;\n    let zCenter = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        xCenter += positions[i + 0];\n        yCenter += positions[i + 1];\n        zCenter += positions[i + 2];\n    }\n    const numPositions = positions.length / 3;\n    center[0] = xCenter / numPositions;\n    center[1] = yCenter / numPositions;\n    center[2] = zCenter / numPositions;\n    return center;\n}\n\n\n/**\n * A plane within a {@link Frustum3}.\n */\nexport class FrustumPlane3 {\n\n    public testVertex: FloatArrayParam;\n    public offset: number;\n    public normal: FloatArrayParam;\n\n    /**\n     * Creates a new frustum plane.\n     */\n    constructor() {\n        this.normal = createVec3();\n        this.offset = 0;\n        this.testVertex = createVec3();\n    }\n\n    /**\n     * Sets the position and direction of the frustum plane.\n     * @param nx\n     * @param ny\n     * @param nz\n     * @param offset\n     */\n    set(nx: number, ny: number, nz: number, offset: number) {\n        const s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n        this.normal[0] = nx * s;\n        this.normal[1] = ny * s;\n        this.normal[2] = nz * s;\n        this.offset = offset * s;\n        this.testVertex[0] = (this.normal[0] >= 0.0) ? 1 : 0;\n        this.testVertex[1] = (this.normal[1] >= 0.0) ? 1 : 0;\n        this.testVertex[2] = (this.normal[2] >= 0.0) ? 1 : 0;\n    }\n}\n\n/**\n * Intersection state in which first boundary is completely inside the second.\n */\nexport const INSIDE: number = 1;\n\n/**\n * Intersection state in which two boundaries partially intersect.\n */\nexport const INTERSECT: number = 2;\n\n/**\n * Intersection state in which two boundaries do not intersect.\n */\nexport const OUTSIDE: number = 3;\n\n/**\n * A 3D frustum defined as six planes.\n */\nexport class Frustum3 {\n\n    /**\n     * The six planes that comprise the frustum boundary.\n     */\n    public planes: FrustumPlane3[];\n\n    /**\n     * Creates a new FrustumProjection\n     */\n    constructor() {\n        this.planes = [\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3(),\n            new FrustumPlane3(), new FrustumPlane3(), new FrustumPlane3()\n        ];\n    }\n}\n\n/**\n * Sets the extents of a frustum to the World-space volume defined by view and projection matrices.\n * Creates the frustum first if not given.\n */\nexport function setFrustum3(viewMat: FloatArrayParam, projMat: FloatArrayParam, frustum?: Frustum3) {\n    const m = mulMat4(projMat, viewMat, tempMat4a);\n    const m0 = m[0];\n    const m1 = m[1];\n    const m2 = m[2];\n    const m3 = m[3];\n    const m4 = m[4];\n    const m5 = m[5];\n    const m6 = m[6];\n    const m7 = m[7];\n    const m8 = m[8];\n    const m9 = m[9];\n    const m10 = m[10];\n    const m11 = m[11];\n    const m12 = m[12];\n    const m13 = m[13];\n    const m14 = m[14];\n    const m15 = m[15];\n    frustum = frustum || new Frustum3();\n    frustum.planes[0].set(m3 - m0, m7 - m4, m11 - m8, m15 - m12);\n    frustum.planes[1].set(m3 + m0, m7 + m4, m11 + m8, m15 + m12);\n    frustum.planes[2].set(m3 - m1, m7 - m5, m11 - m9, m15 - m13);\n    frustum.planes[3].set(m3 + m1, m7 + m5, m11 + m9, m15 + m13);\n    frustum.planes[4].set(m3 - m2, m7 - m6, m11 - m10, m15 - m14);\n    frustum.planes[5].set(m3 + m2, m7 + m6, m11 + m10, m15 + m14);\n    return frustum;\n}\n\n/**\n * Tests for intersection between a frustum and an axis-aligned 3D boundary.\n * @param frustum\n * @param aabb\n */\nexport function intersectFrustum3AABB3(frustum: Frustum3, aabb: FloatArrayParam): number {\n    let ret = INSIDE;\n    const min = tempVec3a;\n    const max = tempVec3b;\n    min[0] = aabb[0];\n    min[1] = aabb[1];\n    min[2] = aabb[2];\n    max[0] = aabb[3];\n    max[1] = aabb[4];\n    max[2] = aabb[5];\n    const bminmax = [min, max];\n    for (let i = 0; i < 6; ++i) {\n        const plane = frustum.planes[i];\n        if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            return OUTSIDE;\n        }\n        if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n            (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n            (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n            (plane.offset)) < 0.0) {\n            ret = INTERSECT;\n        }\n    }\n    return ret;\n}\n\n/**\n * Tests for intersection between two axis-aligned 3D boundaries.\n * @param aabb1\n * @param aabb2\n */\nexport function intersectAABB3s(aabb1: FloatArrayParam, aabb2: FloatArrayParam): number {\n\n    return INTERSECT;\n    // let ret = INSIDE;\n    // const min = tempVec3a;\n    // const max = tempVec3b;\n    // min[0] = aabb[0];\n    // min[1] = aabb[1];\n    // min[2] = aabb[2];\n    // max[0] = aabb[3];\n    // max[1] = aabb[4];\n    // max[2] = aabb[5];\n    // const bminmax = [min, max];\n    // for (let i = 0; i < 6; ++i) {\n    //     const plane = frustum.planes[i];\n    //     if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         return OUTSIDE;\n    //     }\n    //     if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +\n    //         (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +\n    //         (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +\n    //         (plane.offset)) < 0.0) {\n    //         ret = INTERSECT;\n    //     }\n    // }\n    // return ret;\n}\n\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Triangles3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given triangle primitive.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param a\n * @param b\n * @param c\n */\nexport function intersectFrustum3Triangle3(frustum: Frustum3, a: FloatArrayParam, b: FloatArrayParam, c: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n * @param indices\n */\nexport function intersectFrustum3Lines3(frustum: Frustum3, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given {@link @xeokit/constants!PointsPrimitive | PointsPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param positions\n */\nexport function intersectFrustum3Positions3(frustum: Frustum3, positions: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given {@link @math/boundaries!Frustum3 | Frustum3} intersects the given position.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param frustum\n * @param position\n */\nexport function intersectFrustum3Point3(frustum: Frustum3, position: FloatArrayParam): boolean {\n    return true;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/constants!TrianglesPrimitive | TrianglesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Triangles3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam): boolean {\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n        // if (aabbIntersectsTriangle(positions, indices[i], indices[i + 1], indices[i + 2], aabb)) {\n        //     return true;\n        // }\n    }\n    return false;\n}\n\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/constants!LinesPrimitive | LinesPrimitive} geometry.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n * @param indices\n */\nexport function intersectAABB3Lines3(aabb: FloatArrayParam, positions: FloatArrayParam, indices: IntArrayParam) {\n    return false;\n}\n\n/**\n * Tests if the given AABB intersects the given {@link @xeokit/constants!PointsPrimitive | PointsPrimitive} vertex positions.\n *\n * Returns ```` true```` if intersection else ````false````.\n *\n * @param aabb\n * @param positions\n */\nexport function intersectAABB3Positions3(aabb: FloatArrayParam, positions: FloatArrayParam) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xmax = aabb[3];\n    const ymax = aabb[4];\n    const zmax = aabb[5];\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const x = positions[i];\n        if (xmin <= x && x <= xmax) {\n            const y = positions[i + 1];\n            if (ymin <= y && y <= ymax) {\n                const z = positions[i + 2];\n                if (zmin <= z && z <= zmax) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Tets if the given 3D AABB contains the given 3D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB3Point3(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4] &&\n        aabb[2] <= p[2] && p[2] <= aabb[5]);\n}\n\n/**\n * Tets if the given 2D AABB contains the given 2D position.\n * @param aabb\n * @param p\n */\nexport function containsAABB2Point2(aabb: FloatArrayParam, p: FloatArrayParam) {\n    return (\n        aabb[0] <= p[0] && p[0] <= aabb[3] &&\n        aabb[1] <= p[1] && p[1] <= aabb[4]);\n}","import type {IntArrayParam} from \"@xeokit/math\";\nimport type {GeometryBucketParams} from \"./GeometryBucketParams\";\n\n/**\n * A geometry bucket within {@link @xeokit/scene!Geometry.geometryBuckets | Geometry.geometryBuckets}.\n *\n * See usage in:\n *\n * * [@xeokit/scene](/docs/modules/_xeokit_scene.html)\n * * [@xeokit/viewer](/docs/modules/_xeokit_viewer.html)\n */\nexport class GeometryBucket {\n\n    /**\n     * GeometryBucket's 3D vertex positions, quantized as 16-bit integers.\n     *\n     * Internally, the Viewer dequantizes these with {@link @xeokit/scene!Geometry.positionsDecompressMatrix}.\n     *\n     * Vertex positions are required for all primitive types.\n     */\n    positionsCompressed: IntArrayParam;\n\n    /**\n     * GeometryBucket's UV coordinates, quantized as 16-bit integers.\n     *\n     * Internally, the Viewer de-quantizes these with {@link @xeokit/scene!Geometry.uvsDecompressMatrix}.\n     */\n    uvsCompressed?: IntArrayParam;\n\n    /**\n     * GeometryBucket's vertex RGB colors, quantized as 8-bit integers.\n     */\n    colorsCompressed?: IntArrayParam;\n\n    /**\n     * GeometryBucket's primitive indices.\n     *\n     * This is either an array of 8-bit, 16-bit or 32-bit values.\n     */\n    indices?: IntArrayParam;\n\n    /**\n     * GeometryBucket's edge indices.\n     *\n     * This is either an array of 8-bit, 16-bit or 32-bit values.\n     */\n    edgeIndices?: IntArrayParam;\n\n    constructor(geometryBucketParams: GeometryBucketParams) {\n        this.positionsCompressed = geometryBucketParams.positionsCompressed;\n        this.uvsCompressed = geometryBucketParams.uvsCompressed;\n        this.colorsCompressed = geometryBucketParams.colorsCompressed;\n        this.indices = geometryBucketParams.indices;\n        this.edgeIndices = geometryBucketParams.edgeIndices;\n    }\n}","import type {FloatArrayParam} from \"@xeokit/math\";\nimport {GeometryBucket} from \"./GeometryBucket\";\nimport type {GeometryCompressedParams} from \"./GeometryCompressedParams\";\nimport type {RendererGeometry} from \"./RendererGeometry\";\n\n/**\n * A geometry in a {@link SceneModel}.\n *\n * * Stored in {@link @xeokit/scene!SceneModel.geometries | SceneModel.geometries}\n * * Created with {@link @xeokit/scene!SceneModel.createGeometry | SceneModel.createGeometry}\n * and {@link @xeokit/scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed}\n * * Referenced by {@link @xeokit/scene!SceneObject.geometry}\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class Geometry {\n\n    /**\n     * ID for the geometry.\n     */\n    id: string;\n\n    /**\n     * Primitive type.\n     *\n     * Possible values are {@link SolidPrimitive}, {@link SurfacePrimitive}, {@link LinesPrimitive}, {@link PointsPrimitive}\n     * and {@link TrianglesPrimitive}.\n     */\n    primitive: number;\n\n    /**\n     * Matrix to decompress {@link @xeokit/scene!GeometryBucketParams.positionsCompressed}.\n     */\n    positionsDecompressMatrix: FloatArrayParam;\n\n    /**\n     * Axis-aligned, non-quantized 3D boundary of the geometry's vertex positions.\n     */\n    aabb?: FloatArrayParam;\n\n    /**\n     * 4x4 matrix to de-quantize the geometry's UV coordinates, when UVs are provided.\n     */\n    uvsDecompressMatrix?: FloatArrayParam;\n\n    /**\n     * The geometry arrays, organized into buckets for optimal memory use.\n     *\n     * The bucketing strategy aims to reduce memory consumed by indices. There are three buckets, each with an indices array that\n     * requires a different number of bits for its values. The first bucket's indices contain 8-bit values in range [0...255],\n     * the second contains 16-bit values in range ````[256..65535]````, and the third contains 32-bit values in\n     * range ````[65536...2147483647]````. With this strategy, we avoid wasting storage bits on the 8-bit and 16-bit values.\n     *\n     * The buckets also partition the geometry positions and UVs, so that the indices are indexing positions and UVs\n     * that are local to their bucket. This further optimizes memory use, by reducing the values of large indices to small\n     * locally-offset values, which can reduce the number of bits they need.\n     */\n    geometryBuckets: GeometryBucket[];\n\n    /**\n     * Interface through which this Geometry can load any user-updated geometry arrays into the renderer.\n     *\n     * @internal\n     */\n    rendererGeometry: RendererGeometry | null;\n\n    constructor(params: GeometryCompressedParams) {\n        this.geometryBuckets = [];\n        for (let i = 0, len = params.geometryBuckets.length; i < len; i++) {\n            this.geometryBuckets[i] = new GeometryBucket(params.geometryBuckets[i]);\n        }\n        this.id = params.id;\n        this.positionsDecompressMatrix = params.positionsDecompressMatrix;\n        this.primitive = params.primitive;\n    }\n}","import type {SceneObject} from \"./SceneObject\";\nimport type {Mesh} from \"./Mesh\";\nimport {decompressPositions3} from \"@xeokit/compression\";\nimport {transformPositions3} from \"@xeokit/matrix\";\nimport type {FloatArrayParam} from \"@xeokit/math\";\nimport type {Geometry} from \"./Geometry\";\nimport type {GeometryBucket} from \"./GeometryBucket\";\nimport {LinesPrimitive, TrianglesPrimitive} from \"@xeokit/constants\";\n\n/**\n * The {@link getSceneObjectGeometry} passes an instance of GeometryView to its callback\n * for each {@link GeometryBucket} it visits. The GeometryView provides the SceneObject, Mesh, Geometry and\n * GeometryBucket at the current state of iteration, along with accessors through which the caller can\n * get various resources that the GeometryView lazy-computes on-demand, such as decompressed vertex positions, World-space\n * vertex positons, and decompressed vertex UV coordinates.\n */\nexport interface GeometryView {\n\n    /**\n     * The current {@link SceneObject}.\n     */\n    object: SceneObject;\n\n    /**\n     * The current {@link Mesh}.\n     */\n    mesh: Mesh;\n\n    /**\n     * The current {@link Mesh | Mesh's} position in {@link SceneModel.meshes | SceneObject.meshes}.\n     */\n    meshIndex: number;\n\n    /**\n     * The current {@link Geometry}.\n     */\n    geometry: Geometry;\n\n    /**\n     * The current {@link GeometryBucket}.\n     */\n    geometryBucket: GeometryBucket;\n\n    /**\n     * The current {@link GeometryBucket | GeometryBucket's} position in {@link Geometry.geometryBuckets | Geometry.geometryBuckets }.\n     */\n    geometryBucketIndex: number;\n\n    /**\n     * The total number of {@link GeometryBucket | GeometryBuckets} within the current {@link SceneObject}..\n     */\n    readonly totalGeometryBuckets: number;\n\n    /**\n     * The number of primitives in the current {@link GeometryBucket}.\n     */\n    readonly numPrimitives: number;\n\n    /**\n     * The current 3D vertex positions, dequantized, as 32-bit floats.\n     */\n    readonly positionsDecompressed: FloatArrayParam;\n\n    /**\n     * The current 3D World-space vertex positions, dequantized and world-transformed, as 64-bit floats.\n     */\n    readonly positionsWorld: FloatArrayParam;\n\n    /**\n     * The current vertex UV coordinates, if any, dequantized to 32-bit floats.\n     */\n    readonly uvsDecompressed: FloatArrayParam;\n}\n\nclass GeometryViewImpl {\n\n    object: SceneObject | null;\n    mesh: Mesh | null;\n    meshIndex: number;\n    geometry: Geometry | null;\n    geometryBucket: GeometryBucket | null;\n    geometryBucketIndex: number;\n    #positionsDecompressed: Float32Array | null;\n    #positionsWorld: Float64Array | null;\n\n    constructor() {\n        this.object = null;\n        this.mesh = null;\n        this.meshIndex = 0;\n        this.geometry = null;\n        this.geometryBucket = null;\n        this.geometryBucketIndex = 0;\n        this.#positionsDecompressed = null;\n        this.#positionsWorld = null;\n    }\n\n    get totalGeometryBuckets() {\n        let totalGeometryBuckets = 0;\n        if (this.object) {\n            for (let i = 0, len = this.object.meshes.length; i < len; i++) {\n                totalGeometryBuckets += this.object.meshes[i].geometry.geometryBuckets.length;\n            }\n        }\n        return totalGeometryBuckets;\n    }\n\n    get numPrimitives() {\n        const primitiveType = (<Geometry>this.geometry).primitive;\n        const elementsPerPrimitiveType = (primitiveType === TrianglesPrimitive ? 3 : (primitiveType === LinesPrimitive ? 2 : 1));\n        return (<FloatArrayParam>(<GeometryBucket>this.geometryBucket).indices).length / elementsPerPrimitiveType;\n    }\n\n    get positionsDecompressed(): FloatArrayParam {\n        if (!this.#positionsDecompressed) {\n            this.#positionsDecompressed = new Float32Array((<GeometryBucket>this.geometryBucket).positionsCompressed.length);\n            decompressPositions3((<GeometryBucket>this.geometryBucket).positionsCompressed, (<Geometry>this.geometry).positionsDecompressMatrix, this.#positionsDecompressed);\n        }\n        return this.#positionsDecompressed;\n    }\n\n    get positionsWorld(): FloatArrayParam {\n        if (!this.#positionsWorld) {\n            const positionsDecompressed = this.positionsDecompressed;\n            this.#positionsWorld = new Float64Array(positionsDecompressed.length);\n            transformPositions3(positionsDecompressed, (<Mesh>this.mesh).matrix, this.#positionsWorld);\n        }\n        return this.#positionsWorld;\n    }\n\n    get uvsDecompressed(): FloatArrayParam | null{\n        return null;\n    }\n\n    reset() {\n        this.#positionsDecompressed = null;\n        this.#positionsWorld = null;\n    }\n}\n\nconst geometryView = new GeometryViewImpl();\n\n/**\n * Gets the uncompressed, World-space geometry of each {@link GeometryBucket} in each\n * {@link Geometry} in each {@link Mesh} in a {@link SceneObject}.\n *\n * If the callback returns ````true````, then this method immediately stops iterating and also returns ````true````.\n *\n * @param sceneObject\n * @param withEachGeometry\n */\nexport function getSceneObjectGeometry(sceneObject: SceneObject, withEachGeometry: (geometryView: GeometryView) => boolean): boolean {\n    geometryView.reset();\n    geometryView.object = sceneObject;\n    for (let i = 0, len = sceneObject.meshes.length; i < len; i++) {\n        const mesh = sceneObject.meshes[i];\n        geometryView.mesh = mesh;\n        geometryView.meshIndex = i;\n        const geometry = mesh.geometry;\n        geometryView.geometry = geometry;\n        for (let j = 0, lenj = geometry.geometryBuckets.length; j < lenj; j++) {\n            geometryView.geometryBucket = geometry.geometryBuckets[j];\n            geometryView.geometryBucketIndex = j;\n            if (withEachGeometry(<GeometryView>geometryView)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n","import type {Mesh} from \"./Mesh\";\nimport type {FloatArrayParam} from \"@xeokit/math\";\nimport type {RendererObject} from \"./RendererObject\";\nimport type {Scene} from \"./Scene\";\nimport type {SceneModel} from \"./SceneModel\";\nimport {collapseAABB3, createAABB3, expandAABB3Points3} from \"@xeokit/boundaries\";\nimport {getSceneObjectGeometry} from \"./getSceneObjectGeometry\";\n\n/**\n * An object in a {@link @xeokit/scene!SceneModel}.\n *\n * * Stored in {@link @xeokit/scene!SceneModel.objects | SceneModel.objects} and {@link @xeokit/scene!Scene.objects | Scene.objects}\n * * Created with {@link @xeokit/scene!SceneModel.createObject | SceneModel.createObject}\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class SceneObject {\n\n    /**\n     * The {@link SceneModel} that contains this SceneObject.\n     */\n    public readonly model: SceneModel;\n\n    /**\n     * Unique ID of this SceneObject.\n     *\n     * SceneObjects are stored by ID in {@link Scene.objects | Scene.objects} and {@link SceneModel.objects | SceneModel.objects}.\n     */\n    public readonly id: string;\n\n    /**\n     * The {@link Mesh | Meshes} belonging to this SceneObject.\n     */\n    public readonly meshes: Mesh[];\n\n    /**\n     * Optional layer ID for this SceneObject.\n     */\n    public readonly layerId?: string;\n\n    /**\n     *  Internal interface through which a {@link SceneObject} can load property updates into a renderer.\n     *\n     *  This is defined while the owner {@link SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.\n     *\n     * @internal\n     */\n    rendererObject: RendererObject | null;\n\n    #aabb: FloatArrayParam;\n    #aabbDirty: boolean;\n\n    /**\n     * @private\n     */\n    constructor(cfg: {\n        model: SceneModel;\n        meshes: Mesh[];\n        id: string;\n        layerId?: string;\n    }) {\n        this.id = cfg.id;\n        this.layerId = cfg.layerId;\n        this.meshes = cfg.meshes;\n        this.#aabb = createAABB3();\n        this.#aabbDirty = true;\n        this.rendererObject = null;\n    }\n\n    /**\n     * Gets the axis-aligned 3D World-space boundary of this SceneObject.\n     */\n    get aabb(): FloatArrayParam {\n        if (this.#aabbDirty) {\n            collapseAABB3(this.#aabb);\n            getSceneObjectGeometry(this, (geometryView) => {\n                expandAABB3Points3(this.#aabb, geometryView.positionsWorld);\n                return false;\n            });\n            this.#aabbDirty = false;\n        }\n        return this.#aabb;\n    }\n\n    /**\n     * @private\n     */\n    setAABBDirty() {\n        this.#aabbDirty = true;\n    }\n}\n","import type {Texture} from \"./Texture\";\nimport type {TextureSetParams} from \"./TextureSetParams\";\nimport type {RendererTextureSet} from \"./RendererTextureSet\";\n\n/**\n * A set of {@link Texture | Textures} in a {@link SceneModel}.\n *\n * * Stored in {@link @xeokit/scene!SceneModel.textureSets | SceneModel.textureSets}\n * * Created with {@link @xeokit/scene!SceneModel.createTextureSet | SceneModel.createTextureSet}\n * * Referenced by {@link Mesh.textureSet | Mesh.textureSet}\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class TextureSet {\n\n    /**\n     * The ID of this TextureSet.\n     */\n    id: string;\n\n    /**\n     * The color {@link Texture} in this set.\n     */\n    colorTexture?: Texture;\n\n    /**\n     * The metallic-roughness {@link Texture} in this set.\n     */\n    metallicRoughnessTexture?: Texture;\n\n    /**\n     * The occlusion {@link Texture} in this set.\n     */\n    occlusionTexture?: Texture;\n\n    /**\n     * The emissive {@link Texture} in this set.\n     */\n    emissiveTexture?: Texture;\n\n    /**\n     *  Internal interface through which a TextureSet can load property updates into a renderer.\n     *\n     *  This is defined while the owner {@link SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.\n     *\n     * @internal\n     */\n    rendererTextureSet: RendererTextureSet | null;\n\n    /**\n     * @private\n     */\n    constructor(textureSetParams: TextureSetParams,\n                textures: {\n                    emissiveTexture?: Texture;\n                    occlusionTexture?: Texture;\n                    metallicRoughnessTexture?: Texture;\n                    colorTexture?: Texture;\n                }) {\n\n        this.id = textureSetParams.id;\n        this.colorTexture = textures.colorTexture;\n        this.metallicRoughnessTexture = textures.metallicRoughnessTexture;\n        this.occlusionTexture = textures.occlusionTexture;\n        this.emissiveTexture = textures.emissiveTexture;\n        this.rendererTextureSet = null;\n    }\n}","import {\n    ClampToEdgeWrapping,\n    GIFMediaType,\n    JPEGMediaType,\n    LinearEncoding,\n    LinearFilter,\n    LinearMipmapLinearFilter,\n    LinearMipMapLinearFilter,\n    LinearMipMapNearestFilter,\n    MirroredRepeatWrapping,\n    NearestFilter,\n    NearestMipMapLinearFilter,\n    NearestMipMapNearestFilter,\n    PNGMediaType,\n    RepeatWrapping,\n    sRGBEncoding\n} from \"@xeokit/constants\";\nimport type {FloatArrayParam} from \"@xeokit/math\";\nimport type {RendererTexture} from \"./RendererTexture\";\nimport type {TextureParams} from \"./TextureParams\";\nimport {createVec4} from \"@xeokit/matrix\";\n\n/**\n * A texture in a {@link SceneModel}.\n *\n * * Stored in {@link @xeokit/scene!SceneModel.textures | SceneModel.textures}\n * * Created with {@link @xeokit/scene!SceneModel.createTexture | SceneModel.createTexture}\n * * Referenced by {@link TextureSet.colorTexture | TextureSet.colorTexture},\n * {@link TextureSet.metallicRoughnessTexture | TextureSet.metallicRoughnessTexture},\n * {@link TextureSet.occlusionTexture | TextureSet.occlusionTexture} and {@link TextureSet.emissiveTexture | TextureSet.emissiveTexture}\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class Texture {\n\n    /**\n     *  Internal interface through which this {@link Texture} can load property updates into a renderer.\n     *\n     *  This is defined when the owner {@link SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.\n     *\n     * @internal\n     */\n    rendererTexture: RendererTexture | null;\n\n    /**\n     * ID for the texture.\n     */\n    id: string;\n\n    /**\n     * Path to an image file.\n     */\n    src?: string;\n\n    /**\n     * Image file data.\n     */\n    imageData?: any;\n\n    /**\n     * Transcoded texture data.\n     */\n    buffers?: ArrayBuffer[];\n\n    /**\n     * HTMLImage containing the texture image.\n     */\n    image?: HTMLImageElement;\n\n    /**\n     * Pixel height of the texture.\n     */\n    height: number;\n\n    /**\n     * Pixel width of the texture.\n     */\n    width: number;\n\n    /**\n     * True if the texture is compressed.\n     */\n    compressed: boolean;\n\n    /**\n     * Media type of this Texture.\n     *\n     * Supported values are {@link GIFMediaType}, {@link PNGMediaType} and {@link JPEGMediaType}.\n     *\n     * Ignored for compressed textures.\n     */\n    mediaType?: number;\n\n    /**\n     * How the texture is sampled when a texel covers more than one pixel.\n     *\n     * Supported values are {@link LinearFilter} and {@link NearestFilter}.\n     */\n    magFilter: number;\n\n    /**\n     * How the texture is sampled when a texel covers less than one pixel. Supported values\n     * are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter},\n     * {@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter}\n     * and {@link LinearMipMapLinearFilter}.\n     *\n     * Ignored for compressed textures.\n     */\n    minFilter: number;\n\n    /**\n     * S wrapping mode.\n     *\n     * Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n     *\n     * Ignored for compressed textures.\n     */\n    wrapS: number;\n\n    /**\n     * T wrapping mode.\n     *\n     * Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n     *\n     * Ignored for compressed textures.\n     */\n    wrapT: number;\n\n    /**\n     * R wrapping mode.\n     *\n     * Supported values are {@link ClampToEdgeWrapping}, {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n     *\n     * Ignored for compressed textures.\n     */\n    wrapR: number;\n\n    /**\n     * Flips this Texture's source data along its vertical axis when ````true````.\n     */\n    flipY: boolean;\n\n    /**\n     * Texture encoding format.\n     *\n     * Supported values are {@link LinearEncoding} and {@link sRGBEncoding}.\n     */\n    encoding: number;\n\n    /**\n     * RGBA color to preload the texture with.\n     */\n    preloadColor: FloatArrayParam;\n\n    /**\n     * @private\n     */\n    channel: number;\n\n    /**\n     * @private\n     */\n    constructor(params: TextureParams) {\n        this.id = params.id;\n        this.imageData = params.imageData;\n        this.src = params.src;\n        this.mediaType = params.mediaType;\n        this.minFilter = params.minFilter || LinearMipMapNearestFilter;\n        this.magFilter = params.magFilter || LinearMipMapNearestFilter;\n        this.wrapS = params.wrapS || RepeatWrapping;\n        this.wrapT = params.wrapT || RepeatWrapping;\n        this.wrapR = params.wrapR || RepeatWrapping\n        this.encoding = params.encoding || LinearEncoding;\n        this.preloadColor = createVec4(params.preloadColor || [1, 1, 1, 1]);\n        this.channel = 0;\n        this.rendererTexture = null;\n    }\n}\n\n","import type {FloatArrayParam} from \"@xeokit/math\";\nimport {createMat4, createVec3, identityMat4} from \"@xeokit/matrix\";\nimport type {RendererMesh} from \"./RendererMesh\";\nimport type {Geometry} from \"./Geometry\";\nimport type {TextureSet} from \"./TextureSet\";\nimport type {SceneObject} from \"./SceneObject\";\n\n/**\n * A mesh in a {@link SceneModel}.\n *\n * * Stored in {@link @xeokit/scene!SceneModel.meshes | SceneModel.meshes}\n * * Created with {@link @xeokit/scene!SceneModel.createMesh | SceneModel.createMesh}\n * * Referenced by {@link @xeokit/scene!SceneModel.meshes | SceneObject.meshes}\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class Mesh {\n\n    /**\n     * Unique ID of this Mesh.\n     *\n     * Mesh is stored by this ID in {@link @xeokit/scene!SceneModel.meshes}.\n     */\n    id: string;\n\n    /**\n     * {@link @xeokit/scene!Geometry} used by this Mesh.\n     */\n    geometry: Geometry;\n\n    /**\n     * {@link @xeokit/scene!TextureSet} used by this Mesh.\n     */\n    textureSet?: TextureSet;\n\n    /**\n     *  Internal interface through which a {@link Mesh} can load property updates into a renderer.\n     *\n     *  This is defined when the owner {@link @xeokit/scene!SceneModel} has been added to a {@link @xeokit/viewer!Viewer | Viewer}.\n     *\n     * @internal\n     */\n    rendererMesh: RendererMesh | null;\n\n    /**\n     * The {@link @xeokit/scene!SceneObject} that uses this Mesh.\n     */\n    object: SceneObject | null;\n\n    #color: FloatArrayParam;\n    #matrix: FloatArrayParam;\n    #metallic: number;\n    #roughness: number;\n    #opacity: number;\n\n    /**\n     * @private\n     */\n    constructor(meshParams: {\n        id: string;\n        geometry: Geometry;\n        textureSet?: TextureSet;\n        matrix?: FloatArrayParam;\n        color?: FloatArrayParam;\n        opacity?: number;\n        roughness?: number;\n        metallic?: number;\n    }) {\n        this.id = meshParams.id;\n        this.#matrix = meshParams.matrix ? createMat4(meshParams.matrix) : identityMat4();\n        this.geometry = meshParams.geometry;\n        this.textureSet = meshParams.textureSet;\n        this.rendererMesh = null;\n\n        this.color = meshParams.color || createVec3([1, 1, 1]);\n        this.metallic = (meshParams.metallic !== null && meshParams.metallic !== undefined) ? meshParams.metallic : 0;\n        this.roughness = (meshParams.roughness !== null && meshParams.roughness !== undefined) ? meshParams.roughness : 1;\n        this.opacity = (meshParams.opacity !== undefined && meshParams.opacity !== null) ? meshParams.opacity : 1.0;\n    }\n\n    /**\n     * Gets the RGB color for this Mesh.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     */\n    get color(): FloatArrayParam {\n        return this.#color;\n    }\n\n    /**\n     * Sets the RGB color for this Mesh.\n     *\n     * Each element of the color is in range ````[0..1]````.\n     */\n    set color(value: FloatArrayParam) {\n        let color = this.#color;\n        if (!color) {\n            color = this.#color = new Float32Array(4);\n            color[3] = 1;\n        }\n        if (value) {\n            color[0] = value[0];\n            color[1] = value[1];\n            color[2] = value[2];\n        } else {\n            color[0] = 1;\n            color[1] = 1;\n            color[2] = 1;\n        }\n        if (this.rendererMesh) {\n            this.rendererMesh.setColor(this.#color);\n        }\n    }\n\n    /**\n     * Gets this Mesh's local modeling transform matrix.\n     *\n     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.\n     *\n     * @type {FloatArrayParam}\n     */\n    get matrix(): FloatArrayParam {\n        return this.#matrix;\n    }\n\n    /**\n     * Updates this Mesh's local modeling transform matrix.\n     *\n     * Default value is ````[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]````.\n     *\n     * @type {FloatArrayParam}\n     */\n    set matrix(matrix: FloatArrayParam) {\n        if (matrix) {\n            // @ts-ignore\n            this.#matrix.set(matrix);\n        } else {\n            identityMat4(this.#matrix);\n        }\n        if (this.rendererMesh) {\n            this.rendererMesh.setMatrix(this.#matrix);\n        }\n        if (this.object) {\n            this.object.setAABBDirty();\n        }\n    }\n\n    /**\n     * Gets this Mesh's metallic factor.\n     *\n     * This is in the range ````[0..1]```` and indicates how metallic this Mesh is.\n     *\n     * ````1```` is metal, ````0```` is non-metal.\n     *\n     * Default value is ````1.0````.\n     */\n    get metallic(): number {\n        return this.#metallic;\n    }\n\n    /**\n     * Sets this Mesh's metallic factor.\n     *\n     * This is in the range ````[0..1]```` and indicates how metallic this Mesh is.\n     *\n     * ````1```` is metal, ````0```` is non-metal.\n     *\n     * Default value is ````1.0````.\n     */\n    set metallic(value: number) {\n        value = (value !== undefined && value !== null) ? value : 1.0;\n        if (this.#metallic === value) {\n            return;\n        }\n        this.#metallic = value;\n        if (this.rendererMesh) {\n            this.rendererMesh.setMetallic(this.#metallic);\n        }\n    }\n\n    /**\n     * Gets this Mesh's roughness factor.\n     *\n     * This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.\n     *\n     * Default value is ````1.0````.\n     */\n    get roughness(): number {\n        return this.#roughness;\n    }\n\n    /**\n     * Sets this Mesh's roughness factor.\n     *\n     * This factor is in the range ````[0..1]````, where ````0```` is fully smooth,````1```` is fully rough.\n     *\n     * Default value is ````1.0````.\n     */\n    set roughness(value: number) {\n        value = (value !== undefined && value !== null) ? value : 1.0;\n        if (this.#roughness === value) {\n            return;\n        }\n        this.#roughness = value;\n        if (this.rendererMesh) {\n            this.rendererMesh.setRoughness(this.#roughness);\n        }\n    }\n\n    /**\n     * Gets the opacity factor for this Mesh.\n     *\n     * This is a factor in range ````[0..1]````.\n     */\n    get opacity(): number {\n        return this.#opacity;\n    }\n\n    /**\n     * Sets the opacity factor for this Mesh.\n     *\n     * This is a factor in range ````[0..1]````.\n     */\n    set opacity(opacity: number) {\n        opacity = (opacity !== undefined && opacity !== null) ? opacity : 1.0;\n        if (this.#opacity === opacity) {\n            return;\n        }\n        this.#opacity = opacity;\n        if (this.rendererMesh) {\n            //       this.rendererMesh.setOpacity(this.#opacity);\n        }\n    }\n}\n","import {DEGTORAD, FloatArrayParam, IntArrayParam} from \"@xeokit/math\";\nimport {createVec3, cross3Vec3, dotVec3, normalizeVec3, subVec3} from \"@xeokit/matrix\";\nimport {decompressPoint3} from \"@xeokit/compression\";\n\nconst uniquePositions: number[] = [];\nconst indicesLookup: number[] = [];\nconst indicesReverseLookup: number[] = [];\nconst weldedIndices: number[] = [];\n\n// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\nconst faces: { normal: number[]; }[] = [];\nlet numFaces = 0;\nconst compa = new Uint16Array(3);\nconst compb = new Uint16Array(3);\nconst compc = new Uint16Array(3);\nconst a = createVec3();\nconst b = createVec3();\nconst c = createVec3();\nconst cb = createVec3();\nconst ab = createVec3();\nconst cross = createVec3();\nconst normal = createVec3();\n\nfunction weldVertices(positions: FloatArrayParam, indices: IntArrayParam) {\n    const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n    let vx;\n    let vy;\n    let vz;\n    let key;\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = Math.pow(10, precisionPoints);\n    let i;\n    let len;\n    let lenUniquePositions = 0;\n    for (i = 0, len = positions.length; i < len; i += 3) {\n        vx = positions[i];\n        vy = positions[i + 1];\n        vz = positions[i + 2];\n        key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n        // @ts-ignore\n        if (positionsMap[key] === undefined) {\n            // @ts-ignore\n            positionsMap[key] = lenUniquePositions / 3;\n            uniquePositions[lenUniquePositions++] = vx;\n            uniquePositions[lenUniquePositions++] = vy;\n            uniquePositions[lenUniquePositions++] = vz;\n        }\n        // @ts-ignore\n        indicesLookup[i / 3] = positionsMap[key];\n    }\n    for (i = 0, len = indices.length; i < len; i++) {\n        weldedIndices[i] = indicesLookup[indices[i]];\n        indicesReverseLookup[weldedIndices[i]] = indices[i];\n    }\n}\n\nfunction buildFaces(numIndices: number, positionsDecompressMatrix: FloatArrayParam) {\n    numFaces = 0;\n    for (let i = 0, len = numIndices; i < len; i += 3) {\n        const ia = ((weldedIndices[i]) * 3);\n        const ib = ((weldedIndices[i + 1]) * 3);\n        const ic = ((weldedIndices[i + 2]) * 3);\n        if (positionsDecompressMatrix) {\n            compa[0] = uniquePositions[ia];\n            compa[1] = uniquePositions[ia + 1];\n            compa[2] = uniquePositions[ia + 2];\n            compb[0] = uniquePositions[ib];\n            compb[1] = uniquePositions[ib + 1];\n            compb[2] = uniquePositions[ib + 2];\n            compc[0] = uniquePositions[ic];\n            compc[1] = uniquePositions[ic + 1];\n            compc[2] = uniquePositions[ic + 2];\n            // Decode\n            decompressPoint3(compa, positionsDecompressMatrix, a);\n            decompressPoint3(compb, positionsDecompressMatrix, b);\n            decompressPoint3(compc, positionsDecompressMatrix, c);\n        } else {\n            a[0] = uniquePositions[ia];\n            a[1] = uniquePositions[ia + 1];\n            a[2] = uniquePositions[ia + 2];\n            b[0] = uniquePositions[ib];\n            b[1] = uniquePositions[ib + 1];\n            b[2] = uniquePositions[ib + 2];\n            c[0] = uniquePositions[ic];\n            c[1] = uniquePositions[ic + 1];\n            c[2] = uniquePositions[ic + 2];\n        }\n        subVec3(c, b, cb);\n        subVec3(a, b, ab);\n        cross3Vec3(cb, ab, cross);\n        normalizeVec3(cross, normal);\n        // @ts-ignore\n        const face = faces[numFaces] || (faces[numFaces] = {normal: createVec3()});\n        face.normal[0] = normal[0];\n        face.normal[1] = normal[1];\n        face.normal[2] = normal[2];\n        numFaces++;\n    }\n}\n\n\n/**\n * Builds edge connectivity indices from a 3D triangle mesh given as vertex positions and triangle indices\n * @private\n */\nexport function buildEdgeIndices(\n    positions: FloatArrayParam,\n    indices: IntArrayParam,\n    positionsDecompressMatrix: FloatArrayParam,\n    edgeThreshold: number): IntArrayParam {\n\n    weldVertices(positions, indices);\n    buildFaces(indices.length, positionsDecompressMatrix);\n\n    const edgeIndices = [];\n    const thresholdDot = Math.cos(DEGTORAD * edgeThreshold);\n    const edges = {};\n\n    let edge1;\n    let edge2;\n    let index1;\n    let index2;\n    let key;\n    let largeIndex = false;\n    let edge;\n    let normal1;\n    let normal2;\n    let dot;\n    let ia;\n    let ib;\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n        const faceIndex = i / 3;\n        for (let j = 0; j < 3; j++) {\n            edge1 = weldedIndices[i + j];\n            edge2 = weldedIndices[i + ((j + 1) % 3)];\n            index1 = Math.min(edge1, edge2);\n            index2 = Math.max(edge1, edge2);\n            key = index1 + \",\" + index2;\n            // @ts-ignore\n            if (edges[key] === undefined) {\n                // @ts-ignore\n                edges[key] = {\n                    index1: index1,\n                    index2: index2,\n                    face1: faceIndex,\n                    face2: undefined\n                };\n            } else {\n                // @ts-ignore\n                edges[key].face2 = faceIndex;\n            }\n        }\n    }\n\n    for (key in edges) {\n        // @ts-ignore\n        edge = edges[key];\n        // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n        if (edge.face2 !== undefined) {\n            normal1 = faces[edge.face1].normal;\n            normal2 = faces[edge.face2].normal;\n            dot = dotVec3(normal1, normal2);\n            if (dot > thresholdDot) {\n                continue;\n            }\n        }\n        ia = indicesReverseLookup[edge.index1];\n        ib = indicesReverseLookup[edge.index2];\n        if (!largeIndex && ia > 65535 || ib > 65535) {\n            largeIndex = true;\n        }\n        edgeIndices.push(ia);\n        edgeIndices.push(ib);\n    }\n\n    return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n}","/**\n * @author https://github.com/tmarti, with support from https://tribia.com/\n * @license MIT\n *\n * This file takes a geometry given by { positions, indices }, and returns\n * equivalent { positions, indices } arrays but which only contain unique\n * positions.\n *\n * The time is O(N logN) with the number of positions due to a pre-sorting\n * step, but is much more GC-friendly and actually faster than the classic O(N)\n * approach based in keeping a hash-based LUT to identify unique positions.\n */\n\nlet comparePositions: any = null;\n\n\n/**\n * This function obtains unique positions in the provided object\n * .positions array and calculates an index mapping, which is then\n * applied to the provided object .indices and .edgeindices.\n *\n * The input object items are not modified, and instead new set\n * of positions, indices and edgeIndices with the applied optimization\n * are returned.\n *\n * The algorithm, instead of being based in a hash-like LUT for\n * identifying unique positions, is based in pre-sorting the input\n * positions...\n *\n * (it's possible to define a _\"consistent ordering\"_ for the positions\n *  as positions are quantized and thus not suffer from float number\n *  comparison artifacts)\n *\n * ... so same positions are adjacent in the sorted array, and then\n * it's easy to scan linearly the sorted array. During the linear run,\n * we will know that we found a different position because the comparison\n * function will return != 0 between current and previous element.\n *\n * During this linear traversal of the array, a `unique counter` is used\n * in order to calculate the mapping between original indices and unique\n * indices.\n *\n * @param {*} mesh The input mesh to process, with `positions`, `indices` and `edgeIndices` keys.\n * @private\n * @returns An array with 3 elements: 0 => the uniquified positions; 1 and 2 => the remapped edges and edgeIndices arrays\n */\nexport function uniquifyPositions(mesh: any): [Uint16Array, Uint32Array, Uint32Array | undefined] {\n\n    let positionsCompressed = mesh.positionsCompressed;\n    let indices = mesh.indices;\n    let edgeIndices = mesh.edgeIndices;\n\n    setMaxNumberOfPositions(positionsCompressed.length / 3);\n\n    let seq = seqInit.slice(0, positionsCompressed.length / 3);\n    let remappings = seqInit.slice(0, positionsCompressed.length / 3);\n\n    comparePositions = positionsCompressed;\n\n    seq.sort(compareVertex);\n\n    let uniqueIdx = 0\n\n    remappings[seq[0]] = 0;\n\n    for (let i = 1, len = seq.length; i < len; i++) {\n        if (0 != compareVertex(seq[i], seq[i - 1])) {\n            uniqueIdx++;\n        }\n\n        remappings[seq[i]] = uniqueIdx;\n    }\n\n    const numUniquePositions = uniqueIdx + 1;\n\n    const uniquePositionsCompressed = new Uint16Array(numUniquePositions * 3);\n\n    uniqueIdx = 0\n\n    uniquePositionsCompressed [uniqueIdx * 3 + 0] = positionsCompressed [seq[0] * 3 + 0];\n    uniquePositionsCompressed [uniqueIdx * 3 + 1] = positionsCompressed [seq[0] * 3 + 1];\n    uniquePositionsCompressed [uniqueIdx * 3 + 2] = positionsCompressed [seq[0] * 3 + 2];\n\n    for (let i = 1, len = seq.length; i < len; i++) {\n        if (0 !== compareVertex(seq[i], seq[i - 1])) {\n            uniqueIdx++;\n\n            uniquePositionsCompressed [uniqueIdx * 3 + 0] = positionsCompressed [seq[i] * 3 + 0];\n            uniquePositionsCompressed [uniqueIdx * 3 + 1] = positionsCompressed [seq[i] * 3 + 1];\n            uniquePositionsCompressed [uniqueIdx * 3 + 2] = positionsCompressed [seq[i] * 3 + 2];\n        }\n\n        remappings[seq[i]] = uniqueIdx;\n    }\n\n    comparePositions = null;\n\n    let uniqueIndices = new Uint32Array(indices.length);\n\n    for (let i = 0, len = indices.length; i < len; i++) {\n        uniqueIndices[i] = remappings [indices[i]];\n    }\n\n    let uniqueEdgeIndices;\n\n    if (edgeIndices) {\n        uniqueEdgeIndices = new Uint32Array(edgeIndices.length);\n        for (let i = 0, len = edgeIndices.length; i < len; i++) {\n            uniqueEdgeIndices[i] = remappings [edgeIndices[i]];\n        }\n    }\n    return [\n        uniquePositionsCompressed,\n        uniqueIndices,\n        uniqueEdgeIndices\n    ];\n}\n\n\nfunction compareVertex(a: any, b: any) {\n    let res;\n\n    for (let i = 0; i < 3; i++) {\n        if (0 != (res = comparePositions[a * 3 + i] - comparePositions[b * 3 + i])) {\n            return res;\n        }\n    }\n\n    return 0;\n}\n\nlet seqInit: any = null;\n\nfunction setMaxNumberOfPositions(maxPositions: any) {\n    if (seqInit !== null && seqInit.length >= maxPositions) {\n        return;\n    }\n\n    seqInit = new Uint32Array(maxPositions);\n\n    for (let i = 0; i < maxPositions; i++) {\n        seqInit[i] = i;\n    }\n}\n\n","/**\n * @author https://github.com/tmarti, with support from https://tribia.com/\n * @license MIT\n **/\nimport type {IntArrayParam} from \"@xeokit/math\";\n\n\nconst MAX_RE_BUCKET_FAN_OUT = 8;\n\nlet bucketsForIndices: any = null;\n\nexport function rebucketPositions(\n    mesh: {\n        positionsCompressed: IntArrayParam,\n        indices: IntArrayParam,\n        edgeIndices?: IntArrayParam,\n    },\n    bitsPerBucket: any,\n    checkResult = false): {\n    positionsCompressed: IntArrayParam,\n    indices: IntArrayParam,\n    edgeIndices?: IntArrayParam\n}[] {\n\n    const positionsCompressed = (mesh.positionsCompressed || []);\n    const indices = preSortIndices(mesh.indices || [], bitsPerBucket);\n    const edgeIndices: any = [];//preSortEdgeIndices(mesh.edgeIndices || []);\n\n    /**\n     * Code adapted from https://stackoverflow.com/questions/22697936/binary-search-in-javascript\n     */\n    function edgeSearch(el0: any, el1: any) {\n        if (el0 > el1) {\n            let tmp = el0;\n            el0 = el1;\n            el1 = tmp;\n        }\n\n        function compare_fn(a: any, b: any) {\n            if (a != el0) {\n                return el0 - a;\n            }\n\n            if (b != el1) {\n                return el1 - b;\n            }\n\n            return 0;\n        }\n\n        var m = 0;\n        var n = (edgeIndices.length >> 1) - 1;\n        while (m <= n) {\n            var k = (n + m) >> 1;\n            var cmp = compare_fn(edgeIndices[k * 2], edgeIndices[k * 2 + 1]);\n            if (cmp > 0) {\n                m = k + 1;\n            } else if (cmp < 0) {\n                n = k - 1;\n            } else {\n                return k;\n                /**\n                 * Flat array of compressed integer vertex colors.\n                 *\n                 * Alternative to {@link @xeokit/scene!GeometryParams.colorsCompressed}.\n                 *\n                 * Ignored when {@link @xeokit/scene!GeometryParams.id} is defined.\n                 */\n            }\n        }\n        return -m - 1;\n    }\n\n    // console.log (edgeIndices);\n\n    // throw (e);\n\n    // console.log (`${mesh.edgeIndices.length / 2} edge indices`);\n    // console.log (`${edgeIndices.length / 2} edge indices sorted`);\n\n    const alreadyOutputEdgeIndices = new Int32Array(edgeIndices.length / 2);\n    alreadyOutputEdgeIndices.fill(0);\n\n    const numPositions = positionsCompressed.length / 3;\n\n    if (numPositions > ((1 << bitsPerBucket) * MAX_RE_BUCKET_FAN_OUT)) {\n        return [mesh];\n    }\n\n    const bucketIndicesRemap = new Int32Array(numPositions);\n    bucketIndicesRemap.fill(-1);\n\n    const buckets: any = [];\n\n    function addEmptyBucket() {\n        bucketIndicesRemap.fill(-1);\n\n        let newBucket: any = {\n            positionsCompressed: [],\n            indices: [],\n            edgeIndices: [],\n            maxNumPositions: (1 << bitsPerBucket) - bitsPerBucket,\n            numPositions: 0,\n            bucketNumber: buckets.length\n        };\n\n        buckets.push(newBucket);\n\n        return newBucket;\n    }\n\n    let currentBucket = addEmptyBucket();\n\n    // let currentBucket = 0;\n\n    let retVal = 0;\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n        let additonalPositionsInBucket = 0;\n\n        const ii0 = indices[i];\n        const ii1 = indices[i + 1];\n        const ii2 = indices[i + 2];\n\n        if (bucketIndicesRemap[ii0] == -1) {\n            additonalPositionsInBucket++;\n        }\n\n        if (bucketIndicesRemap[ii1] == -1) {\n            additonalPositionsInBucket++;\n        }\n\n        if (bucketIndicesRemap[ii2] == -1) {\n            additonalPositionsInBucket++;\n        }\n\n        if ((additonalPositionsInBucket + currentBucket.numPositions) > currentBucket.maxNumPositions) {\n            currentBucket = addEmptyBucket();\n        }\n\n        if (currentBucket.bucketNumber > MAX_RE_BUCKET_FAN_OUT) {\n            return [mesh];\n        }\n\n        if (bucketIndicesRemap[ii0] == -1) {\n            bucketIndicesRemap[ii0] = currentBucket.numPositions++;\n            currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3 + 1]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii0 * 3 + 2]);\n        }\n\n        if (bucketIndicesRemap[ii1] == -1) {\n            bucketIndicesRemap[ii1] = currentBucket.numPositions++;\n            currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3 + 1]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii1 * 3 + 2]);\n        }\n\n        if (bucketIndicesRemap[ii2] == -1) {\n            bucketIndicesRemap[ii2] = currentBucket.numPositions++;\n            currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3 + 1]);\n            currentBucket.positionsCompressed.push(positionsCompressed[ii2 * 3 + 2]);\n        }\n\n        currentBucket.indices.push(bucketIndicesRemap[ii0]);\n        currentBucket.indices.push(bucketIndicesRemap[ii1]);\n        currentBucket.indices.push(bucketIndicesRemap[ii2]);\n\n        // Check possible edge1\n        let edgeIndex;\n\n        if ((edgeIndex = edgeSearch(ii0, ii1)) >= 0) {\n            if (alreadyOutputEdgeIndices[edgeIndex] == 0) {\n                alreadyOutputEdgeIndices[edgeIndex] = 1;\n\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);\n            }\n        }\n\n        if ((edgeIndex = edgeSearch(ii0, ii2)) >= 0) {\n            if (alreadyOutputEdgeIndices[edgeIndex] == 0) {\n                alreadyOutputEdgeIndices[edgeIndex] = 1;\n\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);\n            }\n        }\n\n        if ((edgeIndex = edgeSearch(ii1, ii2)) >= 0) {\n            if (alreadyOutputEdgeIndices[edgeIndex] == 0) {\n                alreadyOutputEdgeIndices[edgeIndex] = 1;\n\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2]]);\n                currentBucket.edgeIndices.push(bucketIndicesRemap[edgeIndices[edgeIndex * 2 + 1]]);\n            }\n        }\n    }\n\n    const prevBytesPerIndex = bitsPerBucket / 8 * 2;\n    const newBytesPerIndex = bitsPerBucket / 8;\n\n    const originalSize = positionsCompressed.length * 2 + (indices.length + edgeIndices.length) * prevBytesPerIndex;\n\n    let newSize = 0;\n    let newPositions = -positionsCompressed.length / 3;\n\n    buckets.forEach((bucket: any) => {\n        newSize += bucket.positionsCompressed.length * 2 + (bucket.indices.length + bucket.edgeIndices.length) * newBytesPerIndex;\n        newPositions += bucket.positionsCompressed.length / 3;\n    });\n\n    if (newSize > originalSize) {\n        return [mesh];\n    }\n\n    // console.log (\"added positions \" + newPositions + \", buckets: \" + buckets.length);\n\n    if (checkResult) {\n        doCheckResult(buckets, mesh);\n    }\n\n    // return [ mesh ];\n\n    return buckets;\n}\n\nfunction compareBuckets(a: any, b: any) {\n    let aa = a * 3;\n    let bb = b * 3;\n    let aa1, aa2, aa3, bb1, bb2, bb3;\n    const minBucketA = Math.min(\n        aa1 = bucketsForIndices[aa],\n        aa2 = bucketsForIndices[aa + 1],\n        aa3 = bucketsForIndices[aa + 2]\n    );\n    const minBucketB = Math.min(\n        bb1 = bucketsForIndices[bb],\n        bb2 = bucketsForIndices[bb + 1],\n        bb3 = bucketsForIndices[bb + 2]\n    );\n    if (minBucketA != minBucketB) {\n        return minBucketA - minBucketB;\n    }\n    const maxBucketA = Math.max(\n        aa1,\n        aa2,\n        aa3,\n    );\n    const maxBucketB = Math.max(\n        bb1,\n        bb2,\n        bb3,\n    );\n    if (maxBucketA != maxBucketB) {\n        return maxBucketA - maxBucketB;\n    }\n    return 0;\n}\n\nfunction preSortIndices(indices: any, bitsPerBucket: any) {\n    let seq = new Int32Array(indices.length / 3);\n    for (let i = 0, len = seq.length; i < len; i++) {\n        seq[i] = i;\n    }\n    bucketsForIndices = new Int32Array(indices.length);\n    for (let i = 0, len = indices.length; i < len; i++) {\n        bucketsForIndices[i] = indices[i] >> bitsPerBucket;\n    }\n    seq.sort(compareBuckets);\n    const sortedIndices = new Int32Array(indices.length);\n    for (let i = 0, len = seq.length; i < len; i++) {\n        sortedIndices[i * 3 + 0] = indices[seq[i] * 3 + 0];\n        sortedIndices[i * 3 + 1] = indices[seq[i] * 3 + 1];\n        sortedIndices[i * 3 + 2] = indices[seq[i] * 3 + 2];\n    }\n    return sortedIndices;\n}\n\nlet compareEdgeIndices: any = null;\n\nfunction compareIndices(a: any, b: any) {\n    let retVal = compareEdgeIndices[a * 2] - compareEdgeIndices[b * 2];\n    if (retVal != 0) {\n        return retVal;\n    }\n    return compareEdgeIndices[a * 2 + 1] - compareEdgeIndices[b * 2 + 1];\n}\n\nfunction preSortEdgeIndices(edgeIndices: any): any {\n    if ((edgeIndices || []).length == 0) {\n        return [];\n    }\n    let seq = new Int32Array(edgeIndices.length / 2);\n    for (let i = 0, len = seq.length; i < len; i++) {\n        seq[i] = i;\n    }\n    for (let i = 0, j = 0, len = edgeIndices.length; i < len; i += 2) {\n        if (edgeIndices[i] > edgeIndices[i + 1]) {\n            let tmp = edgeIndices[i];\n            edgeIndices[i] = edgeIndices[i + 1];\n            edgeIndices[i + 1] = tmp;\n        }\n    }\n    compareEdgeIndices = new Int32Array(edgeIndices);\n    seq.sort(compareIndices);\n    const sortedEdgeIndices = new Int32Array(edgeIndices.length);\n    for (let i = 0, len = seq.length; i < len; i++) {\n        sortedEdgeIndices[i * 2 + 0] = edgeIndices[seq[i] * 2 + 0];\n        sortedEdgeIndices[i * 2 + 1] = edgeIndices[seq[i] * 2 + 1];\n    }\n    return sortedEdgeIndices;\n}\n\n\nfunction unbucket(buckets: any) {\n    let positionsCompressed: any = [];\n    let indices: any = [];\n    let edgeIndices: any = [];\n\n    let positionsBase = 0;\n\n    buckets.forEach((bucket: any) => {\n        bucket.positionsCompressed.forEach((coord: any) => {\n            positionsCompressed.push(coord);\n        });\n\n        bucket.indices.forEach((index: any) => {\n            indices.push(index + positionsBase);\n        });\n\n        bucket.edgeIndices.forEach((edgeIndex: any) => {\n            edgeIndices.push(edgeIndex + positionsBase);\n        });\n\n        positionsBase += positionsCompressed.length / 3;\n    });\n\n    return {\n        positionsCompressed,\n        indices,\n        edgeIndices\n    };\n}\n\nfunction doCheckResult(buckets: any, mesh: any) {\n    const meshDict: any = {};\n    const edgesDict: any = {};\n\n    let edgeIndicesCount = 0;\n\n    buckets.forEach((bucket: any) => {\n        let indices = bucket.indices;\n        let edgeIndices = bucket.edgeIndices;\n        let positionsCompressed = bucket.positionsCompressed;\n\n        for (var i = 0, len = indices.length; i < len; i += 3) {\n            var key = positionsCompressed[indices[i] * 3] + \"_\" + positionsCompressed[indices[i] * 3 + 1] + \"_\" + positionsCompressed[indices[i] * 3 + 2] + \"/\" +\n                positionsCompressed[indices[i + 1] * 3] + \"_\" + positionsCompressed[indices[i + 1] * 3 + 1] + \"_\" + positionsCompressed[indices[i + 1] * 3 + 2] + \"/\" +\n                positionsCompressed[indices[i + 2] * 3] + \"_\" + positionsCompressed[indices[i + 2] * 3 + 1] + \"_\" + positionsCompressed[indices[i + 2] * 3 + 2];\n\n            meshDict[key] = true;\n        }\n\n        edgeIndicesCount += bucket.edgeIndices.length / 2;\n\n        for (var i = 0, len = edgeIndices.length; i < len; i += 2) {\n            var key = positionsCompressed[edgeIndices[i] * 3] + \"_\" + positionsCompressed[edgeIndices[i] * 3 + 1] + \"_\" + positionsCompressed[edgeIndices[i] * 3 + 2] + \"/\" +\n                positionsCompressed[edgeIndices[i + 1] * 3] + \"_\" + positionsCompressed[edgeIndices[i + 1] * 3 + 1] + \"_\" + positionsCompressed[edgeIndices[i + 1] * 3 + 2] + \"/\";\n\n            edgesDict[key] = true;\n        }\n    });\n\n    {\n        let indices = mesh.indices;\n        let edgeIndices = mesh.edgeIndices;\n        let positionsCompressed = mesh.positionsCompressed;\n\n        for (var i = 0, len = indices.length; i < len; i += 3) {\n            var key = positionsCompressed[indices[i] * 3] + \"_\" + positionsCompressed[indices[i] * 3 + 1] + \"_\" + positionsCompressed[indices[i] * 3 + 2] + \"/\" +\n                positionsCompressed[indices[i + 1] * 3] + \"_\" + positionsCompressed[indices[i + 1] * 3 + 1] + \"_\" + positionsCompressed[indices[i + 1] * 3 + 2] + \"/\" +\n                positionsCompressed[indices[i + 2] * 3] + \"_\" + positionsCompressed[indices[i + 2] * 3 + 1] + \"_\" + positionsCompressed[indices[i + 2] * 3 + 2];\n\n            if (!(key in meshDict)) {\n                console.log(\"Not found \" + key);\n                throw \"Ohhhh!\";\n            }\n        }\n\n        //  for (var i = 0, len = edgeIndices.length; i < len; i+=2)\n        //  {\n        //      var key = positionsCompressed[edgeIndices[i]*3] + \"_\" + positionsCompressed[edgeIndices[i]*3+1] + \"_\" + positionsCompressed[edgeIndices[i]*3+2] + \"/\" +\n        //                positionsCompressed[edgeIndices[i+1]*3] + \"_\" + positionsCompressed[edgeIndices[i+1]*3+1] + \"_\" + positionsCompressed[edgeIndices[i+1]*3+2] + \"/\";\n\n        //      if (!(key in edgesDict)) {\n        //          var key2 = edgeIndices[i] + \"_\" + edgeIndices[i+1];\n\n        //          console.log (\"   - Not found \" + key);\n        //          console.log (\"   - Not found \" + key2);\n        //         //  throw \"Ohhhh2!\";\n        //      }\n        //  }\n    }\n}\n\n","import {createMat4} from \"@xeokit/matrix\";\nimport {collapseAABB3, expandAABB3Points3} from \"@xeokit/boundaries\";\nimport {SolidPrimitive, SurfacePrimitive, TrianglesPrimitive} from \"@xeokit/constants\";\nimport {quantizePositions3} from \"@xeokit/compression\";\n\nimport {buildEdgeIndices} from \"./buildEdgeIndices\";\nimport {uniquifyPositions} from \"./calculateUniquePositions\";\nimport {rebucketPositions} from \"./rebucketPositions\";\nimport type {GeometryParams} from \"./GeometryParams\";\nimport type {GeometryCompressedParams} from \"./GeometryCompressedParams\";\nimport type {IntArrayParam} from \"@xeokit/math\";\n\n/**\n * Compresses a {@link @xeokit/scene!GeometryParams | GeometryParams} into a {@link @xeokit/scene!GeometryCompressedParams | GeometryCompressedParams}.\n *\n * See {@link @xeokit/scene} for usage examples.\n *\n * @param geometryParams Uncompressed geometry params.\n * @returns Compressed geometry params.\n */\nexport function compressGeometryParams(geometryParams: GeometryParams): GeometryCompressedParams {\n    const positionsDecompressMatrix = createMat4();\n    const aabb = collapseAABB3();\n    expandAABB3Points3(aabb, geometryParams.positions);\n    const positionsCompressed = quantizePositions3(geometryParams.positions, aabb, positionsDecompressMatrix);\n    const edgeIndices = (geometryParams.primitive === SolidPrimitive || geometryParams.primitive === SurfacePrimitive || geometryParams.primitive === TrianglesPrimitive) && geometryParams.indices\n        ? buildEdgeIndices(positionsCompressed, geometryParams.indices, positionsDecompressMatrix, 10)\n        : null;\n    let uniquePositionsCompressed: IntArrayParam;\n    let uniqueIndices: Uint32Array;\n    let uniqueEdgeIndices: Uint32Array | undefined;\n    [\n        uniquePositionsCompressed,\n        uniqueIndices,\n        uniqueEdgeIndices\n    ] = uniquifyPositions({\n        positionsCompressed,\n        uvs: geometryParams.uvs,\n        indices: geometryParams.indices,\n        edgeIndices: edgeIndices\n    });\n    const numUniquePositions = uniquePositionsCompressed.length / 3;\n    const geometryBuckets = <{\n        positionsCompressed: IntArrayParam,\n        indices: IntArrayParam,\n        edgeIndices: IntArrayParam\n    }[]>rebucketPositions({\n        positionsCompressed: uniquePositionsCompressed,\n        indices: uniqueIndices,\n        edgeIndices: uniqueEdgeIndices,\n    }, (numUniquePositions > (1 << 16)) ? 16 : 8);\n    return { // Assume that closed triangle mesh is decomposed into open surfaces\n        id: geometryParams.id,\n        primitive: (geometryParams.primitive === SolidPrimitive && geometryBuckets.length > 1) ? TrianglesPrimitive : geometryParams.primitive,\n        aabb,\n        positionsDecompressMatrix,\n        uvsDecompressMatrix: undefined,\n        geometryBuckets\n    };\n}","\n\nconst isBoolean = x => typeof x === 'boolean';\nconst isFunction = x => typeof x === 'function';\nexport const isObject = x => x !== null && typeof x === 'object';\nexport const isPureObject = x => isObject(x) && x.constructor === {}.constructor;\nexport const isPromise = x => isObject(x) && isFunction(x.then);\nexport const isIterable = x => x && typeof x[Symbol.iterator] === 'function';\nexport const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';\nexport const isIterator = x => x && isFunction(x.next);\nexport const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;\nexport const isFile = x => typeof File !== 'undefined' && x instanceof File;\nexport const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;\n\nexport const isBuffer = x => x && typeof x === 'object' && x.isBuffer;\nexport const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\nexport const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);\n\nexport const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\nexport const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nexport const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);\nexport const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);\n//# sourceMappingURL=is-type.js.map","\n\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\n\nexport function parseMIMEType(mimeString) {\n  const matches = MIME_TYPE_PATTERN.exec(mimeString);\n  if (matches) {\n    return matches[1];\n  }\n  return mimeString;\n}\n\nexport function parseMIMETypeFromURL(url) {\n  const matches = DATA_URL_PATTERN.exec(url);\n  if (matches) {\n    return matches[1];\n  }\n  return '';\n}\n//# sourceMappingURL=mime-type-utils.js.map","import { isResponse, isBlob } from '../../javascript-utils/is-type';\nimport { parseMIMEType, parseMIMETypeFromURL } from './mime-type-utils';\nconst QUERY_STRING_PATTERN = /\\?.*/;\n\nexport function getResourceUrlAndType(resource) {\n  if (isResponse(resource)) {\n    const url = stripQueryString(resource.url || '');\n    const contentTypeHeader = resource.headers.get('content-type') || '';\n    return {\n      url,\n      type: parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(url)\n    };\n  }\n\n  if (isBlob(resource)) {\n    return {\n      url: stripQueryString(resource.name || ''),\n      type: resource.type || ''\n    };\n  }\n  if (typeof resource === 'string') {\n    return {\n      url: stripQueryString(resource),\n      type: parseMIMETypeFromURL(resource)\n    };\n  }\n\n  return {\n    url: '',\n    type: ''\n  };\n}\n\nexport function getResourceContentLength(resource) {\n  if (isResponse(resource)) {\n    return resource.headers['content-length'] || -1;\n  }\n  if (isBlob(resource)) {\n    return resource.size;\n  }\n  if (typeof resource === 'string') {\n    return resource.length;\n  }\n  if (resource instanceof ArrayBuffer) {\n    return resource.byteLength;\n  }\n  if (ArrayBuffer.isView(resource)) {\n    return resource.byteLength;\n  }\n  return -1;\n}\nfunction stripQueryString(url) {\n  return url.replace(QUERY_STRING_PATTERN, '');\n}\n//# sourceMappingURL=resource-utils.js.map","import { isResponse } from '../../javascript-utils/is-type';\nimport { getResourceContentLength, getResourceUrlAndType } from './resource-utils';\n\nexport async function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  if (typeof resource === 'string') {\n    resource = new TextEncoder().encode(resource);\n  }\n\n  const response = new Response(resource, {\n    headers\n  });\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\n\nexport async function checkResponse(response) {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    let message = \"\".concat(response.status, \" \").concat(response.statusText);\n    message = message.length > 60 ? \"\".concat(message.slice(0, 60), \"...\") : message;\n    throw new Error(message);\n  }\n}\n\nasync function getResponseError(response) {\n  let message = \"Failed to fetch resource \".concat(response.url, \" (\").concat(response.status, \"): \");\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += \" \".concat(await response.text());\n    }\n    message += text;\n    message = message.length > 60 ? \"\".concat(message.slice(0, 60), \"...\") : message;\n  } catch (error) {\n  }\n  return message;\n}\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return \"data:,\".concat(resource.slice(0, INITIAL_DATA_LENGTH));\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onload = event => {\n        var _event$target;\n        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n      };\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return \"data:base64,\".concat(base64);\n  }\n  return null;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n//# sourceMappingURL=response-utils.js.map","import { resolvePath } from '@loaders.gl/loader-utils';\nimport { makeResponse } from '../utils/response-utils';\n\nexport async function fetchFile(url, options) {\n  if (typeof url === 'string') {\n    url = resolvePath(url);\n    let fetchOptions = options;\n    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {\n      fetchOptions = options.fetch;\n    }\n    return await fetch(url, fetchOptions);\n  }\n  return await makeResponse(url);\n}\n//# sourceMappingURL=fetch-file.js.map","import isElectron from './is-electron';\nexport default function isBrowser() {\n  const isNode = typeof process === 'object' && String(process) === '[object process]' && !process.browser;\n  return !isNode || isElectron();\n}\nexport function isBrowserMainThread() {\n  return isBrowser() && typeof document !== 'undefined';\n}\n//# sourceMappingURL=is-browser.js.map","export default function isElectron(mockUserAgent) {\n  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions['electron'])) {\n    return true;\n  }\n\n  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;\n  const userAgent = mockUserAgent || realUserAgent;\n\n  if (userAgent && userAgent.indexOf('Electron') >= 0) {\n    return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=is-electron.js.map","const globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document,\n  process: typeof process === 'object' && process\n};\nconst global_ = globalThis;\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst document_ = globals.document || {};\nconst process_ = globals.process || {};\nconst console_ = console;\nexport { self_ as self, window_ as window, global_ as global, document_ as document, process_ as process, console_ as console };\n//# sourceMappingURL=globals.js.map","import checkIfBrowser from '../lib/is-browser';\nexport { self, window, global, document, process, console } from '../lib/globals';\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';\nexport const isBrowser = checkIfBrowser();\n//# sourceMappingURL=globals.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction getStorage(type) {\n  try {\n    const storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return storage;\n  } catch (e) {\n    return null;\n  }\n}\n\nexport class LocalStorage {\n  constructor(id, defaultConfig) {\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';\n\n    _defineProperty(this, \"storage\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    this.storage = getStorage(type);\n    this.id = id;\n    this.config = defaultConfig;\n\n    this._loadConfiguration();\n  }\n\n  getConfiguration() {\n    return this.config;\n  }\n\n  setConfiguration(configuration) {\n    Object.assign(this.config, configuration);\n\n    if (this.storage) {\n      const serialized = JSON.stringify(this.config);\n      this.storage.setItem(this.id, serialized);\n    }\n  }\n\n  _loadConfiguration() {\n    let configuration = {};\n\n    if (this.storage) {\n      const serializedConfiguration = this.storage.getItem(this.id);\n      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};\n    }\n\n    Object.assign(this.config, configuration);\n    return this;\n  }\n\n}\n//# sourceMappingURL=local-storage.js.map","export function formatTime(ms) {\n  let formatted;\n\n  if (ms < 10) {\n    formatted = \"\".concat(ms.toFixed(2), \"ms\");\n  } else if (ms < 100) {\n    formatted = \"\".concat(ms.toFixed(1), \"ms\");\n  } else if (ms < 1000) {\n    formatted = \"\".concat(ms.toFixed(0), \"ms\");\n  } else {\n    formatted = \"\".concat((ms / 1000).toFixed(2), \"s\");\n  }\n\n  return formatted;\n}\nexport function leftPad(string) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const padLength = Math.max(length - string.length, 0);\n  return \"\".concat(' '.repeat(padLength)).concat(string);\n}\nexport function rightPad(string) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const padLength = Math.max(length - string.length, 0);\n  return \"\".concat(string).concat(' '.repeat(padLength));\n}\nexport function formatValue(v) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const EPSILON = 1e-16;\n  const {\n    isInteger = false\n  } = opts;\n\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n\nfunction formatArrayValue(v, opts) {\n  const {\n    maxElts = 16,\n    size = 1\n  } = opts;\n  let string = '[';\n\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += \",\".concat(i % size === 0 ? ' ' : '');\n    }\n\n    string += formatValue(v[i], opts);\n  }\n\n  const terminator = v.length > maxElts ? '...' : ']';\n  return \"\".concat(string).concat(terminator);\n}\n\nexport function formatImage(image, message, scale) {\n  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;\n  const imageUrl = image.src.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n\n  if (image.width > maxWidth) {\n    scale = Math.min(scale, maxWidth / image.width);\n  }\n\n  const width = image.width * scale;\n  const height = image.height * scale;\n  const style = ['font-size:1px;', \"padding:\".concat(Math.floor(height / 2), \"px \").concat(Math.floor(width / 2), \"px;\"), \"line-height:\".concat(height, \"px;\"), \"background:url(\".concat(imageUrl, \");\"), \"background-size:\".concat(width, \"px \").concat(height, \"px;\"), 'color:transparent;'].join('');\n  return [\"\".concat(message, \" %c+\"), style];\n}\n//# sourceMappingURL=formatters.js.map","import { isBrowser } from '@probe.gl/env';\nexport let COLOR;\n\n(function (COLOR) {\n  COLOR[COLOR[\"BLACK\"] = 30] = \"BLACK\";\n  COLOR[COLOR[\"RED\"] = 31] = \"RED\";\n  COLOR[COLOR[\"GREEN\"] = 32] = \"GREEN\";\n  COLOR[COLOR[\"YELLOW\"] = 33] = \"YELLOW\";\n  COLOR[COLOR[\"BLUE\"] = 34] = \"BLUE\";\n  COLOR[COLOR[\"MAGENTA\"] = 35] = \"MAGENTA\";\n  COLOR[COLOR[\"CYAN\"] = 36] = \"CYAN\";\n  COLOR[COLOR[\"WHITE\"] = 37] = \"WHITE\";\n  COLOR[COLOR[\"BRIGHT_BLACK\"] = 90] = \"BRIGHT_BLACK\";\n  COLOR[COLOR[\"BRIGHT_RED\"] = 91] = \"BRIGHT_RED\";\n  COLOR[COLOR[\"BRIGHT_GREEN\"] = 92] = \"BRIGHT_GREEN\";\n  COLOR[COLOR[\"BRIGHT_YELLOW\"] = 93] = \"BRIGHT_YELLOW\";\n  COLOR[COLOR[\"BRIGHT_BLUE\"] = 94] = \"BRIGHT_BLUE\";\n  COLOR[COLOR[\"BRIGHT_MAGENTA\"] = 95] = \"BRIGHT_MAGENTA\";\n  COLOR[COLOR[\"BRIGHT_CYAN\"] = 96] = \"BRIGHT_CYAN\";\n  COLOR[COLOR[\"BRIGHT_WHITE\"] = 97] = \"BRIGHT_WHITE\";\n})(COLOR || (COLOR = {}));\n\nfunction getColor(color) {\n  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;\n}\n\nexport function addColor(string, color, background) {\n  if (!isBrowser && typeof string === 'string') {\n    if (color) {\n      color = getColor(color);\n      string = \"\\x1B[\".concat(color, \"m\").concat(string, \"\\x1B[39m\");\n    }\n\n    if (background) {\n      color = getColor(background);\n      string = \"\\x1B[\".concat(background + 10, \"m\").concat(string, \"\\x1B[49m\");\n    }\n  }\n\n  return string;\n}\n//# sourceMappingURL=color.js.map","export default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n//# sourceMappingURL=assert.js.map","import { window, process, isBrowser } from '@probe.gl/env';\nexport function getHiResTimestamp() {\n  let timestamp;\n\n  if (isBrowser && 'performance' in window) {\n    var _window$performance, _window$performance$n;\n\n    timestamp = window === null || window === void 0 ? void 0 : (_window$performance = window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);\n  } else if ('hrtime' in process) {\n    var _process$hrtime;\n\n    const timeParts = process === null || process === void 0 ? void 0 : (_process$hrtime = process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process);\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n//# sourceMappingURL=hi-res-timestamp.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { VERSION, isBrowser } from '@probe.gl/env';\nimport { LocalStorage } from './utils/local-storage';\nimport { formatImage, formatTime, leftPad } from './utils/formatters';\nimport { addColor } from './utils/color';\nimport { autobind } from './utils/autobind';\nimport assert from './utils/assert';\nimport { getHiResTimestamp } from './utils/hi-res-timestamp';\nconst originalConsole = {\n  debug: isBrowser ? console.debug || console.log : console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\nconst DEFAULT_SETTINGS = {\n  enabled: true,\n  level: 0\n};\n\nfunction noop() {}\n\nconst cache = {};\nconst ONCE = {\n  once: true\n};\nexport class Log {\n  constructor() {\n    let {\n      id\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      id: ''\n    };\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"VERSION\", VERSION);\n\n    _defineProperty(this, \"_startTs\", getHiResTimestamp());\n\n    _defineProperty(this, \"_deltaTs\", getHiResTimestamp());\n\n    _defineProperty(this, \"_storage\", void 0);\n\n    _defineProperty(this, \"userData\", {});\n\n    _defineProperty(this, \"LOG_THROTTLE_TIMEOUT\", 0);\n\n    this.id = id;\n    this.userData = {};\n    this._storage = new LocalStorage(\"__probe-\".concat(this.id, \"__\"), DEFAULT_SETTINGS);\n    this.timeStamp(\"\".concat(this.id, \" started\"));\n    autobind(this);\n    Object.seal(this);\n  }\n\n  set level(newLevel) {\n    this.setLevel(newLevel);\n  }\n\n  get level() {\n    return this.getLevel();\n  }\n\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n\n  getLevel() {\n    return this._storage.config.level;\n  }\n\n  getTotal() {\n    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));\n  }\n\n  getDelta() {\n    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));\n  }\n\n  set priority(newPriority) {\n    this.level = newPriority;\n  }\n\n  get priority() {\n    return this.level;\n  }\n\n  getPriority() {\n    return this.level;\n  }\n\n  enable() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this._storage.setConfiguration({\n      enabled\n    });\n\n    return this;\n  }\n\n  setLevel(level) {\n    this._storage.setConfiguration({\n      level\n    });\n\n    return this;\n  }\n\n  get(setting) {\n    return this._storage.config[setting];\n  }\n\n  set(setting, value) {\n    this._storage.setConfiguration({\n      [setting]: value\n    });\n  }\n\n  settings() {\n    if (console.table) {\n      console.table(this._storage.config);\n    } else {\n      console.log(this._storage.config);\n    }\n  }\n\n  assert(condition, message) {\n    assert(condition, message);\n  }\n\n  warn(message) {\n    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);\n  }\n\n  error(message) {\n    return this._getLogFunction(0, message, originalConsole.error, arguments);\n  }\n\n  deprecated(oldUsage, newUsage) {\n    return this.warn(\"`\".concat(oldUsage, \"` is deprecated and will be removed in a later version. Use `\").concat(newUsage, \"` instead\"));\n  }\n\n  removed(oldUsage, newUsage) {\n    return this.error(\"`\".concat(oldUsage, \"` has been removed. Use `\").concat(newUsage, \"` instead\"));\n  }\n\n  probe(logLevel, message) {\n    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {\n      time: true,\n      once: true\n    });\n  }\n\n  log(logLevel, message) {\n    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);\n  }\n\n  info(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.info, arguments);\n  }\n\n  once(logLevel, message) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);\n  }\n\n  table(logLevel, table, columns) {\n    if (table) {\n      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {\n        tag: getTableHeader(table)\n      });\n    }\n\n    return noop;\n  }\n\n  image(_ref) {\n    let {\n      logLevel,\n      priority,\n      image,\n      message = '',\n      scale = 1\n    } = _ref;\n\n    if (!this._shouldLog(logLevel || priority)) {\n      return noop;\n    }\n\n    return isBrowser ? logImageInBrowser({\n      image,\n      message,\n      scale\n    }) : logImageInNode({\n      image,\n      message,\n      scale\n    });\n  }\n\n  time(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);\n  }\n\n  timeEnd(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);\n  }\n\n  timeStamp(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.timeStamp || noop);\n  }\n\n  group(logLevel, message) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      collapsed: false\n    };\n    const options = normalizeArguments({\n      logLevel,\n      message,\n      opts\n    });\n    const {\n      collapsed\n    } = opts;\n    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;\n    return this._getLogFunction(options);\n  }\n\n  groupCollapsed(logLevel, message) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.group(logLevel, message, Object.assign({}, opts, {\n      collapsed: true\n    }));\n  }\n\n  groupEnd(logLevel) {\n    return this._getLogFunction(logLevel, '', console.groupEnd || noop);\n  }\n\n  withGroup(logLevel, message, func) {\n    this.group(logLevel, message)();\n\n    try {\n      func();\n    } finally {\n      this.groupEnd(logLevel)();\n    }\n  }\n\n  trace() {\n    if (console.trace) {\n      console.trace();\n    }\n  }\n\n  _shouldLog(logLevel) {\n    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);\n  }\n\n  _getLogFunction(logLevel, message, method, args, opts) {\n    if (this._shouldLog(logLevel)) {\n      opts = normalizeArguments({\n        logLevel,\n        message,\n        args,\n        opts\n      });\n      method = method || opts.method;\n      assert(method);\n      opts.total = this.getTotal();\n      opts.delta = this.getDelta();\n      this._deltaTs = getHiResTimestamp();\n      const tag = opts.tag || opts.message;\n\n      if (opts.once) {\n        if (!cache[tag]) {\n          cache[tag] = getHiResTimestamp();\n        } else {\n          return noop;\n        }\n      }\n\n      message = decorateMessage(this.id, opts.message, opts);\n      return method.bind(console, message, ...opts.args);\n    }\n\n    return noop;\n  }\n\n}\n\n_defineProperty(Log, \"VERSION\", VERSION);\n\nfunction normalizeLogLevel(logLevel) {\n  if (!logLevel) {\n    return 0;\n  }\n\n  let resolvedLevel;\n\n  switch (typeof logLevel) {\n    case 'number':\n      resolvedLevel = logLevel;\n      break;\n\n    case 'object':\n      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;\n      break;\n\n    default:\n      return 0;\n  }\n\n  assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);\n  return resolvedLevel;\n}\n\nexport function normalizeArguments(opts) {\n  const {\n    logLevel,\n    message\n  } = opts;\n  opts.logLevel = normalizeLogLevel(logLevel);\n  const args = opts.args ? Array.from(opts.args) : [];\n\n  while (args.length && args.shift() !== message) {}\n\n  switch (typeof logLevel) {\n    case 'string':\n    case 'function':\n      if (message !== undefined) {\n        args.unshift(message);\n      }\n\n      opts.message = logLevel;\n      break;\n\n    case 'object':\n      Object.assign(opts, logLevel);\n      break;\n\n    default:\n  }\n\n  if (typeof opts.message === 'function') {\n    opts.message = opts.message();\n  }\n\n  const messageType = typeof opts.message;\n  assert(messageType === 'string' || messageType === 'object');\n  return Object.assign(opts, {\n    args\n  }, opts.opts);\n}\n\nfunction decorateMessage(id, message, opts) {\n  if (typeof message === 'string') {\n    const time = opts.time ? leftPad(formatTime(opts.total)) : '';\n    message = opts.time ? \"\".concat(id, \": \").concat(time, \"  \").concat(message) : \"\".concat(id, \": \").concat(message);\n    message = addColor(message, opts.color, opts.background);\n  }\n\n  return message;\n}\n\nfunction logImageInNode(_ref2) {\n  let {\n    image,\n    message = '',\n    scale = 1\n  } = _ref2;\n  console.warn('removed');\n  return noop;\n}\n\nfunction logImageInBrowser(_ref3) {\n  let {\n    image,\n    message = '',\n    scale = 1\n  } = _ref3;\n\n  if (typeof image === 'string') {\n    const img = new Image();\n\n    img.onload = () => {\n      const args = formatImage(img, message, scale);\n      console.log(...args);\n    };\n\n    img.src = image;\n    return noop;\n  }\n\n  const element = image.nodeName || '';\n\n  if (element.toLowerCase() === 'img') {\n    console.log(...formatImage(image, message, scale));\n    return noop;\n  }\n\n  if (element.toLowerCase() === 'canvas') {\n    const img = new Image();\n\n    img.onload = () => console.log(...formatImage(img, message, scale));\n\n    img.src = image.toDataURL();\n    return noop;\n  }\n\n  return noop;\n}\n\nfunction getTableHeader(table) {\n  for (const key in table) {\n    for (const title in table[key]) {\n      return title || 'untitled';\n    }\n  }\n\n  return 'empty';\n}\n//# sourceMappingURL=log.js.map","export function autobind(obj) {\n  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];\n  const proto = Object.getPrototypeOf(obj);\n  const propNames = Object.getOwnPropertyNames(proto);\n\n  for (const key of propNames) {\n    if (typeof obj[key] === 'function') {\n      if (!predefined.find(name => key === name)) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  }\n}\n//# sourceMappingURL=autobind.js.map","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Log } from '@probe.gl/log';\nexport const probeLog = new Log({\n  id: 'loaders.gl'\n});\n\nexport class NullLog {\n  log() {\n    return () => {};\n  }\n  info() {\n    return () => {};\n  }\n  warn() {\n    return () => {};\n  }\n  error() {\n    return () => {};\n  }\n}\n\nexport class ConsoleLog {\n  constructor() {\n    _defineProperty(this, \"console\", void 0);\n    this.console = console;\n  }\n\n  log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return this.console.log.bind(this.console, ...args);\n  }\n  info() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return this.console.info.bind(this.console, ...args);\n  }\n  warn() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return this.console.warn.bind(this.console, ...args);\n  }\n  error() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return this.console.error.bind(this.console, ...args);\n  }\n}\n//# sourceMappingURL=loggers.js.map","import { isBrowser } from '@loaders.gl/loader-utils';\nimport { ConsoleLog } from './loggers';\nexport const DEFAULT_LOADER_OPTIONS = {\n  fetch: null,\n  mimeType: undefined,\n  nothrow: false,\n  log: new ConsoleLog(),\n\n  CDN: 'https://unpkg.com/@loaders.gl',\n  worker: true,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: isBrowser,\n  _nodeWorkers: false,\n  _workerType: '',\n\n  limit: 0,\n  _limitMB: 0,\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  metadata: false,\n  transforms: []\n};\nexport const REMOVED_LOADER_OPTIONS = {\n  throws: 'nothrow',\n  dataType: '(no longer used)',\n  uri: 'baseUri',\n  method: 'fetch.method',\n  headers: 'fetch.headers',\n  body: 'fetch.body',\n  mode: 'fetch.mode',\n  credentials: 'fetch.credentials',\n  cache: 'fetch.cache',\n  redirect: 'fetch.redirect',\n  referrer: 'fetch.referrer',\n  referrerPolicy: 'fetch.referrerPolicy',\n  integrity: 'fetch.integrity',\n  keepalive: 'fetch.keepalive',\n  signal: 'fetch.signal'\n};\n//# sourceMappingURL=option-defaults.js.map","import { isPureObject, isObject } from '../../javascript-utils/is-type';\nimport { fetchFile } from '../fetch/fetch-file';\nimport { probeLog, NullLog } from './loggers';\nimport { DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS } from './option-defaults';\n\nexport function getGlobalLoaderState() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders\n  } = globalThis;\n\n  loaders._state = loaders._state || {};\n  return loaders._state;\n}\n\nexport const getGlobalLoaderOptions = () => {\n  const state = getGlobalLoaderState();\n  state.globalOptions = state.globalOptions || {\n    ...DEFAULT_LOADER_OPTIONS\n  };\n  return state.globalOptions;\n};\n\nexport function setGlobalOptions(options) {\n  const state = getGlobalLoaderState();\n  const globalOptions = getGlobalLoaderOptions();\n  state.globalOptions = normalizeOptionsInternal(globalOptions, options);\n}\n\nexport function normalizeOptions(options, loader, loaders, url) {\n  loaders = loaders || [];\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  validateOptions(options, loaders);\n  return normalizeOptionsInternal(loader, options, url);\n}\n\nexport function getFetchFunction(options, context) {\n  const globalOptions = getGlobalLoaderOptions();\n  const fetchOptions = options || globalOptions;\n\n  if (typeof fetchOptions.fetch === 'function') {\n    return fetchOptions.fetch;\n  }\n\n  if (isObject(fetchOptions.fetch)) {\n    return url => fetchFile(url, fetchOptions);\n  }\n\n  if (context !== null && context !== void 0 && context.fetch) {\n    return context === null || context === void 0 ? void 0 : context.fetch;\n  }\n\n  return fetchFile;\n}\n\nfunction validateOptions(options, loaders) {\n  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n  for (const loader of loaders) {\n    const idOptions = options && options[loader.id] || {};\n\n    const loaderOptions = loader.options && loader.options[loader.id] || {};\n    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};\n\n    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n  }\n}\n\nfunction validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {\n  const loaderName = id || 'Top level';\n  const prefix = id ? \"\".concat(id, \".\") : '';\n  for (const key in options) {\n    const isSubOptions = !id && isObject(options[key]);\n    const isBaseUriOption = key === 'baseUri' && !id;\n    const isWorkerUrlOption = key === 'workerUrl' && id;\n    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n      if (key in deprecatedOptions) {\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' no longer supported, use '\").concat(deprecatedOptions[key], \"'\"))();\n      } else if (!isSubOptions) {\n        const suggestion = findSimilarOption(key, loaders);\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' not recognized. \").concat(suggestion))();\n      }\n    }\n  }\n}\nfunction findSimilarOption(optionKey, loaders) {\n  const lowerCaseOptionKey = optionKey.toLowerCase();\n  let bestSuggestion = '';\n  for (const loader of loaders) {\n    for (const key in loader.options) {\n      if (optionKey === key) {\n        return \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n      const lowerCaseKey = key.toLowerCase();\n      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n      if (isPartialMatch) {\n        bestSuggestion = bestSuggestion || \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n    }\n  }\n  return bestSuggestion;\n}\nfunction normalizeOptionsInternal(loader, options, url) {\n  const loaderDefaultOptions = loader.options || {};\n  const mergedOptions = {\n    ...loaderDefaultOptions\n  };\n  addUrlOptions(mergedOptions, url);\n\n  if (mergedOptions.log === null) {\n    mergedOptions.log = new NullLog();\n  }\n  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n  mergeNestedFields(mergedOptions, options);\n  return mergedOptions;\n}\n\nfunction mergeNestedFields(mergedOptions, options) {\n  for (const key in options) {\n    if (key in options) {\n      const value = options[key];\n      if (isPureObject(value) && isPureObject(mergedOptions[key])) {\n        mergedOptions[key] = {\n          ...mergedOptions[key],\n          ...options[key]\n        };\n      } else {\n        mergedOptions[key] = options[key];\n      }\n    }\n  }\n}\n\nfunction addUrlOptions(options, url) {\n  if (url && !('baseUri' in options)) {\n    options.baseUri = url;\n  }\n}\n//# sourceMappingURL=option-utils.js.map","import { assert } from '@loaders.gl/loader-utils';\nexport function isLoaderObject(loader) {\n  var _loader;\n  if (!loader) {\n    return false;\n  }\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);\n\n  return hasExtensions;\n}\nexport function normalizeLoader(loader) {\n  var _loader2, _loader3;\n  assert(loader, 'null loader');\n  assert(isLoaderObject(loader), 'invalid loader');\n\n  let options;\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = {\n      ...loader,\n      options: {\n        ...loader.options,\n        ...options\n      }\n    };\n  }\n\n  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {\n    loader.text = true;\n  }\n  if (!loader.text) {\n    loader.binary = true;\n  }\n  return loader;\n}\n//# sourceMappingURL=normalize-loader.js.map","import { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { getGlobalLoaderState } from '../loader-utils/option-utils';\n\nconst getGlobalLoaderRegistry = () => {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = state.loaderRegistry || [];\n  return state.loaderRegistry;\n};\n\nexport function registerLoaders(loaders) {\n  const loaderRegistry = getGlobalLoaderRegistry();\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  for (const loader of loaders) {\n    const normalizedLoader = normalizeLoader(loader);\n    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {\n      loaderRegistry.unshift(normalizedLoader);\n    }\n  }\n}\nexport function getRegisteredLoaders() {\n  return getGlobalLoaderRegistry();\n}\n\nexport function _unregisterLoaders() {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = [];\n}\n//# sourceMappingURL=register-loaders.js.map","\nimport { Log } from '@probe.gl/log';\nexport const log = new Log({\n  id: 'loaders.gl'\n});\n//# sourceMappingURL=log.js.map","import { compareArrayBuffers, path } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { log } from '../utils/log';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { getRegisteredLoaders } from './register-loaders';\nimport { isBlob } from '../../javascript-utils/is-type';\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\nexport async function selectLoader(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  let loader = selectLoaderSync(data, loaders, {\n    ...options,\n    nothrow: true\n  }, context);\n  if (loader) {\n    return loader;\n  }\n\n  if (isBlob(data)) {\n    data = await data.slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n\nexport function selectLoaderSync(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  let candidateLoaders = [];\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  normalizeLoaders(candidateLoaders);\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n\nfunction selectLoaderInternal(data, loaders, options, context) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);\n  let loader = null;\n  let reason = '';\n\n  if (options !== null && options !== void 0 && options.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);\n    reason = \"match forced by supplied MIME type \".concat(options === null || options === void 0 ? void 0 : options.mimeType);\n  }\n\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? \"matched url \".concat(testUrl) : '');\n\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? \"matched MIME type \".concat(type) : '');\n\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? \"matched initial data \".concat(getFirstCharacters(data)) : '');\n\n  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);\n  reason = reason || (loader ? \"matched fallback MIME type \".concat(type) : '');\n  if (reason) {\n    var _loader;\n    log.log(1, \"selectLoader selected \".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, \": \").concat(reason, \".\"));\n  }\n  return loader;\n}\n\nfunction validHTTPResponse(data) {\n  if (data instanceof Response) {\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  let message = 'No valid loader found (';\n  message += url ? \"\".concat(path.filename(url), \", \") : 'no url provided, ';\n  message += \"MIME type: \".concat(type ? \"\\\"\".concat(type, \"\\\"\") : 'not provided', \", \");\n  const firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? \" first bytes: \\\"\".concat(firstCharacters, \"\\\"\") : 'first bytes: not available';\n  message += ')';\n  return message;\n}\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    if (mimeType === \"application/x.\".concat(loader.id)) {\n      return loader;\n    }\n  }\n  return null;\n}\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => data.startsWith(test));\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n    case 'string':\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n    default:\n      return false;\n  }\n}\nfunction getFirstCharacters(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n//# sourceMappingURL=select-loader.js.map","\n\nexport function filename(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';\n}\n\nexport function dirname(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n\nexport function join() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(\"^\".concat(separator)), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(\"\".concat(separator, \"$\")), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n//# sourceMappingURL=path.js.map","const DEFAULT_CHUNK_SIZE = 256 * 1024;\n\nexport function* makeStringIterator(string, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    yield textEncoder.encode(chunk);\n  }\n}\n//# sourceMappingURL=make-string-iterator.js.map","const DEFAULT_CHUNK_SIZE = 256 * 1024;\n\nexport function* makeArrayBufferIterator(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    chunkSize = DEFAULT_CHUNK_SIZE\n  } = options;\n  let byteOffset = 0;\n  while (byteOffset < arrayBuffer.byteLength) {\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n//# sourceMappingURL=make-array-buffer-iterator.js.map","const DEFAULT_CHUNK_SIZE = 1024 * 1024;\n\nexport async function* makeBlobIterator(blob, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n  while (offset < blob.size) {\n    const end = offset + chunkSize;\n    const chunk = await blob.slice(offset, end).arrayBuffer();\n    offset = end;\n    yield chunk;\n  }\n}\n//# sourceMappingURL=make-blob-iterator.js.map","import { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\nexport function makeStreamIterator(stream, options) {\n  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);\n}\n\nasync function* makeBrowserStreamIterator(stream, options) {\n\n  const reader = stream.getReader();\n  let nextBatchPromise;\n  try {\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      if (options !== null && options !== void 0 && options._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      const {\n        done,\n        value\n      } = await currentBatchPromise;\n      if (done) {\n        return;\n      }\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    reader.releaseLock();\n  }\n}\n\nasync function* makeNodeStreamIterator(stream, options) {\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk);\n  }\n}\n//# sourceMappingURL=make-stream-iterator.js.map","import { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from '../../javascript-utils/is-type';\nimport { makeIterator } from '../../iterators/make-iterator/make-iterator';\nimport { checkResponse, makeResponse } from '../utils/response-utils';\nconst ERR_DATA = 'Cannot convert supplied data type';\n\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n  if (isBuffer(data)) {\n    data = data.buffer;\n  }\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n    let arrayBuffer = data.buffer;\n\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n  throw new Error(ERR_DATA);\n}\n\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader, options);\n  }\n\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n  if (isReadableStream(data)) {\n    data = makeIterator(data, options);\n  }\n  if (isIterable(data) || isAsyncIterable(data)) {\n    return concatenateArrayBuffersAsync(data);\n  }\n  throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    const body = await response.body;\n    return makeIterator(body, options);\n  }\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data, options);\n  }\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n  return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n  if (isReadableStream(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  return response.body;\n}\n\nfunction getIterableFromData(data) {\n  if (ArrayBuffer.isView(data)) {\n    return function* oneChunk() {\n      yield data.buffer;\n    }();\n  }\n  if (data instanceof ArrayBuffer) {\n    return function* oneChunk() {\n      yield data;\n    }();\n  }\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n  throw new Error(ERR_DATA);\n}\n//# sourceMappingURL=get-data.js.map","import { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { parseWithWorker, canParseWithWorker } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { isResponse } from '../../javascript-utils/is-type';\nimport { normalizeOptions } from '../loader-utils/option-utils';\nimport { getArrayBufferOrStringFromData } from '../loader-utils/get-data';\nimport { getLoaderContext, getLoadersFromContext } from '../loader-utils/loader-context';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { selectLoader } from './select-loader';\n\nexport async function parse(data, loaders, options, context) {\n  assert(!context || typeof context === 'object');\n\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n  data = await data;\n  options = options || {};\n\n  const {\n    url\n  } = getResourceUrlAndType(data);\n\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = await selectLoader(data, candidateLoaders, options);\n  if (!loader) {\n    return null;\n  }\n\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n\n  context = getLoaderContext({\n    url,\n    parse,\n    loaders: candidateLoaders\n  }, options, context);\n  return await parseWithLoader(loader, data, options, context);\n}\n\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  if (isResponse(data)) {\n    const response = data;\n    const {\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    } = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    context.response = {\n      headers,\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    };\n  }\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  assert(!loader.parseSync);\n\n  throw new Error(\"\".concat(loader.id, \" loader - no parser found and worker is disabled\"));\n}\n//# sourceMappingURL=parse.js.map","import { getFetchFunction } from './option-utils';\n\nexport function getLoaderContext(context, options) {\n  let previousContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (previousContext) {\n    return previousContext;\n  }\n  const resolvedContext = {\n    fetch: getFetchFunction(options, context),\n    ...context\n  };\n\n  if (!Array.isArray(resolvedContext.loaders)) {\n    resolvedContext.loaders = null;\n  }\n  return resolvedContext;\n}\n\nexport function getLoadersFromContext(loaders, context) {\n  if (!context && loaders && !Array.isArray(loaders)) {\n    return loaders;\n  }\n\n  let candidateLoaders;\n  if (loaders) {\n    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\n  }\n  if (context && context.loaders) {\n    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\n    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\n  }\n  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;\n}\n//# sourceMappingURL=loader-context.js.map","import { assert } from '../env-utils/assert';\nimport { VERSION } from '../env-utils/version';\n\nexport function validateWorkerVersion(worker) {\n  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VERSION;\n  assert(worker, 'no worker provided');\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {\n    major: parts[0],\n    minor: parts[1]\n  };\n}\n//# sourceMappingURL=validate-worker-version.js.map","import { makeStringIterator } from './make-string-iterator';\nimport { makeArrayBufferIterator } from './make-array-buffer-iterator';\nimport { makeBlobIterator } from './make-blob-iterator';\nimport { makeStreamIterator } from './make-stream-iterator';\nimport { isBlob, isReadableStream, isResponse } from '../../javascript-utils/is-type';\n\nexport function makeIterator(data, options) {\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data, options);\n  }\n  if (isResponse(data)) {\n    const response = data;\n    return makeStreamIterator(response.body, options);\n  }\n  throw new Error('makeIterator');\n}\n//# sourceMappingURL=make-iterator.js.map","import { concatenateArrayBuffers } from '../binary-utils/array-buffer-utils';\n\nexport async function forEach(iterator, visitor) {\n  while (true) {\n    const {\n      done,\n      value\n    } = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\nexport async function concatenateArrayBuffersAsync(asyncIterator) {\n  const arrayBuffers = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\nexport async function concatenateStringsAsync(asyncIterator) {\n  const strings = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n//# sourceMappingURL=async-iteration.js.map","import { canEncodeWithWorker } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { concatenateArrayBuffers, resolvePath } from '@loaders.gl/loader-utils';\nimport { isBrowser } from '@loaders.gl/loader-utils';\nimport { writeFile } from '../fetch/write-file';\nimport { fetchFile } from '../fetch/fetch-file';\nimport { getLoaderOptions } from './loader-options';\n\nexport async function encode(data, writer, options) {\n  const globalOptions = getLoaderOptions();\n  options = {\n    ...globalOptions,\n    ...options\n  };\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n  if (writer.encodeInBatches) {\n    const batches = encodeInBatches(data, writer, options);\n\n    const chunks = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    return concatenateArrayBuffers(...chunks);\n  }\n  if (!isBrowser && writer.encodeURLtoURL) {\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n    const tmpOutputFilename = getTemporaryFilename('output');\n    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n  throw new Error('Writer could not encode data');\n}\n\nexport function encodeSync(data, writer, options) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\nexport async function encodeText(data, writer, options) {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error('Writer could not encode data as text');\n}\n\nexport function encodeInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  throw new Error('Writer could not encode data in batches');\n}\n\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\nfunction getIterator(data) {\n  const dataIterator = [{\n    table: data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}\n\nfunction getTemporaryFilename(filename) {\n  return \"/tmp/\".concat(filename);\n}\n//# sourceMappingURL=encode.js.map","import { WorkerFarm } from '@loaders.gl/worker-utils';\nimport { isBrowser } from '../env-utils/globals';\n\nexport function canEncodeWithWorker(writer, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  if (!isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {\n    return false;\n  }\n  return writer.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\n//# sourceMappingURL=encode-with-worker.js.map","\nimport { isBrowser, assert, resolvePath } from '@loaders.gl/loader-utils';\nimport { fs, toBuffer } from '@loaders.gl/loader-utils';\nexport async function writeFile(filePath, arrayBufferOrString, options) {\n  filePath = resolvePath(filePath);\n  if (!isBrowser) {\n    await fs.writeFile(filePath, toBuffer(arrayBufferOrString), {\n      flag: 'w'\n    });\n  }\n  assert(false);\n}\nexport function writeFileSync(filePath, arrayBufferOrString, options) {\n  filePath = resolvePath(filePath);\n  if (!isBrowser) {\n    fs.writeFileSync(filePath, toBuffer(arrayBufferOrString), {\n      flag: 'w'\n    });\n  }\n  assert(false);\n}\n//# sourceMappingURL=write-file.js.map","import {KTX2BasisWriter} from \"@loaders.gl/textures\";\nimport {ImageLoader} from '@loaders.gl/images';\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport {Component, EventEmitter, SDKError} from \"@xeokit/core\";\nimport {\n    LinesPrimitive,\n    PointsPrimitive,\n    SolidPrimitive,\n    SurfacePrimitive,\n    TrianglesPrimitive\n} from \"@xeokit/constants\";\nimport {createAABB3} from \"@xeokit/boundaries\";\n\nimport {Geometry} from \"./Geometry\";\nimport {SceneObject} from \"./SceneObject\";\nimport {TextureSet} from \"./TextureSet\";\nimport {Texture} from \"./Texture\";\nimport {Mesh} from \"./Mesh\";\nimport type {RendererModel} from \"./RendererModel\";\nimport type {TransformParams} from \"./TransformParams\";\nimport type {TextureSetParams} from \"./TextureSetParams\";\nimport type {GeometryParams} from \"./GeometryParams\";\nimport type {GeometryCompressedParams} from \"./GeometryCompressedParams\";\nimport type {MeshParams} from \"./MeshParams\";\nimport type {SceneObjectParams} from \"./SceneObjectParams\";\nimport type {TextureParams} from \"./TextureParams\";\nimport {compressGeometryParams} from \"./compressGeometryParams\";\nimport {encode, load} from \"@loaders.gl/core\";\nimport type {SceneModelParams} from \"./SceneModelParams\";\nimport type {Scene} from \"./Scene\";\n\n// XKT texture types\n\nconst COLOR_TEXTURE = 0;\nconst METALLIC_ROUGHNESS_TEXTURE = 1;\nconst NORMALS_TEXTURE = 2;\nconst EMISSIVE_TEXTURE = 3;\nconst OCCLUSION_TEXTURE = 4;\n\n// KTX2 encoding options for each texture type\n\nconst TEXTURE_ENCODING_OPTIONS: {\n    [key: string]: any\n} = {}\n\nTEXTURE_ENCODING_OPTIONS[COLOR_TEXTURE] = {\n    useSRGB: true,\n    qualityLevel: 50,\n    encodeUASTC: true,\n    mipmaps: true\n};\n\nTEXTURE_ENCODING_OPTIONS[EMISSIVE_TEXTURE] = {\n    useSRGB: true,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\n\nTEXTURE_ENCODING_OPTIONS[METALLIC_ROUGHNESS_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 50,\n    mipmaps: true // Needed for GGX roughness shading\n};\n\nTEXTURE_ENCODING_OPTIONS[NORMALS_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\n\nTEXTURE_ENCODING_OPTIONS[OCCLUSION_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\n\n/**\n * xeokit Geometry and Materials Model.\n *\n * * A representation of a model's geometry and materials within a {@link Scene}.\n * * Contains {@link SceneObject | SceneObjects}, {@link Mesh | Meshes}, {@link Geometry | Geometries} and {@link Texture | Textures}.\n * * Compresses textures using [Basis](/docs/pages/GLOSSARY.html#basis)\n * * Compresses geometry using [bucketing](/docs/pages/GLOSSARY.html#geometry-bucketing) and [quantization](/docs/pages/GLOSSARY.html#geometry-quantization)\n * * Viewable in the Browser with {@link @xeokit/viewer!Viewer}\n * * Importable from various model file formats, using {@link @xeokit/gltf!loadGLTF}, {@link @xeokit/las!loadLAS}, {@link @xeokit/cityjson!loadCityJSON}, {@link @xeokit/xkt!loadXKT} (etc)\n * * Exportable to XKT format using {@link @xeokit/xkt!saveXKT}\n * * Programmatically buildable using builder methods\n *\n * See {@link \"@xeokit/scene\"} for usage.\n */\nexport class SceneModel extends Component {\n\n    /**\n     * The {@link Scene} that contains this SceneModel.\n     */\n    public readonly scene: Scene;\n\n    /**\n     * Unique ID of this SceneModel.\n     *\n     * SceneModel are stored against this ID in {@link Scene.models}.\n     */\n    declare public readonly id: string;\n\n    /**\n     * If we want to view this SceneModel with a {@link @xeokit/viewer}, an\n     * optional ID of a {@link @xeokit/viewer!ViewLayer | ViewLayer} to view it in.\n     */\n    public readonly layerId?: string;\n\n    /**\n     * Indicates if this SceneModel has already been built.\n     *\n     * * Set ````true```` by {@link SceneModel.build | SceneModel.build}.\n     * * Subscribe to updates using {@link SceneModel.onBuilt | SceneModel.onBuilt} and {@link Scene.onModelCreated | Scene.onModelCreated}.\n     * * Don't create anything more in this SceneModel once it's built.\n     */\n    public built: boolean;\n\n    /**\n     * Indicates if this SceneModel has been destroyed.\n     *\n     * * Set ````true```` by {@link SceneModel.destroy | SceneModel.destroy}.\n     * * Don't create anything more in this SceneModel once it's destroyed.\n     */\n    declare readonly destroyed: boolean;\n\n    /**\n     * The edge threshold for automatic [edge primitive generation](/docs/pages/GLOSSARY.html#geometry-edge-generation).\n     */\n    public readonly edgeThreshold: number;\n\n    /**\n     * {@link @xeokit/scene!Geometry | Geometries} within this SceneModel, each mapped to {@link @xeokit/scene!Geometry.id | Geometry.id}.\n     *\n     * * Created by {@link SceneModel.createGeometry | SceneModel.createGeometry}.\n     */\n    public readonly geometries: { [key: string]: Geometry };\n\n    /**\n     * {@link Texture | Textures} within this SceneModel, each mapped to {@link Texture.id | Texture.id}.\n     *\n     * * Created by {@link SceneModel.createTexture | SceneModel.createTexture}.\n     * * Compressed asynchronously in {@link SceneModel.build | SceneModel.build}.\n     */\n    public readonly textures: { [key: string]: Texture };\n\n    /**\n     * {@link TextureSet | TextureSets} within this SceneModel, each mapped to {@link TextureSet.id | TextureSet.id}.\n     *\n     * * Created by {@link SceneModel.createTextureSet | SceneModel.createTextureSet}.\n     */\n    public readonly textureSets: { [key: string]: TextureSet };\n\n    /**\n     * {@link Mesh | Meshes} within this SceneModel, each mapped to {@link Mesh.id | Mesh.id}.\n     *\n     * * Created by {@link SceneModel.createMesh | SceneModel.createMesh}.\n     */\n    public readonly meshes: { [key: string]: Mesh };\n\n    /**\n     * {@link SceneObject | SceneObjects} within this SceneModel, each mapped to {@link SceneObject.id | SceneObject.id}.\n     *\n     * * Created by {@link SceneModel.createObject | SceneModel.createObject}.\n     */\n    readonly objects: { [key: string]: SceneObject };\n\n    /**\n     * The axis-aligned 3D World-space boundary of this SceneModel.\n     *\n     * * Created by {@link SceneModel.build | SceneModel.build}.\n     */\n    public readonly aabb: Float64Array;\n\n    /**\n     * Emits an event when this {@link @xeokit/scene!SceneModel | SceneModel} has been built.\n     *\n     * * Triggered by {@link SceneModel.build | SceneModel.build}.\n     *\n     * @event onBuilt\n     */\n    public readonly onBuilt: EventEmitter<SceneModel, null>;\n\n    /**\n     * Emits an event when this {@link @xeokit/scene!SceneModel | SceneModel} has been destroyed.\n     *\n     * * Triggered by {@link SceneModel.destroy | SceneModel.destroy}.\n     *\n     * @event\n     */\n    declare public readonly onDestroyed: EventEmitter<SceneModel, null>;\n\n    /**\n     *  Internal interface through which a SceneModel can load property updates into a renderer.\n     *\n     * @internal\n     */\n    public rendererModel: RendererModel | null;\n\n\n    #texturesList: Texture[];\n    #numObjects: number;\n    #meshUsedByObject: { [key: string]: boolean };\n\n    /**\n     * @private\n     */\n    constructor(scene: Scene, sceneModelParams: SceneModelParams) {\n        super(scene, {\n            id: sceneModelParams.id\n        });\n\n        this.scene = scene;\n\n        this.onBuilt = new EventEmitter(new EventDispatcher<SceneModel, null>());\n        this.onDestroyed = new EventEmitter(new EventDispatcher<SceneModel, null>());\n\n        this.#numObjects = 0;\n        this.#meshUsedByObject = {};\n\n        this.id = sceneModelParams.id || \"default\";\n        this.layerId = sceneModelParams.layerId;\n        this.edgeThreshold = 10;\n        this.geometries = {};\n        this.textures = {};\n        this.#texturesList = [];\n        this.textureSets = {};\n        this.meshes = {};\n        this.objects = {};\n        this.aabb = createAABB3();\n        this.built = false;\n        this.rendererModel = null;\n\n        this.fromJSON(sceneModelParams);\n    }\n\n    /**\n     * Adds components to this SceneModel.\n     *\n     * See {@link \"@xeokit/scene\"} for usage.\n     *\n     * @param sceneModelParams\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this SceneModel has already been built.\n     * * If this SceneModel has already been destroyed.\n     * * A duplicate component ({@link SceneObject}, {@link Mesh}, {@link Geometry}, {@link Texture} etc.) was already created within this SceneModel.\n     */\n    fromJSON(sceneModelParams: SceneModelParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to add components to SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to add components to SceneModel - SceneModel already built\");\n        }\n        if (sceneModelParams.geometries) {\n            for (let i = 0, len = sceneModelParams.geometries.length; i < len; i++) {\n                this.createGeometry(sceneModelParams.geometries[i]);\n            }\n        }\n        if (sceneModelParams.textures) {\n            for (let i = 0, len = sceneModelParams.textures.length; i < len; i++) {\n                this.createTexture(sceneModelParams.textures[i]);\n            }\n        }\n        if (sceneModelParams.textureSets) {\n            for (let i = 0, len = sceneModelParams.textureSets.length; i < len; i++) {\n                this.createTextureSet(sceneModelParams.textureSets[i]);\n            }\n        }\n        if (sceneModelParams.meshes) {\n            for (let i = 0, len = sceneModelParams.meshes.length; i < len; i++) {\n                this.createMesh(sceneModelParams.meshes[i]);\n            }\n        }\n        if (sceneModelParams.objects) {\n            for (let i = 0, len = sceneModelParams.objects.length; i < len; i++) {\n                this.createObject(sceneModelParams.objects[i]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link Transform} within this SceneModel.\n     *\n     * * Stores the new {@link Transform} in {@link SceneModel.transforms | SceneModel.transforms}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const spinningTransform = sceneModel.createTransform({\n     *      id: \"spinningTransform\",\n     *      rotation: [0, 10, 0]\n     * });\n     *\n     * const spinningTransformAgain = sceneModel.transforms[\"spinningTransform\"];\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param transformParams Transform creation parameters.\n     * @returns *{Transform}*\n     * * On success\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If SceneModel has already been built or destroyed.\n     */\n    createTransform(transformParams: TransformParams): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Transform in SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Transform in SceneModel - SceneModel already built\");\n        }\n        //...\n    }\n\n    /**\n     * Creates a new {@link Texture} within this SceneModel.\n     *\n     * * Stores the new {@link Texture} in {@link SceneModel.textures | SceneModel.textures}.\n     * * Textures are compressed asynchronously by {@link SceneModel.build | SceneModel.build}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const texture = sceneModel.createTexture({\n     *      id: \"myColorTexture\",\n     *      src: // Path to JPEG, PNG, KTX2,\n     *      image: // HTMLImageElement,\n     *      buffers: // ArrayBuffer[] containing KTX2 MIP levels\n     *      preloadColor: [1,0,0,1],\n     *      flipY: false,\n     *      encoding: LinearEncoding, // @xeokit/constants\n     *      magFilter: LinearFilter,\n     *      minFilter: LinearFilter,\n     *      wrapR: ClampToEdgeWrapping,\n     *      wrapS: ClampToEdgeWrapping,\n     *      wrapT: ClampToEdgeWrapping,\n     * });\n     *\n     * const textureAgain = sceneModel.textures[\"myColorTexture\"];\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param textureParams - Texture creation parameters.\n     * @returns *{@link Texture}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If SceneModel has already been built or destroyed.\n     * * Invalid TextureParams were given.\n     * * Texture with given ID already exists in this Scene.\n     */\n    createTexture(textureParams: TextureParams): Texture | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Texture in SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Texture in SceneModel - SceneModel already built\");\n        }\n        if (!textureParams.imageData && !textureParams.src && !textureParams.buffers) {\n            return new SDKError(\"Failed to create Texture in SceneModel - Parameter expected: textureParams.imageData, textureParams.src or textureParams.buffers\");\n        }\n        if (this.textures[textureParams.id]) {\n            return new SDKError(`Failed to create Texture in SceneModel - Texture already exists with this ID: ${textureParams.id}`);\n        }\n        if (textureParams.src) {\n            const fileExt = textureParams.src.split('.').pop();\n            // if (fileExt !== \"jpg\" && fileExt !== \"jpeg\" && fileExt !== \"png\") {\n            //     console.error(`Model does not support image files with extension '${fileExt}' - won't create texture '${textureParams.id}`);\n            //     return;\n            // }\n        }\n        const texture = new Texture(textureParams);\n        this.textures[textureParams.id] = texture;\n        this.#texturesList.push(texture);\n        return texture;\n    }\n\n    /**\n     * Creates a new {@link TextureSet} within this SceneModel.\n     *\n     * * Stores the new {@link TextureSet} in {@link SceneModel.textureSets | SceneModel.textureSets}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const textureSet = sceneModel.createTextureSet({\n     *      id: \"myTextureSet\",\n     *      colorTextureId: \"myColorTexture\"\n     * });\n     *\n     * const textureSetAgain = sceneModel.textureSets[\"myTextureSet\"];\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param textureSetParams TextureSet creation parameters.\n     *\n     * @returns *{@link TextureSet}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If SceneModel has already been built or destroyed.\n     * * Invalid TextureSetParams were given.\n     * * TextureSet with given ID already exists in this SceneModel.\n     * * One or more of the given Textures could not be found in this SceneModel.\n     */\n    createTextureSet(textureSetParams: TextureSetParams): TextureSet | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create TextureSet in SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create TextureSet in SceneModel - SceneModel already built\");\n        }\n        if (this.textureSets[textureSetParams.id]) {\n            return new SDKError(`Failed to create TextureSet in SceneModel - TextureSet already exists with this ID: ${textureSetParams.id}`);\n        }\n        let colorTexture;\n        if (textureSetParams.colorTextureId !== undefined && textureSetParams.colorTextureId !== null) {\n            colorTexture = this.textures[textureSetParams.colorTextureId];\n            if (!colorTexture) {\n                return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.colorTextureId} - ensure that you create it first with createTexture()`);\n            }\n            colorTexture.channel = COLOR_TEXTURE;\n        }\n        let metallicRoughnessTexture;\n        if (textureSetParams.metallicRoughnessTextureId !== undefined && textureSetParams.metallicRoughnessTextureId !== null) {\n            metallicRoughnessTexture = this.textures[textureSetParams.metallicRoughnessTextureId];\n            if (!metallicRoughnessTexture) {\n                return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.metallicRoughnessTextureId} - ensure that you create it first with createTexture()`);\n            }\n            metallicRoughnessTexture.channel = METALLIC_ROUGHNESS_TEXTURE;\n        }\n        let normalsTexture;\n        if (textureSetParams.normalsTextureId !== undefined && textureSetParams.normalsTextureId !== null) {\n            normalsTexture = this.textures[textureSetParams.normalsTextureId];\n            if (!normalsTexture) {\n                return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.normalsTextureId} - ensure that you create it first with createTexture()`);\n            }\n            normalsTexture.channel = NORMALS_TEXTURE;\n        }\n        let emissiveTexture;\n        if (textureSetParams.emissiveTextureId !== undefined && textureSetParams.emissiveTextureId !== null) {\n            emissiveTexture = this.textures[textureSetParams.emissiveTextureId];\n            if (!emissiveTexture) {\n                return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.emissiveTextureId} - ensure that you create it first with createTexture()`);\n            }\n            emissiveTexture.channel = EMISSIVE_TEXTURE;\n        }\n        let occlusionTexture;\n        if (textureSetParams.occlusionTextureId !== undefined && textureSetParams.occlusionTextureId !== null) {\n            occlusionTexture = this.textures[textureSetParams.occlusionTextureId];\n            if (!occlusionTexture) {\n                return new SDKError(`Failed to create TextureSet in SceneModel - Texture not found: ${textureSetParams.occlusionTextureId} - ensure that you create it first with createTexture()`);\n            }\n            occlusionTexture.channel = OCCLUSION_TEXTURE;\n        }\n        const textureSet = new TextureSet(textureSetParams, {\n            emissiveTexture,\n            occlusionTexture,\n            metallicRoughnessTexture,\n            colorTexture\n        });\n        this.textureSets[textureSetParams.id] = textureSet;\n        return textureSet;\n    }\n\n    /**\n     * Creates a new {@link @xeokit/scene!Geometry} within this SceneModel, from non-compressed geometry parameters.\n     *\n     * * Stores the new {@link Geometry} in {@link SceneModel.geometries | SceneModel.geometries}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const boxGeometry = sceneModel.createGeometry({\n     *      id: \"boxGeometry\",\n     *      primitive: TrianglesPrimitive, // @xeokit/constants\n     *      positions: [\n     *          1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front\n     *          1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v1 right\n     *          1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v1-v6-v1 top\n     *          -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left\n     *          -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,// v7-v4-v3-v2 bottom\n     *          1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v1 back\n     *      ],\n     *      indices: [\n     *          0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15,\n     *          16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n     *      ]\n     *  });\n     *\n     * if (boxGeometry instanceof SDKError) {\n     *     console.log(boxGeometry.message);\n     * } else {\n     *      const boxGeometryAgain = sceneModel.geometries[\"boxGeometry\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param geometryParams Non-compressed geometry parameters.\n     * @returns *{Geometry}*\n     *  * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this SceneModel has already been destroyed.\n     * * If this SceneModel has already been built.\n     * * Invalid GeometryParams were given.\n     * * Geometry of given ID already exists in this SceneModel.\n     * * Unsupported primitive type given.\n     * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.\n     * * Mandatory indices were not given for primitive type that is not {@link PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.\n     * * Indices out of range of vertex positions.\n     * * Indices out of range of vertex UVs.\n     * * Mismatch between given quantities of vertex positions and UVs.\n     */\n    createGeometry(geometryParams: GeometryParams): Geometry | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Geometry in SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Geometry in SceneModel - SceneModel already built\");\n        }\n        if (!geometryParams) {\n            return new SDKError(\"Failed to create Geometry in SceneModel - Parameters expected: geometryParams\");\n        }\n        if (geometryParams.id === null || geometryParams.id === undefined) {\n            return new SDKError(\"Failed to create Geometry in SceneModel - Parameter expected: geometryParams.id\");\n        }\n        const geometryId = geometryParams.id;\n        if (this.geometries[geometryId]) {\n            return new SDKError(`Failed to create Geometry in SceneModel - Geometry with this ID already created: ${geometryId}`);\n        }\n        const primitive = geometryParams.primitive;\n        if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {\n            return new SDKError(`Failed to create Geometry in SceneModel - Unsupported value for geometryParams.primitive: '${primitive}' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive`);\n        }\n        if (!geometryParams.positions) {\n            return new SDKError(\"Failed to create Geometry in SceneModel - Param expected: geometryParams.positions\");\n        }\n        if (!geometryParams.indices && primitive !== PointsPrimitive) {\n            return new SDKError(`Failed to create Geometry in SceneModel - Param expected: geometryParams.indices (required for primitive type)`);\n        }\n        if (geometryParams.uvs) {\n            if (geometryParams.uvs.length / 2 !== geometryParams.positions.length / 3) {\n                return new SDKError(\"Failed to create Geometry in SceneModel - mismatch between given quantities of vertex positions and UVs\");\n            }\n        }\n        if (geometryParams.indices) {\n            const lastPositionsIdx = geometryParams.positions.length / 3;\n            for (let i = 0, len = geometryParams.indices.length; i < len; i++) {\n                const idx = geometryParams.indices[i];\n                if (idx < 0 || idx >= lastPositionsIdx) {\n                    return new SDKError(\"Failed to create Geometry in SceneModel - indices out of range of vertex positions\");\n                }\n                if (geometryParams.uvs) {\n                    const lastUVsIdx = geometryParams.uvs.length / 2;\n                    if (idx < 0 || idx >= lastUVsIdx) {\n                        return new SDKError(\"Failed to create Geometry in SceneModel - indices out of range of vertex UVs\");\n                    }\n                }\n            }\n        }\n        const geometry = new Geometry(<GeometryCompressedParams>compressGeometryParams(geometryParams));\n        this.geometries[geometryId] = geometry;\n        return geometry;\n    }\n\n    /**\n     * Creates a new {@link @xeokit/scene!Geometry} within this SceneModel, from pre-compressed geometry parameters.\n     *\n     * * Stores the new {@link Geometry} in {@link SceneModel.geometries | SceneModel.geometries}.\n     * * Use {@link @xeokit/compression!compressGeometryParams} to pre-compress {@link @xeokit/scene!GeometryParams|GeometryParams} into {@link @xeokit/scene!GeometryCompressedParams|GeometryCompressedParams}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const boxGeometry = sceneModel.createGeometryCompressed({\n     *      id: \"boxGeometry\",\n     *      primitive: TrianglesPrimitive, // @xeokit/constants\n     *      positionsDecompressMatrix: [\n     *          0.00003052270125906143, 0, 0, 0,\n     *          0, 0.00003052270125906143, 0, 0,\n     *          0, 0, 0.00003052270125906143, 0,\n     *          -1, -1, -1, 1\n     *      ],\n     *      geometryBuckets: [\n     *          {\n     *              positionsCompressed: [\n     *                  65525, 65525, 65525, 0, 65525, 65525, 0, 0,\n     *                  65525, 65525, 0, 65525, 65525, 0, 0, 65525,\n     *                  65525, 0, 0, 65525, 0, 0, 0, 0\n     *              ],\n     *              indices: [\n     *                  0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6,\n     *                  0, 6, 1, 1, 6, 7, 1, 7, 2, 7, 4, 3, 7, 3, 2,\n     *                  4, 7, 6, 4, 6, 5\n     *              ]\n     *          }\n     *      ]\n     * });\n     *\n     * if (boxGeometry instanceof SDKError) {\n     *     console.log(boxGeometry.message);\n     * } else {\n     *      const boxGeometryAgain = sceneModel.geometries[\"boxGeometry\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param geometryCompressedParams Pre-compressed geometry parameters.\n     * @returns *{Geometry}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this SceneModel has already been destroyed.\n     * * If this SceneModel has already been built.\n     * * Invalid GeometryParams were given.\n     * * Geometry of given ID already exists in this SceneModel.\n     * * Unsupported primitive type given.\n     * * Mandatory vertex positions were not given. Vertex positions are mandatory for all primitive types.\n     * * Mandatory indices were not given for primitive type that is not {@link PointsPrimitive}. Indices are mandatory for all primitive types except PointsPrimitive.\n     * * Indices out of range of vertex positions.\n     * * Indices out of range of vertex UVs.\n     * * Mismatch between given quantities of vertex positions and UVs.\n     */\n    createGeometryCompressed(geometryCompressedParams: GeometryCompressedParams): Geometry | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to add compressed Geometry to SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to add compressed Geometry to SceneModel - SceneModel already built\");\n        }\n        if (!geometryCompressedParams) {\n            return new SDKError(\"Failed to add compressed Geometry to SceneModel - Parameters expected: geometryCompressedParams\");\n        }\n        const geometryId = geometryCompressedParams.id;\n        if (this.geometries[geometryId]) {\n            return new SDKError(`Failed to add compressed Geometry to SceneModel - Geometry with this ID already created: ${geometryId}`);\n        }\n        const primitive = geometryCompressedParams.primitive;\n        if (primitive !== PointsPrimitive && primitive !== LinesPrimitive && primitive !== TrianglesPrimitive && primitive !== SolidPrimitive && primitive !== SurfacePrimitive) {\n            return new SDKError(`Failed to add compressed Geometry to SceneModel - Unsupported value for geometryCompressedParams.primitive: '${primitive}' - supported values are PointsPrimitive, LinesPrimitive, TrianglesPrimitive, SolidPrimitive and SurfacePrimitive`);\n        }\n        const geometry = new Geometry(geometryCompressedParams);\n        this.geometries[geometryId] = geometry;\n        return geometry;\n    }\n\n    /**\n     * Creates a new {@link Mesh} within this SceneModel.\n     *\n     * * Stores the new {@link Mesh} in {@link SceneModel.meshes | SceneModel.meshes}.\n     * * A {@link Mesh} can be owned by one {@link SceneObject}, which can own multiple {@link Mesh}es.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const redBoxMesh = sceneModel.createMesh({\n     *      id: \"redBoxMesh\",\n     *      geometryId: \"boxGeometry\",\n     *      textureSetId: \"myTextureSet\",\n     *      position: [-4, -6, -4],\n     *      scale: [1, 3, 1],\n     *      rotation: [0, 0, 0],\n     *      color: [1, 0.3, 0.3]\n     * });\n     *\n     * if (redBoxMesh instanceof SDKError) {\n     *      console.log(redBoxMesh.message);\n     * } else {\n     *      const redBoxMeshAgain = sceneModel.meshes[\"redBoxMesh\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param meshParams Pre-compressed mesh parameters.\n     * @returns *{Mesh}*\n     *  * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this SceneModel has already been destroyed.\n     * * If this SceneModel has already been built.\n     * * Invalid MeshParams were given.\n     * * Mesh of given ID already exists in this SceneModel.\n     * * Specified Geometry could not be found in this SceneModel.\n     * * Specified TextureSet could not be found in this SceneModel.\n     */\n    createMesh(meshParams: MeshParams): Mesh | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create Mesh in SceneModel - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create Mesh in SceneModel - SceneModel already built\");\n        }\n        if (this.meshes[meshParams.id]) {\n            return new SDKError(`Failed to create Mesh in SceneModel - Mesh already exists with this ID: ${meshParams.id}`);\n        }\n        const geometry = this.geometries[meshParams.geometryId];\n        if (!geometry) {\n            return new SDKError(`Failed to create Mesh in SceneModel - Geometry not found: ${meshParams.geometryId}`);\n        }\n        const textureSet = meshParams.textureSetId ? this.textureSets[meshParams.textureSetId] : undefined;\n        if (meshParams.textureSetId && !textureSet) {\n            return new SDKError(`Failed to create Mesh in SceneModel - TextureSet not found: ${meshParams.textureSetId}`);\n        }\n\n        // geometry.numInstances++;\n        // let matrix = meshParams.matrix;\n        // if (!matrix) {\n        //     const position = meshParams.position;\n        //     const scale = meshParams.scale;\n        //     const rotation = meshParams.rotation;\n        //     if (position || scale || rotation) {\n        //         matrix = identityMat4();\n        //         const quaternion = eulerToQuat(rotation || [0, 0, 0], \"XYZ\", identityQuat());\n        //         composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n        //     } else {\n        //         matrix = identityMat4();\n        //     }\n        // }\n        // const meshIndex = this.meshesList.length;\n\n        const mesh = new Mesh({\n            id: meshParams.id,\n            geometry,\n            textureSet,\n            matrix: meshParams.matrix,\n            color: meshParams.color,\n            opacity: meshParams.opacity,\n            roughness: meshParams.roughness,\n            metallic: meshParams.metallic\n        });\n        this.meshes[meshParams.id] = mesh;\n        return mesh;\n    }\n\n    /**\n     * Creates a new {@link SceneObject}.\n     *\n     * * Stores the new {@link SceneObject} in {@link SceneModel.objects | SceneModel.objects} and {@link Scene.objects | Scene.objects}.\n     * * Fires an event via {@link Scene.onObjectCreated | Scene.onObjectCreated}.\n     * * Each {@link Mesh} is allowed to belong to one SceneObject.\n     * * SceneObject IDs must be unique within the SceneModel's {@link Scene}.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * const redBoxObject = sceneModel.createObject({\n     *     id: \"redBoxObject\",\n     *     meshIds: [\"redBoxMesh\"]\n     * });\n     *\n     * if (redBoxObject instanceof SDKError) {\n     *      console.log(redBoxObject.message);\n     * } else {\n     *      const redBoxObjectAgain = sceneModel.objects[\"redBoxObject\"];\n     *      const redBoxObjectOnceMore = scene.objects[\"redBoxObject\"];\n     * }\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @param objectParams SceneObject parameters.\n     * @returns *{SceneObject}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * If this SceneModel has already been destroyed.\n     * * If this SceneModel has already been built.\n     * * Invalid ObjectParams were given.\n     * * SceneObject of given ID already exists in this SceneModel's Scene. Note that SceneObject IDs must be unique within the Scene.\n     * * No Meshes were specified.\n     * * One or more of the specified Meshes already belong to another SceneObject in this SceneModel.\n     * * Specified Meshes could not be found in this SceneModel.\n     */\n    createObject(objectParams: SceneObjectParams): SceneObject | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Failed to create SceneObject - SceneModel already destroyed\");\n        }\n        if (this.built) {\n            return new SDKError(\"Failed to create SceneObject SceneModel already built\");\n        }\n        if (objectParams.meshIds.length === 0) {\n            return new SDKError(\"Failed to create SceneObject - no meshes specified\");\n        }\n        if (this.scene.objects[objectParams.id]) {\n            return new SDKError(`Failed to create SceneObject - SceneObject already exists in Scene: ${objectParams.id}`);\n        }\n        const meshIds = objectParams.meshIds;\n        const meshes = [];\n        for (let meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {\n            const meshId = meshIds[meshIdIdx];\n            const mesh = this.meshes[meshId];\n            if (!mesh) {\n                return new SDKError(`Failed to create SceneObject - Mesh not found: ${meshId}`);\n            }\n            if (this.#meshUsedByObject[meshId]) {\n                return new SDKError(`Failed to create SceneObject - Mesh ${meshId} already belongs to another SceneObject`);\n            }\n            meshes.push(mesh);\n            this.#meshUsedByObject[mesh.id] = true;\n        }\n        const sceneObject = new SceneObject({\n            id: objectParams.id,\n            layerId: objectParams.layerId || this.layerId,\n            model: this,\n            meshes\n        });\n        for (let i = 0, len = meshes.length; i < len; i++) {\n            const mesh = meshes[i];\n            mesh.object = sceneObject;\n        }\n        this.#numObjects++;\n        this.objects[objectParams.id] = sceneObject;\n        return sceneObject;\n    }\n\n    /**\n     * Finalizes this SceneModel, readying it for use.\n     *\n     * * Fires an event via {@link SceneModel.onBuilt | SceneModel.onBuilt} and {@link Scene.onModelCreated | SceneModel.onCreated}, to indicate to subscribers that\n     * the SceneModel is complete and ready to use.\n     * * Sets {@link SceneModel.built | SceneModel.built} ````true````.\n     * * You can only call this method once on a SceneModel.\n     * * The SceneModel must have at least one {@link SceneObject}.\n     * * Once built, no more components can be created in a SceneModel.\n     *\n     * ### Usage\n     *\n     * ````javascript\n     * sceneMode.onBuilt.subscribe(()=>{\n     *     // Our SceneModel is built and ready to use\n     * });\n     *\n     * myScene.onModelCreated.subscribe((sceneModel)=>{\n     *     // Another way to subscribe to SceneModel readiness\n     * });\n     *\n     * mySceneModel.build().then((result) => { // Asynchronous (texture compression etc).\n     *      if (result instanceof SDKError) {\n     *          console.log(result.message);\n     *      }  else {\n     *          // Now we can do things with our SceneModel\n     *      }\n     * }).catch(sdkError) {// SDKError\n     *     console.log(sdkError.message);\n     * };\n     * ````\n     *\n     * See {@link \"@xeokit/scene\"} for more usage info.\n     *\n     * @throws *{@link @xeokit/core!SDKError}*\n     * * If SceneModel has already been built or destroyed.\n     * * If no SceneObjects were created in this SceneModel.\n     */\n    async build(): Promise<SceneModel> {\n        return new Promise<SceneModel>((resolve) => {\n            if (this.destroyed) {\n                throw new SDKError(\"Failed to build SceneModel - SceneModel already destroyed\");\n            }\n            if (this.built) {\n                throw new SDKError(\"Failed to build SceneModel - SceneModel already built\");\n            }\n            this.#removeUnusedTextures();\n            this.#compressTextures().then(() => {\n                this.built = true;\n                this.onBuilt.dispatch(this, null);\n                resolve(this);\n            }).catch((e) => {\n                throw e;\n            });\n        });\n    }\n\n    #removeUnusedTextures() {\n        // let texturesList = [];\n        // const textures = {};\n        // for (let i = 0, leni = this.texturesList.length; i < leni; i++) {\n        //     const texture = this.texturesList[i];\n        //     if (texture.channel !== null) {\n        //         texture.textureIndex = texturesList.length;\n        //         texturesList.push(texture);\n        //         textures[texture.id] = texture;\n        //     }\n        // }\n        // this.texturesList = texturesList;\n        // this.textures = textures;\n    }\n\n    #compressTextures(): Promise<any> {\n        let countTextures = this.#texturesList.length;\n        return new Promise<void>((resolve) => {\n            if (countTextures === 0) {\n                resolve();\n                return;\n            }\n            for (let i = 0, leni = this.#texturesList.length; i < leni; i++) {\n                const texture = this.#texturesList[i];\n                const encodingOptions = TEXTURE_ENCODING_OPTIONS[texture.channel] || {};\n                if (texture.src) {  // Texture created with SceneModel#createTexture({ src: ... })\n                    const src = texture.src;\n                    const fileExt = src.split('.').pop();\n                    switch (fileExt) {\n                        case \"jpeg\":\n                        case \"jpg\":\n                        case \"png\":\n\n                            load(src, ImageLoader, {\n                                image: {\n                                    type: \"data\"\n                                }\n                            }).then((imageData) => {\n                                if (texture.compressed) {\n                                    encode(imageData, KTX2BasisWriter, encodingOptions).then((encodedData) => {\n                                        const encodedImageData = new Uint8Array(encodedData);\n                                        texture.imageData = encodedImageData;\n                                        if (--countTextures <= 0) {\n                                            resolve();\n                                        }\n                                    }).catch((err) => {\n                                        return new SDKError(`Failed to compress texture: ${err}`);\n                                    });\n                                } else {\n                                    texture.imageData = new Uint8Array(1);\n                                    if (--countTextures <= 0) {\n                                        resolve();\n                                    }\n                                }\n                            }).catch((err) => {\n                                return new SDKError(`Failed to load texture image: ${err}`);\n                            });\n                            break;\n                        default:\n                            if (--countTextures <= 0) {\n                                resolve();\n                            }\n                            break;\n                    }\n                }\n                if (texture.imageData) {// Texture created with SceneModel#createTexture({ imageData: ... })\n                    if (texture.compressed) {\n                        encode(texture.imageData, KTX2BasisWriter, encodingOptions)\n                            .then((encodedImageData) => {\n                                texture.imageData = new Uint8Array(encodedImageData);\n                                if (--countTextures <= 0) {\n                                    resolve();\n                                }\n                            }).catch((err) => {\n                            return new SDKError(`Failed to compress texture: ${err}`);\n                        });\n                    } else {\n                        texture.imageData = new Uint8Array(1);\n                        if (--countTextures <= 0) {\n                            resolve();\n                        }\n                    }\n                }\n            }\n        });\n    }\n}\n","import { isBlob } from '../../javascript-utils/is-type';\nimport { isLoaderObject } from '../loader-utils/normalize-loader';\nimport { getFetchFunction } from '../loader-utils/option-utils';\nimport { parse } from './parse';\n\nexport async function load(url, loaders, options, context) {\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  const fetch = getFetchFunction(options);\n\n  let data = url;\n  if (typeof url === 'string') {\n    data = await fetch(url);\n  }\n\n  if (isBlob(url)) {\n    data = await fetch(url);\n  }\n\n  return await parse(data, loaders, options);\n}\n//# sourceMappingURL=load.js.map","import {Component, EventEmitter, SDKError} from \"@xeokit/core\";\nimport {FloatArrayParam, MAX_DOUBLE, MIN_DOUBLE} from \"@xeokit/math\";\nimport {EventDispatcher} from \"strongly-typed-events\";\nimport {SceneModel} from \"./SceneModel\";\nimport type {SceneObject} from \"./SceneObject\";\nimport type {SceneModelParams} from \"./SceneModelParams\";\nimport {createAABB3} from \"@xeokit/boundaries\";\n\n/**\n * A scene representation.\n *\n * A Scene is a container of {@link SceneModel | SceneModels} and {@link SceneObject | SceneObjects}.\n */\nexport class Scene extends Component {\n\n    /**\n     * The {@link @xeokit/scene!SceneModel | SceneModels} belonging to this Scene, each keyed to\n     * its {@link @xeokit/scene!SceneModel.id | SceneModel.id}.\n     */\n    public readonly models: { [key: string]: SceneModel };\n\n    /**\n     * The {@link SceneObject | SceneObjects} in this Scene, mapped to {@link SceneObject.id | SceneObject.id}.\n     */\n    public readonly objects: { [key: string]: SceneObject };\n\n    /**\n     * Emits an event each time a {@link SceneModel} is created in this Scene.\n     *\n     * @event\n     */\n    public readonly onModelCreated: EventEmitter<Scene, SceneModel>;\n\n    /**\n     * Emits an event each time a {@link SceneModel} is destroyed in this Scene.\n     *\n     * @event\n     */\n    public readonly onModelDestroyed: EventEmitter<Scene, SceneModel>;\n\n    #onModelBuilts: { [key: string]: any };\n    #onModelDestroys: { [key: string]: any };\n    #center: Float64Array;\n    #aabbDirty: boolean;\n    #aabb: Float64Array;\n\n    /**\n     * Creates a new Scene.\n     *\n     * See {@link \"@xeokit/scene\"} for usage.\n     */\n    constructor() {\n\n        super(null, {});\n\n        this.#aabb = createAABB3();\n        this.#aabbDirty = true;\n\n        this.models = {};\n        this.objects = {};\n\n        this.#onModelBuilts = {};\n        this.#onModelDestroys = {};\n        this.onModelCreated = new EventEmitter(new EventDispatcher<Scene, SceneModel>());\n        this.onModelDestroyed = new EventEmitter(new EventDispatcher<Scene, SceneModel>());\n    }\n\n    /**\n     * Gets the collective World-space 3D center of all the {@link SceneModel | SceneModels} in this Scene.\n     */\n    get center(): Float64Array {\n        if (this.#aabbDirty) {\n            const aabb = this.aabb; // Lazy-build\n            this.#center[0] = (aabb[0] + aabb[3]) / 2;\n            this.#center[1] = (aabb[1] + aabb[4]) / 2;\n            this.#center[2] = (aabb[2] + aabb[5]) / 2;\n        }\n        return this.#center;\n    }\n\n    /**\n     * Gets the collective World-space 3D [axis-aligned boundary](/docs/pages/GLOSSARY.html#aabb) of all the {@link SceneModel | SceneModels} in this Scene.\n     *\n     * The boundary will be of the form ````[xMin, yMin, zMin, xMax, yMax, zMax]````.\n     */\n    get aabb(): FloatArrayParam {\n        if (this.#aabbDirty) {\n            let xmin = MAX_DOUBLE;\n            let ymin = MAX_DOUBLE;\n            let zmin = MAX_DOUBLE;\n            let xmax = MIN_DOUBLE;\n            let ymax = MIN_DOUBLE;\n            let zmax = MIN_DOUBLE;\n            let aabb;\n            const objects = this.objects;\n            let valid = false;\n            for (const objectId in objects) {\n                if (objects.hasOwnProperty(objectId)) {\n                    const object = objects[objectId];\n                    // if (object.collidable === false) {\n                    //     continue;\n                    // }\n                    aabb = object.aabb;\n                    if (aabb[0] < xmin) {\n                        xmin = aabb[0];\n                    }\n                    if (aabb[1] < ymin) {\n                        ymin = aabb[1];\n                    }\n                    if (aabb[2] < zmin) {\n                        zmin = aabb[2];\n                    }\n                    if (aabb[3] > xmax) {\n                        xmax = aabb[3];\n                    }\n                    if (aabb[4] > ymax) {\n                        ymax = aabb[4];\n                    }\n                    if (aabb[5] > zmax) {\n                        zmax = aabb[5];\n                    }\n                    valid = true;\n                }\n            }\n            if (!valid) {\n                xmin = -100;\n                ymin = -100;\n                zmin = -100;\n                xmax = 100;\n                ymax = 100;\n                zmax = 100;\n            }\n            this.#aabb[0] = xmin;\n            this.#aabb[1] = ymin;\n            this.#aabb[2] = zmin;\n            this.#aabb[3] = xmax;\n            this.#aabb[4] = ymax;\n            this.#aabb[5] = zmax;\n            this.#aabbDirty = false;\n        }\n        return this.#aabb;\n    }\n\n    /**\n     * Creates a new {@link @xeokit/scene!SceneModel} in this Scene.\n     *\n     * Remember to call {@link SceneModel.build | SceneModel.build} when you've finished building or loading the SceneModel. That will\n     * fire events via {@link Scene.onModelCreated | Scene.onModelCreated} and {@link SceneModel.onBuilt | SceneModel.onBuilt}, to\n     * indicate to any subscribers that the SceneModel is built and ready for use.\n     *\n     * See {@link \"@xeokit/scene\"} for more details on usage.\n     *\n     * @param  sceneModelParams Creation parameters for the new {@link @xeokit/scene!SceneModel}.\n     * @returns *{@link SceneModel}*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Scene has already been destroyed.\n     * * A SceneModel with the given ID already exists in this Scene.\n     */\n    createModel(sceneModelParams: SceneModelParams): SceneModel | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Scene already destroyed\");\n        }\n        const id = sceneModelParams.id;\n        if (this.models[id]) {\n            return new SDKError(`SceneModel already created in this Scene: ${id}`);\n        }\n        const sceneModel = new SceneModel(this, sceneModelParams);\n        this.models[id] = sceneModel;\n        sceneModel.onDestroyed.one(() => { // SceneModel#destroy() called\n            delete this.models[sceneModel.id];\n            this.#deregisterObjects(sceneModel);\n            this.onModelDestroyed.dispatch(this, sceneModel);\n        });\n        sceneModel.onBuilt.one(() => { // SceneModel#build() called\n            this.#registerObjects(sceneModel);\n            this.onModelCreated.dispatch(this, sceneModel);\n        });\n        return sceneModel;\n    }\n\n    /**\n     * @private\n     */\n    setAABBDirty() {\n        if (!this.#aabbDirty) {\n            this.#aabbDirty = true;\n            //this.events.fire(\"aabb\", true);\n        }\n    }\n\n    /**\n     * Destroys all contained {@link SceneModel | SceneModels}.\n     *\n     * * Fires {@link Scene.onModelDestroyed | Scene.onModelDestroyed} and {@link SceneModel.onDestroyed | SceneModel.onDestroyed}\n     * for each existing SceneModel in this Scene.\n     *\n     * See {@link \"@xeokit/scene\"} for usage.\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Scene has already been destroyed.\n     */\n    clear(): void | SDKError {\n        if (this.destroyed) {\n            return new SDKError(\"Scene already destroyed\");\n        }\n        for (let id in this.models) {\n            this.models[id].destroy();\n        }\n    }\n\n    /**\n     * Destroys this Scene and all contained {@link SceneModel | SceneModels}.\n     *\n     * * Fires {@link Scene.onModelDestroyed | Scene.onModelDestroyed} and {@link SceneModel.onDestroyed | SceneModel.onDestroyed}\n     * for each existing SceneModels in this Data.\n     * * Unsubscribes all subscribers to {@link Scene.onModelCreated | Scene.onModelCreated}, {@link Scene.onModelDestroyed | Scene.onModelDestroyed}, {@link SceneModel.onDestroyed | SceneModel.onDestroyed}\n     *\n     * See {@link \"@xeokit/scene\"} for usage.\n     *\n     * @returns *void*\n     * * On success.\n     * @returns *{@link @xeokit/core!SDKError}*\n     * * This Scene has already been destroyed.\n     */\n    destroy(): void | SDKError {\n        this.clear();\n        this.onModelCreated.clear();\n        this.onModelDestroyed.clear();\n        super.destroy();\n    }\n\n    #registerObjects(model: SceneModel) {\n        const objects = model.objects;\n        for (let id in objects) {\n            const object = objects[id];\n            this.objects[object.id] = <SceneObject>object;\n        }\n        this.#aabbDirty = true;\n    }\n\n    #deregisterObjects(model: SceneModel) {\n        const objects = model.objects;\n        for (let id in objects) {\n            const object = objects[id];\n            delete this.objects[object.id];\n        }\n        this.#aabbDirty = true;\n    }\n}"],"names":["assert","condition","message","Error","isBrowser","Boolean","process","String","browser","version","exec","globals","self","window","global","document","global_","isWorker","importScripts","isMobile","orientation","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","arg","input","hint","prim","toPrimitive","undefined","res","call","TypeError","toPropertyKey","Object","defineProperty","enumerable","configurable","writable","WorkerJob","jobName","workerThread","this","name","result","Promise","resolve","reject","_resolve","_reject","postMessage","type","payload","source","done","isRunning","error","Worker","terminate","workerURLCache","Map","getLoadableWorkerURLFromSource","workerSource","blob","Blob","URL","createObjectURL","getTransferList","object","recursive","arguments","length","transfers","transfersSet","Set","isTransferable","add","buffer","ArrayBuffer","isView","Array","from","MessagePort","ImageBitmap","OffscreenCanvas","getTransferListForWriter","clone","assign","keys","forEach","RegExp","NOOP","WorkerThread","static","NodeWorker","props","url","onMessage","onError","console","log","worker","_createBrowserWorker","_createNodeWorker","destroy","terminated","data","transferList","_getErrorFromErrorEvent","event","concat","lineno","colno","_loadableURL","workerURL","get","startsWith","set","getLoadableWorkerURL","onmessage","onerror","onmessageerror","includes","eval","on","code","WorkerPool","isSupported","setProps","idleQueue","isDestroyed","maxConcurrency","maxMobileConcurrency","reuseWorkers","onDebug","async","job","startPromise","onStart","jobQueue","push","_startQueuedJob","_getAvailableWorker","queuedJob","shift","backlog","returnWorkerToQueue","count","_getMaxConcurrency","toLowerCase","DEFAULT_PROPS","WorkerFarm","_workerFarm","workerPools","workerPool","values","_getWorkerPoolProps","getWorkerPool","options","NPM_TAG","VERSION","getWorkerURL","workerOptions","id","workerFile","workerUrl","_workerType","module","versionTag","processOnWorker","context","warning","getWorkerName","workerFarm","getWorkerFarm","workerPoolProps","startJob","bind","transferableOptions","warn","loadLibraryPromises","loadLibrary","libraryUrl","moduleName","library","modules","CDN","getLibraryUrl","endsWith","response","fetch","arrayBuffer","node","node.requireFromFile","scriptSource","script","createElement","appendChild","createTextNode","e","text","body","loadLibraryFromString","loadLibraryFromFile","parseWithWorker","loader","parseOnMainThread","JSON","parse","stringify","concatenateArrayBuffers","_len","sources","_key","sourceArrays","map","source2","Uint8Array","byteLength","reduce","typedArray","offset","sourceArray","pathPrefix","fileAliases","resolvePath","filename","alias","replace","toArrayBuffer","isBuffer","node.toArrayBuffer","byteOffset","slice","TextEncoder","encode","_toArrayBuffer","BASIS_CDN_ENCODER_WASM","BASIS_CDN_ENCODER_JS","loadBasisEncoderPromise","KTX2BasisWriter","extensions","useSRGB","qualityLevel","encodeUASTC","mipmaps","image","BasisEncoder","basisEncoder","BASIS_ENCODER","wasmBinary","all","globalThis","BASIS","BasisEncoderModule","then","BasisFile","KTX2File","initializeBasis","initializeBasisEncoderModule","loadBasisEncoder","loadBasisEncoderModule","basisFileData","width","height","setCreateKTX2File","setKTX2UASTCSupercompression","setKTX2SRGBTransferFunc","setSliceSourceImage","setPerceptual","setMipSRGB","setQualityLevel","setUASTC","setMipGen","numOutputBytes","subarray","delete","_parseImageNode","IMAGE_SUPPORTED","Image","IMAGE_BITMAP_SUPPORTED","NODE_IMAGE_SUPPORTED","DATA_SUPPORTED","SVG_DATA_URL_PATTERN","SVG_URL_PATTERN","isSVG","test","getBlob","parseToImage","blobOrDataUrl","xmlText","TextDecoder","decode","unescape","encodeURIComponent","btoa","getBlobOrSVGDataUrl","webkitURL","objectUrl","src","onload","err","loadToImage","revokeObjectURL","EMPTY_OBJECT","imagebitmapOptionsSupported","BIG_ENDIAN","LITTLE_ENDIAN","getBinaryImageMetadata","binaryData","dataView","toDataView","getUint32","mimeType","getPngMetadata","getUint16","getUint8","tableMarkers","sofMarkers","i","getJpegMarkers","marker","has","getJpegMetadata","getGifMetadata","getBmpMetadata","DataView","ImageLoader","mimeTypes","imageType","getDefaultImageType","isImageTypeSupported","getLoadableImageType","imagebitmapOptions","imagebitmap","isEmptyObject","createImageBitmap","safeCreateImageBitmap","parseToImageBitmap","parseToNodeImage","format","getImageTypeOrNull","getImageType","canvas","getContext","drawImage","getImageData","tests","he","ie","je","ke","le","createAABB3","Float64Array","collapseAABB3","aabb","MAX_DOUBLE","MIN_DOUBLE","expandAABB3Points3","positions","x","y","z","len","createVec3","createMat4","newFloatArray","GeometryBucket","geometryBucketParams","positionsCompressed","uvsCompressed","colorsCompressed","indices","edgeIndices","Geometry","params","primitive","positionsDecompressMatrix","uvsDecompressMatrix","geometryBuckets","rendererGeometry","_positionsDecompressed","_classPrivateFieldLooseKey","_positionsWorld","geometryView","GeometryViewImpl","mesh","meshIndex","geometry","geometryBucket","geometryBucketIndex","_classPrivateFieldLooseBase","reset","_createClass","totalGeometryBuckets","meshes","primitiveType","TrianglesPrimitive","LinesPrimitive","Float32Array","decompressPositions3","positionsDecompressed","transformPositions3","matrix","getSceneObjectGeometry","sceneObject","withEachGeometry","j","lenj","_aabb","_aabbDirty","SceneObject","cfg","model","layerId","rendererObject","setAABBDirty","_this","positionsWorld","TextureSet","textureSetParams","textures","colorTexture","metallicRoughnessTexture","occlusionTexture","emissiveTexture","rendererTextureSet","Texture","rendererTexture","imageData","buffers","compressed","mediaType","magFilter","minFilter","wrapS","wrapT","wrapR","flipY","encoding","preloadColor","channel","RepeatWrapping","createVec4","_color","_matrix","_metallic","_roughness","_opacity","Mesh","meshParams","textureSet","rendererMesh","identityMat4","color","metallic","roughness","opacity","setColor","setMatrix","setMetallic","setRoughness","uniquePositions","indicesLookup","indicesReverseLookup","weldedIndices","faces","numFaces","compa","Uint16Array","compb","compc","a","b","c","cb","ab","cross","normal","comparePositions","compareVertex","seqInit","bucketsForIndices","compareBuckets","aa1","aa2","aa3","bb1","bb2","bb3","aa","bb","minBucketA","Math","min","minBucketB","maxBucketA","max","maxBucketB","compressGeometryParams","geometryParams","uniquePositionsCompressed","quantizePositions3","SolidPrimitive","SurfacePrimitive","edgeThreshold","vx","vy","vz","positionsMap","precision","pow","lenUniquePositions","round","weldVertices","numIndices","ia","ib","ic","decompressPoint3","subVec3","cross3Vec3","normalizeVec3","face","buildFaces","edge1","edge2","index1","index2","edge","thresholdDot","cos","DEGTORAD","edges","largeIndex","faceIndex","face1","face2","dotVec3","Uint32Array","buildEdgeIndices","_uniquifyPositions","maxPositions","setMaxNumberOfPositions","seq","remappings","sort","uniqueIdx","uniqueEdgeIndices","uniqueIndices","uniquifyPositions","uvs","bitsPerBucket","checkResult","Int32Array","sortedIndices","preSortIndices","edgeSearch","el0","el1","tmp","compare_fn","m","n","k","cmp","alreadyOutputEdgeIndices","fill","numPositions","bucketIndicesRemap","buckets","addEmptyBucket","newBucket","maxNumPositions","bucketNumber","currentBucket","additonalPositionsInBucket","ii0","ii1","ii2","edgeIndex","newBytesPerIndex","originalSize","newSize","bucket","meshDict","doCheckResult","rebucketPositions","isFunction","isObject","isPureObject","isIterable","isAsyncIterable","asyncIterator","isResponse","Response","json","isBlob","isReadableStream","ReadableStream","tee","cancel","getReader","isReadableDOMStream","read","pipe","isBoolean","readable","isReadableNodeStream","DATA_URL_PATTERN","MIME_TYPE_PATTERN","parseMIMEType","mimeString","matches","parseMIMETypeFromURL","QUERY_STRING_PATTERN","getResourceUrlAndType","resource","stripQueryString","headers","makeResponse","contentLength","size","getResourceContentLength","initialDataUrl","blobSlice","reader","FileReader","_event$target","target","readAsDataURL","base64","binary","bytes","fromCharCode","arrayBufferToBase64","getInitialDataUrl","fetchFile","fetchOptions","mockUserAgent","versions","realUserAgent","navigator","userAgent","indexOf","isElectron","window_","process_","__VERSION__","checkIfBrowser","LocalStorage","defaultConfig","storage","setItem","removeItem","getStorage","config","_loadConfiguration","getConfiguration","setConfiguration","configuration","serialized","serializedConfiguration","getItem","formatImage","scale","maxWidth","imageUrl","style","floor","join","COLOR","getColor","toUpperCase","WHITE","getHiResTimestamp","timestamp","_window$performance","_window$performance$n","performance","now","_process$hrtime","timeParts","hrtime","Date","originalConsole","debug","info","DEFAULT_SETTINGS","enabled","level","noop","cache","ONCE","once","Log","userData","_storage","timeStamp","predefined","proto","getPrototypeOf","propNames","getOwnPropertyNames","find","autobind","seal","newLevel","setLevel","getLevel","isEnabled","getTotal","Number","_startTs","toPrecision","getDelta","_deltaTs","priority","newPriority","getPriority","enable","setting","settings","table","_getLogFunction","deprecated","oldUsage","newUsage","removed","probe","logLevel","time","args","columns","tag","getTableHeader","_ref","_shouldLog","_ref3","img","element","nodeName","toDataURL","logImageInBrowser","timeEnd","group","opts","collapsed","normalizeArguments","method","groupCollapsed","groupEnd","withGroup","func","trace","normalizeLogLevel","total","delta","string","padLength","repeat","leftPad","ms","formatted","toFixed","formatTime","background","decorateMessage","resolvedLevel","isFinite","unshift","messageType","title","probeLog","NullLog","DEFAULT_LOADER_OPTIONS","nothrow","_len2","_key2","_len3","_key3","_len4","_key4","_nodeWorkers","limit","_limitMB","batchSize","batchDebounceMs","metadata","transforms","REMOVED_LOADER_OPTIONS","throws","dataType","uri","mode","credentials","redirect","referrer","referrerPolicy","integrity","keepalive","signal","getGlobalLoaderState","loaders","_state","getGlobalLoaderOptions","state","globalOptions","getFetchFunction","validateOptionsObject","defaultOptions","deprecatedOptions","loaderName","prefix","isSubOptions","suggestion","findSimilarOption","optionKey","lowerCaseOptionKey","bestSuggestion","lowerCaseKey","mergeNestedFields","mergedOptions","isLoaderObject","_loader","isArray","normalizeLoader","_loader2","_loader3","parseTextSync","parseText","getGlobalLoaderRegistry","loaderRegistry","EXT_PATTERN","selectLoaderSync","validHTTPResponse","candidateLoaders","ignoreRegisteredLoaders","normalizeLoaders","testUrl","reason","findLoaderByMIMEType","match","extension","loaderExtension","findLoaderByExtension","findLoaderByUrl","testDataAgainstText","testDataAgainstBinary","findLoaderByInitialBytes","getFirstCharacters","fallbackMimeType","selectLoaderInternal","getNoValidLoaderMessage","status","slashIndex","lastIndexOf","substr","path.filename","firstCharacters","testText","some","arrayBuffer1","arrayBuffer2","array1","array2","compareArrayBuffers","getMagicString","testBinary","magic","DEFAULT_CHUNK_SIZE","makeStreamIterator","stream","nextBatchPromise","currentBatchPromise","_streamReadAhead","releaseLock","makeBrowserStreamIterator","chunk","makeNodeStreamIterator","ERR_DATA","contextLoaders","getLoadersFromContext","selectLoader","previousContext","resolvedContext","getLoaderContext","validateOptions","baseUri","addUrlOptions","normalizeOptionsInternal","normalizeOptions","ok","redirected","statusText","fromEntries","entries","isArrayBuffer","getArrayBufferOrStringFromDataSync","contentType","getResponseError","checkResponse","chunkSize","textEncoder","chunkLength","makeStringIterator","chunkByteLength","makeArrayBufferIterator","end","makeBlobIterator","makeIterator","arrayBuffers","concatenateArrayBuffersAsync","getArrayBufferOrStringFromData","canParseWithWorker","parseSync","parseWithLoader","writer","canEncodeWithWorker","getLoaderOptions","encodeSync","encodeText","encodeInBatches","batches","dataIterator","start","getIterator","chunks","batch","encodeURLtoURL","tmpInputFilename","getTemporaryFilename","filePath","arrayBufferOrString","fs.writeFile","flag","writeFile","tmpOutputFilename","outputFilename","inputUrl","outputUrl","TEXTURE_ENCODING_OPTIONS","_texturesList","_numObjects","_meshUsedByObject","_removeUnusedTextures","_compressTextures","SceneModel","_Component","scene","sceneModelParams","_assertThisInitialized","_compressTextures2","_removeUnusedTextures2","built","geometries","textureSets","objects","onBuilt","rendererModel","EventEmitter","EventDispatcher","onDestroyed","fromJSON","_inheritsLoose","_proto","destroyed","SDKError","createGeometry","createTexture","createTextureSet","createMesh","createObject","createTransform","transformParams","textureParams","split","pop","texture","normalsTexture","colorTextureId","metallicRoughnessTextureId","normalsTextureId","emissiveTextureId","occlusionTextureId","geometryId","PointsPrimitive","lastPositionsIdx","idx","createGeometryCompressed","geometryCompressedParams","textureSetId","objectParams","meshIds","meshIdIdx","meshIdLen","meshId","build","_this2","dispatch","Component","_this3","countTextures","_loop","encodingOptions","load","encodedData","encodedImageData","leni","_onModelBuilts","_onModelDestroys","_center","_registerObjects","_deregisterObjects","Scene","_deregisterObjects2","_registerObjects2","models","onModelCreated","onModelDestroyed","createModel","sceneModel","one","clear","xmin","ymin","zmin","xmax","ymax","zmax","valid","objectId","hasOwnProperty"],"mappings":"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"}